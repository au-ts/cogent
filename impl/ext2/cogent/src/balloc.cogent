--
-- Copyright 2016, NICTA
--
-- This software may be distributed and modified according to the terms of
-- the GNU General Public License version 2. Note that NO WARRANTY is provided.
-- See "LICENSE_GPLv2.txt" for details.
--
-- @TAG(NICTA_GPL)
--

------------------------------------------------------------------------------
-- block goal rules
------------------------------------------------------------------------------

type NonZeroObsv = (VfsInode!, Indirect!)

ext2_find_near_2: (FsState!, VfsInode!, Indirect!) -> BlockPtr
ext2_find_near_2 (state, inode, indirect) =
  -- 2) try location of indirect block, if possible
  indirect.buf
  | Some buf -> osbuffer_get_blocknum buf
  | None ->
    -- 3) referred to from inode; use same cylinder group (colouring it)
    let bg = get_block_group_from_ino (state.super.inodes_per_group, vfs_inode_get_ino (inode))
    and bg_start = group_desc_first_block2 (state, bg)

    and colour = (os_get_pid () % 16) * (state.super.blocks_per_group / 16)
    in (bg_start + colour)

is_block_nonzero: Seq32_body () NonZeroObsv BlockPtr
is_block_nonzero #{acc, obsv = (inode, indirect), idx} =
  let blockptr = indirect_read_blockptr_at (indirect, inode, idx)
  in if blockptr /= 0 then ((), Break blockptr) else ((), Iterate ())

ext2_find_near: (FsState!, VfsInode!, Indirect!) -> BlockPtr
ext2_find_near (state, inode, indirect) =   
  -- 1) look at block pointer data (either bh or inode blocks)
  --    to the left of us, and search for one that's non-zero,
  --    and try to allocate near that

  -- prevent underflow (doesn't happen in ptr land)
  if indirect.offset > 0 !indirect then
    let (ptr, res) = seq32_rev [(), NonZeroObsv, BlockPtr] #{
        frm  = indirect.offset - 1,
        to   = 0,
        step = 1,
        f    = is_block_nonzero,
        acc  = (),
        obsv = (inode, indirect)}

    in res
    | Break blockptr -> blockptr
    | Iterate () ->
      -- no luck, try second rule
      ext2_find_near_2 (state, inode, indirect)
  else
    ext2_find_near_2 (state, inode, indirect)

ext2_find_goal: (FsState!, VfsInode!, U32, Indirect!) -> U32
ext2_find_goal (state, inode, iblock, indirect) =
  -- TODO: implement this!
  -- check inode's internal block allocator
  -- and try to allocate sequentially

  -- otherwise, just try and settle for something nearby
  ext2_find_near (state, inode, indirect)

------------------------------------------------------------------------------
-- block allocation and placement algorithms
------------------------------------------------------------------------------

type FindFreeBlockgroupAcc = (ExState, FsState, U32)
type FindFreeBlockgroupRet = (Ext2GroupDescriptor, OSBuffer)

find_free_blockgroup: Seq32_body FindFreeBlockgroupAcc () FindFreeBlockgroupRet
find_free_blockgroup #{acc = (ex, state, block_group), obsv = (), idx} =
  let block_group = block_group + 1
  and block_group = if block_group >= state.group_count then 0 else block_group !state

  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "find_free_blockgroup: checking block group ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, block_group) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

  and ((ex, state), res) = group_desc_and_buf_from_block_group (ex, state, block_group)
  in res
  | Success (group_desc, group_desc_buf) =>
    let have_free_blocks = group_desc.free_block_count > 0 !group_desc
    in if have_free_blocks then
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "find_free_blockgroup: block group ") 
      and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, block_group) 
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " had free blocks!\n") 

      in ((ex, state, block_group), Break (group_desc, group_desc_buf))
    else
      let ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)
      in ((ex, state, block_group), Iterate ())
  | Error () ->
    ((ex, state, block_group), Iterate ())

ext2_write_new_block: (ExState, FsState, VfsInode, OSBuffer, U32, Ext2GroupDescriptor, OSBuffer, U32, U16) -> RR (ExState, FsState, VfsInode) (U32, BlockPtr) U32
ext2_write_new_block (ex, state, inode, group_desc_buf, block_group, group_desc, bitmap_buf, grp_alloc_blk, num) =
  let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_write_new_block: using block group ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, block_group) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " and free block bit ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, grp_alloc_blk) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

  and dest_block = grp_alloc_blk + block_group * state.super.blocks_per_group + state.super.first_data_block !state
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_write_new_block: this resolves to block ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, dest_block) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

  and num32 : U32 = upcast num

  -- check if we're allocating it over a system block
  and was_invalid = in_range_u32 (group_desc.block_bitmap, dest_block, dest_block + num32) || 
                    in_range_u32 (group_desc.inode_bitmap, dest_block, dest_block + num32) || 
                    in_range_u32 (dest_block, group_desc.inode_table, group_desc.inode_table + state.inode_tables_per_group) ||
                    in_range_u32 (dest_block + num32 - 1, group_desc.inode_table, group_desc.inode_table + state.inode_tables_per_group) !state 
  in was_invalid
  | True ->
    let _ = _cogent_warn "ext2_write_new_block: ERROR: wanted to allocate at block "
    and _ = _cogent_warn_u32 dest_block
    and _ = _cogent_warn " but in system zone of block group "
    and _ = _cogent_warn_u32 block_group
    and _ = _cogent_warn "!\n"

    and ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)
    and ex = osbuffer_destroy (ex, bitmap_buf)
    in ((ex, state, inode), Error eIO)
  | _ =>
    -- cool, mark it allocated!
    let (ex, bitmap_buf) = osbuffer_dirty (ex, bitmap_buf)

    -- update inode i_blocks and i_bytes (latter is linux only)
    and inode = vfs_inode_add_bytes (inode, upcast num << upcast const_blockSizeBits)

    and outside_block_count = dest_block > state.super.block_count !state
    in outside_block_count
    | False =>
      -- update group descriptor
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_write_new_block: have free block count ") 
      and _ = _cogent_log_u16 (dbg_EXT2_DIR_BALLOC, group_desc.free_block_count) 
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "; updating\n") 

      and (ex, group_desc_buf) = group_desc_set_free_block_count (ex, block_group, group_desc_buf, group_desc.free_block_count - num) !group_desc
      and ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)

      -- TODO: sync bitmap buffer if we are MS_SYNCHRONOUS

      -- update super
      and state_t { super_buf, super } = state
      and super_t { free_block_count } = super

      and free_block_count = free_block_count - num32
      and (ex, super_buf) = super_set_free_block_count (ex, super_buf, free_block_count)

      and super = super_t { free_block_count  }
      and state = state_t { super, super_buf }

      -- cleanup
      and ex = osbuffer_destroy (ex, bitmap_buf)

      -- finished
      in ((ex, state, inode), Success (num32, dest_block))
    | True ->
      let _ = _cogent_warn "ext2_write_new_block: ERROR: block num "
      and _ = _cogent_warn_u32 dest_block
      and _ = _cogent_warn " outside superblock's block count\n"

      and ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)
      and ex = osbuffer_destroy (ex, bitmap_buf)
      in ((ex, state, inode), Error eIO)

bit_was_zero: Seq32_body U32 OSBuffer ()
bit_was_zero #{ acc = goal_bit, obsv = bitmap_buf, idx } =
  if goal_bit > 0 then
    if osbuffer_test_bit (bitmap_buf, goal_bit - 1) then
      (goal_bit, Break ())
    else
      (goal_bit - 1, Break ())
  else
    (goal_bit, Break ())

-- just work back and call ext2_write_new_block
-- assumes buffer contains at least one free bit
find_first_free_block_in_chunk: (OSBuffer!, U32) -> U32
find_first_free_block_in_chunk (bitmap_buf, goal_bit) =
  let (goal_bit, _) = seq32 [U32, OSBuffer, ()] #{
    frm  = 0,
    to   = 7,
    step = 1,
    f    = bit_was_zero,
    acc  = goal_bit,
    obsv = bitmap_buf }

  in goal_bit

-- second half of find_next_usable_block
find_next_usable_block2: (OSBuffer!, U32, U32) -> R U32 ()
find_next_usable_block2 (bitmap_buf, goal_bit, end) =
  let remainder_offset = goal_bit >> 3
  and empty_chunk_offset = osbuffer_find (bitmap_buf, 0, remainder_offset, ((end + 7) >> 3) - (goal_bit >> 3)) !bitmap_buf
  and free_block_chunk = (empty_chunk_offset - remainder_offset) << 3
  in if free_block_chunk < end && free_block_chunk >= goal_bit then
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "find_next_usable_block2: found free block chunk before it(?) at ") 
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, free_block_chunk) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

    in Success free_block_chunk
  else
    -- no byte chunk free; try each individual bit
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "find_next_usable_block2: no byte chunk free, trying each individual bit\n") 

    and free_block = osbuffer_find_next_zero_bit (bitmap_buf, end, goal_bit) !bitmap_buf
    in if free_block < end then
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "find_next_usable_block2: found one at bit ") 
      and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, free_block) 
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 
      in Success free_block
    else
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "none found; sorry!\n") 
      in Error ()

find_next_usable_block: (OSBuffer!, U32, U32) -> R U32 ()
find_next_usable_block (bitmap_buf, goal_bit, end) =
  if goal_bit > 0 then
    let end_goal = (goal_bit + 63) .&. complement 63 -- FIXME: does this belong in here? masks for 64 bit
    and end_goal = if end_goal > end then end else end_goal

    and goal_bit = osbuffer_find_next_zero_bit (bitmap_buf, end_goal, goal_bit) !bitmap_buf
    in if goal_bit < end_goal then
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "find_next_usable_block: found goal bit near goal\n") 
      in Success goal_bit
    else
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "find_next_usable_block: found goal bit not found near goal; searching again\n") 
      in find_next_usable_block2 (bitmap_buf, goal_bit, end)
  else
    find_next_usable_block2 (bitmap_buf, goal_bit, end)

allocate_many_in_group: Seq32_body (OSBuffer, U32, U32) U32 ()
allocate_many_in_group #{ acc = (buf, allocated, goal), obsv = end, idx } =
  if goal < end then
    -- try to set bit
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "allocate_many_in_group: trying bit ") 
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, goal) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

    and (buf, res) = osbuffer_set_bit (buf, goal)
    in res
    | False ->
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "allocate_many_in_group: was set\n") 
      in ((buf, allocated + 1, goal + 1), Iterate ())
    | _ ->
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "allocate_many_in_group: was already set, stopping\n") 
      in ((buf, allocated, goal), Break ())
  else
    ((buf, allocated, goal), Break ())

allocate_find_first: Seq32_body (OSBuffer, U32, U32) () ()
allocate_find_first #{ acc = (buf, allocated, _), obsv, idx } =
  let (buf, res) = osbuffer_set_bit (buf, idx)
  in res
  | False ->
    ((buf, allocated + 1, idx), Break ())
  | _ ->
    ((buf, allocated, idx + 1), Iterate ())

-- NOTE: we do *not* handle retrying block allocation as Linux does, since we expect that there is a single
-- thread running this code. if this becomes not the case, you must implement a check when doing set_bit. see balloc.c:718
ext2_try_to_allocate_with_bitmap3: (ExState, FsState, U32, OSBuffer, U32, U32, U32, U32) -> RR (ExState, FsState, OSBuffer) (U16, BlockPtr) U32
ext2_try_to_allocate_with_bitmap3 (ex, state, group, bitmap_buf, num, goal, start, end) =
  let allocated:U32 = 0

  -- find first one we can definitely allocate
  and ((bitmap_buf, allocated, goal), res) = seq32 [(OSBuffer, U32, U32), (), ()] #{
    frm  = goal,
    to   = end,
    step = 1,
    f    = allocate_find_first,
    acc  = (bitmap_buf, allocated, goal),
    obsv = () }

  in res
  | Break () ->
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_try_to_allocate_with_bitmap3: allocated initial block at ") 
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, goal) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

    -- try the rest from the same location
    and ((bitmap_buf, allocated, goal), _) = seq32 [(OSBuffer, U32, U32), U32, ()] #{
      frm  = allocated,
      to   = num,
      step = 1,
      f    = allocate_many_in_group,
      acc  = (bitmap_buf, allocated, goal + 1),
      obsv = (end) }
    
    -- XXX: oh man these casts/these ladders https://www.youtube.com/watch?v=ggB33d0BLcY
    in ((ex, state, bitmap_buf), Success (u32_to_u16 allocated, goal - allocated))
  | Iterate () ->
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_try_to_allocate_with_bitmap3: could not find free bit in range\n") 
    in ((ex, state, bitmap_buf), Success (0, goal))

ext2_try_to_allocate_with_bitmap2: (ExState, FsState, U32, OSBuffer, U32, Option U32, U32, U32) -> RR (ExState, FsState, OSBuffer) (U16, BlockPtr) U32
ext2_try_to_allocate_with_bitmap2 (ex, state, group, bitmap_buf, num, maybe_goal, start, end) =
  maybe_goal
  | None ->
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_try_to_allocate_with_bitmap2: had no goal, finding next usable block\n") 
    in find_next_usable_block (bitmap_buf, start, end) !bitmap_buf
    | Success goal ->
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_try_to_allocate_with_bitmap2: got goal bit ") 
      and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, goal) 
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "; finding first free block in chunk\n") 

      -- TODO: only do this if we have no block reservations
      and goal = find_first_free_block_in_chunk (bitmap_buf, goal) !bitmap_buf

      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_try_to_allocate_with_bitmap2: final goal bit (first free block in chunk) was ") 
      and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, goal) 
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

      in ext2_try_to_allocate_with_bitmap3 (ex, state, group, bitmap_buf, num, goal, goal, end)
    | Error () ->
      -- failed to find anything
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_try_to_allocate_with_bitmap2: ERROR: no usable block\n") 
      in ((ex, state, bitmap_buf), Success (0, 0))
  | Some goal ->
    ext2_try_to_allocate_with_bitmap3 (ex, state, group, bitmap_buf, num, goal, goal, end)

-- try to allocate at `num' blocks in a given block group
ext2_try_to_allocate_with_bitmap: (ExState, FsState, U32, OSBuffer, U32, Option U32) -> RR (ExState, FsState, OSBuffer) (U16, BlockPtr) U32
ext2_try_to_allocate_with_bitmap (ex, state, group, bitmap_buf, num, maybe_goal_block) =
  let end = state.super.blocks_per_group !state
  in maybe_goal_block
  | Some goal_block ->
    if goal_block > 0 then -- FIXME: why? these branches are the same? is it < end instead?
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_try_to_allocate_with_bitmap: had goal and > 0, using [") 
      and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, goal_block) 
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, ", ") 
      and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, end) 
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, ")\n") 
      in ext2_try_to_allocate_with_bitmap2 (ex, state, group, bitmap_buf, num, maybe_goal_block, goal_block, end)
    else 
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_try_to_allocate_with_bitmap: had goal but == 0, using [0, ") 
      and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, end) 
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, ")\n") 
      in ext2_try_to_allocate_with_bitmap2 (ex, state, group, bitmap_buf, num, maybe_goal_block, 0, end)
  | None ->
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_try_to_allocate_with_bitmap: had no goal, using [0, ") 
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, end) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, ")\n") 
    in ext2_try_to_allocate_with_bitmap2 (ex, state, group, bitmap_buf, num, maybe_goal_block, 0, end)

-- loop through the rest of the groups to find a free block
ext2_new_block2: (ExState, FsState, VfsInode, U32, U32) -> RR (ExState, FsState, VfsInode) (U32, BlockPtr) U32
ext2_new_block2 (ex, state, inode, goal_block_group, num) =
  let group_count = state.group_count !state

  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_new_block2: going to search ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, group_count) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " block groups\n") 

  and ((ex, state, block_group), res) = seq32 [FindFreeBlockgroupAcc, (), FindFreeBlockgroupRet] #{
    frm  = 0,
    to   = group_count, -- FIXME: surely - 1, since we don't need to check the above? Linux does them all though..
    step = 1,
    f    = find_free_blockgroup,
    acc  = (ex, state, goal_block_group),
    obsv = () }
  in res
  | Break (group_desc, group_desc_buf) =>
    let ((ex, state), res) = get_block_bitmap (ex, state, group_desc.block_bitmap)
    in res
    | Success bitmap_buf =>
      let ((ex, state, bitmap_buf), res) = ext2_try_to_allocate_with_bitmap (ex, state, block_group, bitmap_buf, num, None)
      in res
      | Success (num', grp_alloc_blk) =>
        if num' > 0 then
          -- we allocated!
          ext2_write_new_block (ex, state, inode, group_desc_buf, block_group, group_desc, bitmap_buf, grp_alloc_blk, num')
        else
          let _ = _cogent_warn ("ext2_new_block2: invalid free block count in block group ")
          and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, block_group)
          and _ = _cogent_warn ("; reported free blocks but no bits\n")

          and ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)
          and ex = osbuffer_destroy (ex, bitmap_buf)
          in ((ex, state, inode), Error eIO)
      | Error e ->
        let ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)
        and ex = osbuffer_destroy (ex, bitmap_buf)
        in ((ex, state, inode), Error e)
    | Error () ->
      let ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)
      in ((ex, state, inode), Error eIO)
  | Iterate () ->
    -- sorry, no free block groups left!
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_new_block2: no free block groups remaining\n")
    in ((ex, state, inode), Error eNoSpc)

-- TODO: reservation windows
-- TODO: check reserved blocks for root
ext2_new_blocks: (ExState, FsState, VfsInode, BlockPtr, U32) -> RR (ExState, FsState, VfsInode) (U32, BlockPtr) U32
ext2_new_blocks (ex, state, inode, goal, num) =
  let outside_range = goal < state.super.first_data_block || goal >= state.super.block_count !state
  and goal = if outside_range then state.super.first_data_block else goal !state
  and blocks_per_group = state.super.blocks_per_group !state

  and goal_block_group = (goal - state.super.first_data_block) / blocks_per_group !state

  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_new_blocks: outside range = ") 
  and _ = _cogent_log_bool (dbg_EXT2_DIR_BALLOC, outside_range) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, ", goal = ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, goal) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, ", goal_block_group = ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, goal_block_group) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

  and ((ex, state), res) = group_desc_and_buf_from_block_group (ex, state, goal_block_group)
  in res
  | Success (group_desc_goal, group_desc_buf_goal) =>
    let have_free_blocks = group_desc_goal.free_block_count > 0 !group_desc_goal
    in if have_free_blocks then
      let grp_target_blk = ((goal - state.super.first_data_block)) % blocks_per_group !state

      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_new_block: block group ") 
      and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, goal_block_group) 
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " has some free blocks, going to allocate in its bitmap; target is bit ") 
      and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, grp_target_blk) 
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

      and ((ex, state), res) = get_block_bitmap (ex, state, group_desc_goal.block_bitmap)
      in res 
      | Success (bitmap_buf) =>
        let ((ex, state, bitmap_buf), res) = ext2_try_to_allocate_with_bitmap (ex, state, goal_block_group, bitmap_buf, num, Some grp_target_blk)
        in res
        | Success (num', grp_alloc_blk) =>
          if num' > 0 then
            -- we allocated!
            let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_new_block: allocated " ) 
            and _ = _cogent_log_u16 (dbg_EXT2_DIR_BALLOC, num') 
            and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " blocks starting at bit ") 
            and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, grp_alloc_blk) 
            and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, ", going to write!\n") 

            in ext2_write_new_block (ex, state, inode, group_desc_buf_goal, goal_block_group, group_desc_goal, bitmap_buf, grp_alloc_blk, num')
          else
            -- failed to allocate at goal; try all the block groups
            -- FIXME: old code used to retry with no target, then try all groups
            let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_new_block: failed to allocate at goal, trying all block groups\n") 

            and ((ex, state), _) = put_group_desc_buf_in_array (ex, state, goal_block_group, group_desc_buf_goal)
            and ex = osbuffer_destroy (ex, bitmap_buf)

            in ext2_new_block2 (ex, state, inode, goal_block_group, num)
        | Error err ->
          let ((ex, state), _) = put_group_desc_buf_in_array (ex, state, goal_block_group, group_desc_buf_goal)
          and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_new_block: ERROR: failed to allocate within bitmap\n") 
          and ex = osbuffer_destroy (ex, bitmap_buf)

          in ((ex, state, inode), Error eIO)
      | Error () ->
        let ((ex, state), _) = put_group_desc_buf_in_array (ex, state, goal_block_group, group_desc_buf_goal)
        and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_new_block: failed to get block bitmap for blockgroup\n") 
        in ext2_new_block2 (ex, state, inode, goal_block_group, num)
    else
      -- this block group failed, try all the other block groups
      let ((ex, state), _) = put_group_desc_buf_in_array (ex, state, goal_block_group, group_desc_buf_goal)
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_new_block: no free blocks in block group, going to try all\n") 

      in ext2_new_block2 (ex, state, inode, goal_block_group, num)
  | Error () ->
    let _ = _cogent_warn "ext2_new_block: ERROR: did not get group_desc/buf from block group "
    and _ = _cogent_warn_u32 goal_block_group
    and _ = _cogent_warn "\n"

    in ((ex, state, inode), Error eIO)

------------------------------------------------------------------------------
-- raw block allocation for n-many blocks
------------------------------------------------------------------------------

ext2_alloc_block_many: Seq32_body (WordArray BlockPtr, U32, U32, BlockPtr) U32 ()
ext2_alloc_block_many #{ acc = (ptrs, count, indirect_index, current_block), obsv = indirect_blocks, idx } =
  if indirect_index < indirect_blocks then
    let ptrs = wordarray_put2[BlockPtr] #{ arr = ptrs, idx = indirect_index, val = current_block }
    in ((ptrs, count - 1, indirect_index + 1, current_block + 1), Iterate ())
  else
    ((ptrs, count, indirect_index, current_block), Break ())

ext2_alloc_block: Seq32_body (ExState, FsState, VfsInode, WordArray BlockPtr, U32, U32, U32, BlockPtr) (BlockPtr, U32) U32
ext2_alloc_block #{ acc = (ex, state, inode, ptrs, target, count, indirect_index, current_block), obsv = (goal, indirect_blocks), idx } =
  let count = target

  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_alloc_block: trying one-go allocation for ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, count) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " blocks\n") 

  and ((ex, state, inode), res) = ext2_new_blocks (ex, state, inode, goal, count)
  in res
  | Success (count, current_block) =>
    let target = target - count
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_alloc_block: allocated ") 
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, count) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " blocks, ") 
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, target) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " remaining.\n") 

    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_alloc_block: last blockptr = ") 
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, current_block) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "; putting them all into blockptr array\n") 

    -- map over indirect blocks & count
    and ((ptrs, count, indirect_index, current_block), res) = seq32_rev [(WordArray BlockPtr, U32, U32, U32), U32, ()] #{
      frm  = count,
      to   = 1,
      step = 1,
      f    = ext2_alloc_block_many,
      acc  = (ptrs, count, indirect_index, current_block),
      obsv = (indirect_blocks) }

    in if count > 0 then
      -- everything after this is are multiple direct blocks
      ((ex, state, inode, ptrs, target, count, indirect_index, current_block), Break 0)
    else
      ((ex, state, inode, ptrs, target, count, indirect_index, current_block), Iterate ())
  | Error e ->
    ((ex, state, inode, ptrs, target, count, indirect_index, current_block), Break e)

-- just do the allocation for n blocks
ext2_alloc_blocks: (ExState, FsState, VfsInode, WordArray BlockPtr, U32, BlockPtr, U32) -> RR (ExState, FsState, VfsInode, WordArray BlockPtr) U32 U32
ext2_alloc_blocks (ex, state, inode, blockptrs, num_indirect, goal, num_blocks) =
  let target = num_blocks + num_indirect

  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_alloc_blocks: going to allocate " ) 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, target) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " block total\n") 

  and ((ex, state, inode, blockptrs, _, count, indirect_index, current_block), res) = seq32 [(ExState, FsState, VfsInode, WordArray BlockOffset, U32, U32, U32, U32), (U32, U32), U32] #{
    frm  = 0,
    to   = target,
    step = 1,
    f    = ext2_alloc_block,
    acc  = (ex, state, inode, blockptrs, target, num_blocks, 0, 0),
    obsv = (goal, num_indirect)
  }

  in res
  | Iterate () -> ext2_alloc_blocks_last (ex, state, inode, blockptrs, indirect_index, current_block, count)
  | Break e ->
    if e == 0 then
      -- early exit, wasn't actually failure
      ext2_alloc_blocks_last (ex, state, inode, blockptrs, indirect_index, current_block, count)
    else
      -- FIXME: handle error case properly and deallocate blocks we just allocated!
      ((ex, state, inode, blockptrs), Error e)

ext2_alloc_blocks_last: (ExState, FsState, VfsInode, WordArray BlockPtr, U32, BlockPtr, U32) -> RR (ExState, FsState, VfsInode, WordArray BlockPtr) U32 U32
ext2_alloc_blocks_last (ex, state, inode, blockptrs, indirect_index, current_block, count) =
  let blockptrs = wordarray_put2 [BlockPtr] #{ arr = blockptrs, idx = indirect_index, val = current_block }
  in ((ex, state, inode, blockptrs), Success count)

------------------------------------------------------------------------------
-- block deallocation
------------------------------------------------------------------------------

ext2_free_data_inode: (ExState, FsState, VfsInode, U32, U32) -> (ExState, FsState, VfsInode)

------------------------------------------------------------------------------
-- truncation
------------------------------------------------------------------------------

fsop_can_truncate: (ExState, FsState, VfsInode!) -> ((ExState, FsState), R () U32)
fsop_can_truncate (ex, state, inode) =
    let mode = vfs_inode_get_mode (inode) .&. s_IFMT
    in if not (mode == vfs_type_reg || mode == vfs_type_dir || mode == vfs_type_link) then
      ((ex, state), Error eInval)
    else
      let fast_symlink = ext2_inode_is_fast_symlink inode
      in if fast_symlink then
        ((ex, state), Error eInval)
      else
        let flags = vfs_inode_get_flags inode
        in if (flags .&. s_APPEND) /= 0 || (flags .&. s_IMMUTABLE) /= 0 then
          -- note: Linux doesn't handle APPEND case either (bug, apparently?)
          ((ex, state), Error ePerm)
        else
          ((ex, state), Success ())

ext2_truncate_blocks: (ExState, FsState, VfsInode, U64) -> RR (ExState, FsState, VfsInode) () U32
ext2_truncate_blocks (ex, state, inode, new_size) =
    let ((ex, state), res) = fsop_can_truncate (ex, state, inode) !inode
    in res
    | Success () =>
      -- sweet, let's go!
      ext2_truncate_blocks2 (ex, state, inode, new_size)
    | Error err ->
      ((ex, state, inode), Error err)

-- aka __ext2_truncate_blocks in Linux
ext2_truncate_blocks2: (ExState, FsState, VfsInode, U64) -> RR (ExState, FsState, VfsInode) () U32
ext2_truncate_blocks2 (ex, state, inode, offset) =
    --let addr_per_block  = const_addrPerBlock
    --let blocksize = const_blockSize
    let iblock = (offset + upcast const_blockSize - 1) >> upcast const_blockSizeBits

    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_truncate_blocks2: getting path to logical block ") 
    and _ = _cogent_log_u64 (dbg_EXT2_DIR_BALLOC, iblock) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

    and ((ex, state), res) = path_new_from_block (ex, state, u64_to_u32 iblock) -- XXX: cast
    in res
    | Success path =>
      if path.depth /= 0 !path then
        if path.depth == 1 !path then
          let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_truncate_blocks2: path was single level (just at inode level)\n") 

          -- free first level (inode level)
          and frm = wordarray_get [BlockOffset] (path.offsets, 0) !path
          and to = const_numDirectBlocks

          and (ex, state, inode, no_buf) = ext2_free_data (ex, state, inode, None, frm, to)
          and ex = dispose_existing_buffer (ex, no_buf) -- should actually be None, but ensure it is free'd
          in ext2_truncate_blocks_subtrees (ex, state, inode, offset, path)
        else
          let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_truncate_blocks2: path had depth > 1, finding shared\n") 

          and (state, res) = chain_init (state, path)
          in res
          | Success chain =>
            let ((ex, inode, chain), res) = chain_find_shared (ex, inode, chain)
            in res
            | Success (top, partial_idx) =>
              -- top is now detatched
              if top /= 0 then
                -- had a top, need to free that branch  
                if partial_idx == 0 then
                  -- grows from inode
                  let (ex, inode) = vfs_inode_mark_dirty (ex, inode)
                  and (ex, state, inode, root) = ext2_free_branches (ex, state, inode, None, top, top + 1, chain.path.depth - partial_idx) !chain
                  and ex = branchnode_free (ex, root) -- should be None, but for type system

                  in ext2_truncate_blocks_ind_shared (ex, state, inode, offset, chain, partial_idx)
                else
                  -- grows from indirect
                  let (ex, inode) = chain_dirty_buffer_inode (ex, chain, partial_idx, inode) !chain -- dirty it

                  and (ex, state, inode, root) = ext2_free_branches (ex, state, inode, None, top, top + 1, chain.path.depth - partial_idx) !chain
                  and ex = branchnode_free (ex, root) -- should be None, but for type system

                  in ext2_truncate_blocks_ind_shared (ex, state, inode, offset, chain, partial_idx)
              else
                -- no top, so no need to kill it!
                ext2_truncate_blocks_ind_shared (ex, state, inode, offset, chain, partial_idx)
            | Error () ->
              -- couldn't find shared, return eIO (may mean we can never free that block??)
              let (ex, state, path) = chain_restore (ex, state, chain)
              and (ex, state) = path_restore (ex, state, path)

              in ((ex, state, inode), Error eIO) 
          | Error path ->
            let (ex, state) = path_restore (ex, state, path)

            in ((ex, state, inode), Error eIO) 
      else
        -- easy, we're done if we have no path
        let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_truncate_blocks2: path had empty depth, so we're done (bad block nr?)\n") 

        and (ex, state) = path_restore (ex, state, path)
        in ((ex, state, inode), Success ())
    | Error () ->
      -- easy, we're done if we have no path
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_truncate_blocks2: failed to get path\n") 
      in ((ex, state, inode), Success ())

ext2_truncate_blocks_ind_shared: (ExState, FsState, VfsInode, U64, Chain, IndirectIdx) -> RR (ExState, FsState, VfsInode) () U32
ext2_truncate_blocks_ind_shared (ex, state, inode, offset, chain, partial_idx) =
  -- clear ends of indirect blocks on shared branch
  let to:U32 = 1

  and ((ex, state, inode, chain), _) = seq32_rev [(ExState, FsState, VfsInode, Chain), (), ()] #{
    frm = partial_idx,
    to,
    step = 1,
    f    = free_indirect_on_shared,
    acc  = (ex, state, inode, chain),
    obsv = ()
  }

  -- kill the rest of the full subtrees
  and (ex, state, path) = chain_restore (ex, state, chain)
  in ext2_truncate_blocks_subtrees (ex, state, inode, offset, path)

free_indirect_on_shared: Seq32_body (ExState, FsState, VfsInode, Chain) () ()
free_indirect_on_shared #{ acc = (ex, state, inode, chain), obsv, idx } = 
  let (chain, maybe_indirect, indirect_idx) = chain_pop_indirect (chain)
  in maybe_indirect
  | Some indirect =>
    let indirect_t { blockptr, buf } = indirect

    -- buf should exist, it's an indirect
    and (ex, state, inode, root) = ext2_free_branches (ex, state, inode, buf, blockptr + 1, const_addrPerBlock, chain.path.depth - chain.indirect_count) !chain
    and root_t { maybe_buf } = root

    and (ex, chain) = indirect_restore_taken (ex, chain, indirect_t, indirect_idx)

    in maybe_buf
    | Some buf =>
      let inode = vfs_inode_add_dirty_osbuffer (inode, buf) !buf
      and ex = osbuffer_destroy (ex, buf)

      in ((ex, state, inode, chain), Iterate ())
    | None ->
      -- should've been there, but whatever..
      ((ex, state, inode, chain), Iterate ())
  | None ->
    -- should've been there, but whatever..
    ((ex, state, inode, chain), Iterate ())

-- from do_indirects goto label
ext2_truncate_blocks_subtrees: (ExState, FsState, VfsInode, U64, Path) -> RR (ExState, FsState, VfsInode) () U32
ext2_truncate_blocks_subtrees (ex, state, inode, offset, path) =
  let first_offset = wordarray_get[BlockOffset] (path.offsets, 0) !path
  and (ex, state) = path_restore (ex, state, path)

  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_truncate_blocks_subtrees: have first offset ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, first_offset) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

  in first_offset
  | 15 -> -- triple indirect
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_truncate_blocks_subtrees: was triple indirect, we're done!\n") 
    in ((ex, state, inode), Success ())
  | 14 -> -- double indirect
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_truncate_blocks_subtrees: was double indirect, killing triple indirect tree\n") 
    in (kill_subtree (ex, state, inode, const_tripleIndirectIdx, 3), Success ())
  | 13 -> -- single indirect
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_truncate_blocks_subtrees: was single indirect, killing double and triple indirect trees\n") 

    and (ex, state, inode) = kill_subtree (ex, state, inode, const_doubleIndirectIdx, 2)
    in                       (kill_subtree (ex, state, inode, const_tripleIndirectIdx, 3), Success ())
  | _ -> -- direct inode
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_truncate_blocks_subtrees: was direct; killing single, double and triple indirect trees\n") 

    and (ex, state, inode) = kill_subtree (ex, state, inode, const_singleIndirectIdx, 1)
    and (ex, state, inode) = kill_subtree (ex, state, inode, const_doubleIndirectIdx, 2)
    in                       (kill_subtree (ex, state, inode, const_tripleIndirectIdx, 3), Success ())

kill_subtree: (ExState, FsState, VfsInode, U32, Depth) -> (ExState, FsState, VfsInode)
kill_subtree (ex, state, inode, idx, depth) =
  let nr = wordarray_get [BlockPtr] (inode.fs.block_pointers, idx) !inode
  in if nr /= 0 then
    let inode_t { fs } = inode
    and fs_t { block_pointers } = fs

    -- set ptr to 0
    and block_pointers = wordarray_put2 [BlockPtr] #{ arr = block_pointers, idx, val = 0 }

    and fs = fs_t { block_pointers }
    and inode = inode_t { fs }

    -- mark dirty
    and (ex, inode) = vfs_inode_mark_dirty (ex, inode)

    -- free the remaining branch
    and (ex, state, inode, root) = ext2_free_branches (ex, state, inode, None, nr, nr + 1, depth)
    and ex = branchnode_free (ex, root) -- should be None, but type system

    in (ex, state, inode)
  else
    (ex, state, inode)


type BranchNode = #{
  maybe_buf:    Option OSBuffer, -- if buf, ptr = buf[idx * 4], else ptr = idx (we only have indirects here)
  ptr:          BlockPtr,        -- only relevant for children
  offset_from:  OSBufferOffset,
  offset_to:    OSBufferOffset
}

branchnode_free: (ExState, BranchNode) -> ExState
branchnode_free (ex, node) =
  let node_t {maybe_buf} = node
  in dispose_existing_buffer (ex, maybe_buf)

_branchnode_debug: (BranchNode!) -> ()
_branchnode_debug node =
  let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "offset_from=") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, node.offset_from) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " offset_to=") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, node.offset_to) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " ptr=") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, node.ptr) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " buf=") 
  in node.maybe_buf
  | Some buf -> _cogent_log (dbg_EXT2_DIR_BALLOC, "true") 
  | None -> _cogent_log (dbg_EXT2_DIR_BALLOC, "false") 

-- kicks off the depth limited search over some branches in the tree between [from, to)
ext2_free_branches: (ExState, FsState, VfsInode, Option OSBuffer, U32, U32, U32) -> (ExState, FsState, VfsInode, BranchNode)
ext2_free_branches (ex, state, inode, maybe_buf, offset_from, offset_to, depth) =
  let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branches: freeing [") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, offset_from) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, ", ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, offset_to) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, ") at depth ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, depth) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

  and (root, (ex, state, inode)) = dls_uarray [BranchNode, (ExState, FsState, VfsInode), U32] #{
    curdepth = 0,
    maxdepth = depth + 1, -- +1 for leaf blocks
    f        = ext2_free_branch,
    acc      = (ex, state, inode),
    root     = #{ maybe_buf, ptr = 0, offset_from, offset_to },
    obsv     = depth
  }

  in (ex, state, inode, root)

-- recursive function that frees a branch, and sub-branches
ext2_free_branch: GraphExplorerF (UArray BranchNode) BranchNode (ExState, FsState, VfsInode) (U32)
ext2_free_branch (depth, node, (ex, state, inode), maxdepth) =
  let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch: depth ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, depth) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, ", ") 
  and _ = _branchnode_debug (node) !node
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

  in if depth < maxdepth then
    -- fill up array of child nodes
    let childnode_array_size = node.offset_to - node.offset_from !node
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch: created array of size ") 
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, childnode_array_size) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

    in uarray_create [BranchNode] (ex, childnode_array_size)
    | Success (ex, children) =>
      let node_t { maybe_buf } = node

      and (children, (ex, inode, _, maybe_buf)) = uarray_map_no_break [BranchNode, (ExState, VfsInode, U32, Option OSBuffer), ()] #{
        arr    = children,
        frm    = 0,
        to     = childnode_array_size,
        f      = ext2_free_branch_entry,
        acc    = (ex, inode, node_t.offset_from, maybe_buf),
        obsv   = ()
      } !node_t

      and node = node_t { maybe_buf }

      -- recurse on children
      in (node, (ex, state, inode), Expand (children, ext2_free_branch_cleanup))
    | Error ex ->
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch: failed to allocate array\n") 

      -- couldn't make array, skip this one
      in (node, (ex, state, inode), Iterate ())
  else
    -- leaf node, free the data here
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch: was leaf node (depth + 1 >= maxdepth)\n") 

    and frm = node.offset_from !node
    and to = node.offset_to !node
    and node_t { maybe_buf } = node

    and (ex, state, inode, maybe_buf) = ext2_free_data (ex, state, inode, maybe_buf, frm, to)

    and node = node_t { maybe_buf }
    in (node, (ex, state, inode), Iterate ())

-- generates a single child for a given branch (called over a map)
ext2_free_branch_entry: UArrayMapNoBreakF BranchNode (ExState, VfsInode, U32, Option OSBuffer) ()
ext2_free_branch_entry #{ oelem = no_branchnode, acc = (ex, inode, idx, parent_maybe_buf), obsv } =
  no_branchnode
  | None =>
    -- deref offset to blockptr
    parent_maybe_buf
    | Some buf =>
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch_entry: parent had buffer, deserialising from idx ") 
      and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, idx * 4)
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 
      in osbuffer_deserialise_Ple32 (buf, idx * 4) !buf
      | Success (nr, _) =>
        if nr /= 0 then
          let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch_entry: had non-zero blockptr ") 
          and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, nr) 
          and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " WITH parent buffer (zero-ing and returning child ptr to it)\n") 

          -- unlink it
          -- writes blockptr 0 at offset in buf
          and (parent_maybe_buf, inode) = indirect_set_reference (Some buf, inode, idx, 0)

          -- resolve blockptr to buffer
          and (ex, res) = ext2_get_block (ex, nr)
          in res
          | Success child_buf =>
            (Some #{maybe_buf = Some child_buf, ptr = nr, offset_from = 0, offset_to = const_addrPerBlock }, (ex, inode, idx + 1, parent_maybe_buf))
          | Error () ->
            -- if no buffer, warn and iterate
            let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch_entry: failed to get new block\n") 
            in (None, (ex, inode, idx + 1, parent_maybe_buf))
        else
          -- if no blockptr, ignore
          let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch_entry: null blockptr WITH parent buffer\n") 
          in (None, (ex, inode, idx + 1, Some buf))
      | Error () ->
        -- failed to read from buf, ignore
        let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch_entry: failed to deserialise from offset\n") 
        in (None, (ex, inode, idx + 1, Some buf))
    | None ->
      if idx /= 0 then
        let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch_entry: had non-zero blockptr ") 
        and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, idx) 
        and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " with NO parent buffer\n") 

        -- no need to set ptr since it is usually a stack address

        and (ex, res) = ext2_get_block (ex, idx)
        in res
        | Success child_buf =>
          (Some #{ maybe_buf = Some child_buf, ptr = idx, offset_from = 0, offset_to = const_addrPerBlock }, (ex, inode, idx + 1, None))
        | Error () ->
          let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch_entry: failed to get new block\n") 
          in (None, (ex, inode, idx + 1, None))
      else
        let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch_entry: null blockptr with NO parent buffer\n") 

        -- was null blockptr
        in (None, (ex, inode, idx + 1, None))
  | Some bn ->
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch_entry: had non-null branchnode? impossible?\n") 

    -- impossible, we just allocated the array, nothing should be there yet
    -- just return it back, unmodified
    in (Some bn, (ex, inode, idx + 1, parent_maybe_buf))

-- you CAN'T do this per node because the DLS API doesn't know that each node needs to be cleaned up multiple times.
ext2_free_branch_cleanup: ContinuationF (UArray BranchNode) BranchNode (ExState, FsState, VfsInode) (U32)
ext2_free_branch_cleanup (depth, root, (ex, state, inode), maxdepth, children) =
  let (ex, (state, inode)) = uarray_freeacc [BranchNode, (FsState, VfsInode), ()] #{
    arr  = children,
    f    = ext2_free_branch_cleanup2,
    ex,
    acc  = (state, inode),
    obsv = () }

  in (root, (ex, state, inode))

-- recall, we need to do this per-child (it sits inside the while offset_from < offset_to)
ext2_free_branch_cleanup2: FreeAccF BranchNode (FsState, VfsInode) ()
ext2_free_branch_cleanup2 (ex, node, (state, inode), obsv) =
  let node_t { maybe_buf, ptr } = node

  in maybe_buf
  | Some buf =>
    -- bforget the buffer
    let ex = osbuffer_trash (ex, buf)
    in ext2_free_branch_cleanup3 (ex, state, inode, ptr)
  | None ->
    ext2_free_branch_cleanup3 (ex, state, inode, ptr)

ext2_free_branch_cleanup3: (ExState, FsState, VfsInode, BlockPtr) -> (ExState, (FsState, VfsInode))
ext2_free_branch_cleanup3 (ex, state, inode, blockptr) =
  -- finally, release this block
  let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_branch_cleanup3: finally releasing block ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, blockptr) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " now that children are cleared\n") 

  and (ex, state, inode) = ext2_free_blocks (ex, state, inode, blockptr, 1)

  -- and mark inode dirty (which will cause the *ptr = 0 to be written out later)
  and (ex, inode) = vfs_inode_mark_dirty (ex, inode)
  in (ex, (state, inode))


-- attempts to group consecutive blocks together where possible, and free them
ext2_free_data: (ExState, FsState, VfsInode, Option OSBuffer, OSBufferOffset, OSBufferOffset) -> (ExState, FsState, VfsInode, Option OSBuffer)
ext2_free_data (ex, state, inode, maybe_buffer, from, to) =
  let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_data: freeing from ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, from) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " to ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, to) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "; checking contiguous\n") 

  and ((ex, state, inode, maybe_buffer, count, block_to_free), _) = seq32 [(ExState, FsState, VfsInode, Option OSBuffer, U32, U32), (), ()] #{
    frm  = from,
    to,
    step = 1,
    f    = free_data_consecutive,
    acc  = (ex, state, inode, maybe_buffer, 0, 0),
    obsv = ()
  }

  in if count > 0 then
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_data: found at least one non-zero block, going to free ") 
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, count) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " starting at ") 
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, block_to_free) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

    and (ex, state, inode) = ext2_free_blocks (ex, state, inode, block_to_free, count)
    and (ex, inode) = vfs_inode_mark_dirty (ex, inode)
    in (ex, state, inode, maybe_buffer)
  else
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_data: all were zero'd?\n") 
    in (ex, state, inode, maybe_buffer)

free_data_consecutive: Seq32_body (ExState, FsState, VfsInode, Option OSBuffer, U32, U32) () ()
free_data_consecutive #{ acc = (ex, state, inode, maybe_buf, count, block_to_free), obsv = (), idx } =
  let ptr = indirect_dereference (maybe_buf, inode, idx) !maybe_buf !inode
  in if ptr /= 0 then
    -- zero ptr
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "free_data_consecutive: non-zero at idx ") 
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, idx) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "; setting ref to 0\n") 

    and (maybe_buf, inode) = indirect_set_reference (maybe_buf, inode, idx, 0)

    -- accumulate contiguous
    in if count == 0 then
      let block_to_free = ptr
      and count:U32 = 1

      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "free_data_consecutive: had no count so far, setting to 1, and making block to free ") 
      and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, block_to_free) 
      and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

      in ((ex, state, inode, maybe_buf, count, block_to_free), Iterate ())
    else
      if block_to_free == ptr - count then
        let count = count + 1
        and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "free_data_consecutive: was consecutive\n") 
        in ((ex, state, inode, maybe_buf, count, block_to_free), Iterate ())
      else
        -- free what we had so far
        let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "free_data_consecutive: not consecutive, freeing what we have so far\n") 

        and (ex, state, inode) = ext2_free_blocks (ex, state, inode, block_to_free, count)
        and (ex, inode) = vfs_inode_mark_dirty (ex, inode)

        -- and start a new contiguous region
        and block_to_free = ptr
        and count:U32 = 1

        and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "free_data_consecutive: starting new region at block ") 
        and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, block_to_free) 
        and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

        in ((ex, state, inode, maybe_buf, count, block_to_free), Iterate ())
  else
    --let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "free_data_consecutive: idx ") 
    --and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, idx) 
    --and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, " was zero\n") 

    ((ex, state, inode, maybe_buf, count, block_to_free), Iterate ())

-- actually deallocates a group of blocks
ext2_free_blocks: (ExState, FsState, VfsInode, BlockPtr, U32) -> (ExState, FsState, VfsInode)
ext2_free_blocks (ex, state, inode, block, count) =
  if block < state.super.first_data_block ||
   block + count < block || -- wrap around
   block + count > state.super.block_count !state then

    let _ = _cogent_warn "freeing blocks not in datazone; block ="
    and _ = _cogent_warn_u32 block
    and _ = _cogent_warn ", count = "
    and _ = _cogent_warn_u32 count
    and _ = _cogent_warn "\n"

    in (ex, state, inode)
  else
    let ((ex, state, block, count, freed), res) = seq32 [(ExState, FsState, U32, U32, U32), (), ()] #{
      frm   = 0,
      to    = count, -- upper bound IS ACTUALLY THE NUMBER OF BLOCK GROUPS!!!
      step  = 1,
      f     = ext2_free_blocks2,
      acc   = (ex, state, block, count, 0),
      obsv  = ()
    }

    in if freed > 0 then
      -- update block count
      let inode = vfs_inode_sub_bytes (inode, upcast freed << upcast const_blockSizeBits)

      -- dirty it
      and (ex, inode) = vfs_inode_mark_dirty (ex, inode)
      in (ex, state, inode)
    else
      let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_blocks: warning: free'd 0 blocks\n") 
      in (ex, state, inode)

ext2_free_blocks2: Seq32_body (ExState, FsState, U32, U32, U32) () ()
ext2_free_blocks2 #{ acc = (ex, state, block, count, freed), obsv = (), idx } =
  let overflow:U32 = 0
  and block_group = (block - state.super.first_data_block) / state.super.blocks_per_group !state
  and bit = (block - state.super.first_data_block) % state.super.blocks_per_group !state

  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_blocks2: block group ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, block_group) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "; bit ") 
  and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, bit) 
  and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 

  -- are we freeing across a boundary?
  in if bit + count > state.super.blocks_per_group !state then
    let overflow = bit + count - state.super.blocks_per_group !state

    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_blocks2: freeing across a boundary; have overflow") 
    and _ = _cogent_log_u32 (dbg_EXT2_DIR_BALLOC, overflow) 
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "; removing from count\n") 

    and count = count - overflow
    in ext2_free_blocks3 (ex, state, overflow, block, block_group, bit, count, freed)
  else
    ext2_free_blocks3 (ex, state, overflow, block, block_group, bit, count, freed)

ext2_free_blocks3: (ExState, FsState, U32, U32, U32, U32, U32, U32) -> LRR (ExState, FsState, U32, U32, U32) ()
ext2_free_blocks3 (ex, state, overflow, block, block_group, bit, count, freed) =
  let ((ex, state), res) = group_desc_and_buf_from_block_group (ex, state, block_group)
  in res
  | Success (group_desc, group_desc_buf) =>
    let ((ex, state), res) = get_block_bitmap (ex, state, group_desc.block_bitmap) 
    in res
    | Success bitmap_buf =>
      if in_range_u32 (group_desc.block_bitmap, block, block + count) ||
        in_range_u32 (group_desc.inode_bitmap, block, block + count) ||
        in_range_u32 (block, group_desc.inode_table, group_desc.inode_table + state.inode_tables_per_group) ||
        in_range_u32 (block + count - 1, group_desc.inode_table, group_desc.inode_table + state.inode_tables_per_group) !state then

          let _ = _cogent_warn "freeing blocks in system zones; block = "
          and _ = _cogent_warn_u32 block
          and _ = _cogent_warn ", count = "
          and _ = _cogent_warn_u32 count
          and _ = _cogent_warn "\n"

          and ex = osbuffer_destroy (ex, bitmap_buf)
          and ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)

          in ((ex, state, block, count, freed), Break ()) -- error_return
      else
        -- clear bitmaps
        let ((bitmap_buf, group_freed), _) = seq32 [(OSBuffer, U32), (U32, U32), ()] #{
          frm   = 0,
          to    = count,
          step  = 1,
          f     = free_block_group,
          acc   = (bitmap_buf, 0),
          obsv  = (block, bit)
        }

        -- dirty bitmap
        and (ex, bitmap_buf) = osbuffer_dirty (ex, bitmap_buf)

        -- free it
        and ex = osbuffer_destroy (ex, bitmap_buf)

        -- TODO: check if sync

        -- fix up group desc with new free block count
        and (ex, state) = group_adjust_blocks (ex, state, block_group, group_desc, group_desc_buf, group_freed)
        and freed = freed + group_freed

        -- update super
        and state_t { super_buf, super } = state
        and super_t { free_block_count } = super

        and free_block_count = free_block_count + group_freed
        and (ex, super_buf) = super_set_free_block_count (ex, super_buf, free_block_count)

        and super = super_t { free_block_count  }
        and state = state_t { super, super_buf }

        in if overflow > 0 then
          let block = block + count
          and count = overflow
          in ((ex, state, block, count, freed), Iterate ())
        else
          ((ex, state, block, count, freed), Break ()) -- finished
    | Error () ->
      let _ = _cogent_warn "ext2_free_blocks3: could not get bitmap buf from block "
      and _ = _cogent_warn_u32 group_desc.block_bitmap
      and _ = _cogent_warn "\n"

      and ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)
      in ((ex, state, block, count, freed), Break ()) -- error_return      
  | Error () ->
    let _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "ext2_free_blocks3: failed to get group desc for block group ") 
    and _ = _cogent_warn_u32 block_group
    and _ = _cogent_log (dbg_EXT2_DIR_BALLOC, "\n") 
    in ((ex, state, block, count, freed), Break ()) -- error_return

group_adjust_blocks: (ExState, FsState, U32, Ext2GroupDescriptor, OSBuffer, U32) -> (ExState, FsState)
group_adjust_blocks (ex, state, block_group, group_desc, group_desc_buf, count) =
  if count > 0 then
      let prev_block_count = group_desc.free_block_count !group_desc
      and new_count = prev_block_count + u32_to_u16 count
      and group_desc = group_desc { free_block_count = new_count } -- XXX: cast

      -- write out to buffer
      and (ex, group_desc_buf) = group_desc_set_free_block_count (ex, block_group, group_desc_buf, new_count)

      -- dirty
      and (ex, group_desc_buf) = osbuffer_dirty (ex, group_desc_buf)

      and ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)
      in (ex, state)
  else 
    let ((ex, state), _) = put_group_desc_buf_in_array (ex, state, block_group, group_desc_buf)
    in (ex, state)

free_block_group: Seq32_body (OSBuffer, U32) (U32, U32) ()
free_block_group #{ acc = (buf, group_freed), obsv = (block, bit), idx } =
  let (buf, res) = osbuffer_clear_bit (buf, bit + idx)
  in if res then
    ((buf, group_freed + 1), Iterate ())
  else
    let _ = _cogent_warn "free_block_group: bit already cleared on block "
    and _ = _cogent_warn_u32 (block + idx)
    and _ = _cogent_warn "\n"

    in ((buf, group_freed), Iterate ())
