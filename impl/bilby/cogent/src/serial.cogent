--
-- Copyright 2016, NICTA
--
-- This software may be distributed and modified according to the terms of
-- the GNU General Public License version 2. Note that NO WARRANTY is provided.
-- See "LICENSE_GPLv2.txt" for details.
--
-- @TAG(NICTA_GPL)
--

-- Potential suggestions:
-- anonymous fields
-- free object recursively
-- tags that has to be previous fields
-- deserialise error offset and array index

include <gum/wordarray.cogent>
include <gum/array.cogent>
include <gum/buffer.cogent>
include <gum/crc32.cogent>
include <gum/errno.cogent>
include "../src/ubi.cogent"

bilbyFsMagic : U32
bilbyFsMagic = 0x0b17b9f5

bilbyFsXinfoMask : U64
bilbyFsXinfoMask = 0x1fffffff

bilbyFsXinfoShift : U64
bilbyFsXinfoShift = 29

inum_from_obj_id : ObjId -> VfsIno
inum_from_obj_id oid = u64_to_u32(oid >> 32)

bilbyFsObjTypeInode : U8
bilbyFsObjTypeInode = 0

bilbyFsObjTypeData : U8
bilbyFsObjTypeData = 1

bilbyFsObjTypeDentarr : U8
bilbyFsObjTypeDentarr = 2

bilbyFsObjTypeDel : U8
bilbyFsObjTypeDel = 3

bilbyFsObjTypeSuper : U8
bilbyFsObjTypeSuper = 4

bilbyFsObjTypePad : U8
bilbyFsObjTypePad = 5

bilbyFsObjTypeSum : U8
bilbyFsObjTypeSum = 6

bilbyFsOidMaskDentarr : U64
bilbyFsOidMaskDentarr = upcast bilbyFsObjTypeDentarr << bilbyFsXinfoShift

bilbyFsOidMaskData : U64
bilbyFsOidMaskData = upcast bilbyFsObjTypeData << bilbyFsXinfoShift

bilbyFsOidMaskInode : U64
bilbyFsOidMaskInode = upcast bilbyFsObjTypeInode << bilbyFsXinfoShift

bilbyFsOidMaskDel : U64
bilbyFsOidMaskDel = upcast bilbyFsObjTypeDel << bilbyFsXinfoShift

bilbyFsOidMaskPad : U64
bilbyFsOidMaskPad = upcast bilbyFsObjTypePad << bilbyFsXinfoShift

bilbyFsOidMaskSum : U64
bilbyFsOidMaskSum = upcast bilbyFsObjTypeSum << bilbyFsXinfoShift

bilbyFsOidMaskAll : U64
bilbyFsOidMaskAll = 7 << bilbyFsXinfoShift

-- TODO rename mk_* instead 
{-# cinline obj_id_dentarr_mk #-}
obj_id_dentarr_mk: (VfsIno, (WordArray U8)!) -> ObjId
obj_id_dentarr_mk(ino, name) =
  let oid:ObjId = (u32_to_u64 ino) << 32
  and h = u32_to_u64 (obj_id_hash_name name)
  in oid .|. bilbyFsOidMaskDentarr .|. h

{-# cinline obj_id_inode_mk #-}
obj_id_inode_mk: VfsIno -> ObjId
obj_id_inode_mk(ino) =
  (upcast ino << 32) .|. bilbyFsOidMaskInode

{-# cinline obj_id_data_mk #-}
obj_id_data_mk: (VfsIno, U32) -> ObjId
obj_id_data_mk(ino, blk) =
   obj_id_inode_mk ino .|. bilbyFsOidMaskData .|. upcast blk

{-# cinline obj_id_pad_mk #-}
obj_id_pad_mk: () -> ObjId
obj_id_pad_mk _ = bilbyFsOidMaskPad

{-# cinline obj_id_type #-}
obj_id_type: ObjId -> U64
obj_id_type oid = 
   ((oid .&. bilbyFsOidMaskAll) >> bilbyFsXinfoShift)

obj_id_hash_map: #{elem: U8, acc: U32, obsv: ()} -> LoopResult U32 U32
obj_id_hash_map #{elem, acc=a, obsv} = 
  let v = upcast elem
  and a = a + v << 4
  and a = a + v >> 4
  in Iterate (a * 11)

obj_id_hash_name: (WordArray U8)! -> U32
obj_id_hash_name nm =
  let a:U32 = 0
  and len = wordarray_length[U8] nm
  in wordarray_fold[U8, U32, (), U32] #{arr=nm, frm=0, to=len, f=obj_id_hash_map, acc=a, obsv=()}
  | Break a -> _cogent_assert False ; a .&. (u64_to_u32 bilbyFsXinfoMask)
  | Iterate a -> a .&. (u64_to_u32 bilbyFsXinfoMask)

{-# cinline obj_id_end_mk #-}
obj_id_end_mk: VfsIno -> ObjId
obj_id_end_mk ino =
   obj_id_inode_mk ino .|. upcast word32Max

{-# cinline obj_id_is_inode #-}
obj_id_is_inode: ObjId -> Bool
obj_id_is_inode oid =
   obj_id_type oid == upcast bilbyFsObjTypeInode

{-# cinline obj_id_is_dentarr #-}
obj_id_is_dentarr: ObjId -> Bool
obj_id_is_dentarr oid =
   obj_id_type oid == upcast bilbyFsObjTypeDentarr

{-# cinline obj_id_is_data #-}
obj_id_is_data: ObjId -> Bool
obj_id_is_data oid =
   obj_id_type oid == upcast bilbyFsObjTypeData

type Obj = {
       magic : U32,
       crc : U32,
       sqnum : U64,
       offs : U32, -- in-mem only field
       len : U32,
      -- , pad1 : U8
      -- , pad2 : U8
       trans : ObjTrans,
       otype : ObjType,
       ounion : ObjUnion
}

bilbyFsObjHeaderSize : U32
bilbyFsObjHeaderSize = 24

serialise_ObjHeader:(Buffer, BufOffs, Obj!) -> (Buffer, BufOffs)
serialise_ObjHeader(buf, offs, o) =
  let buf = serialise_le32(buf, offs, o.magic)
  and buf = serialise_le32(buf, offs+4, o.crc)
  and buf = serialise_le64(buf, offs+8, o.sqnum)
  and buf = serialise_le32(buf, offs+16, o.len)
  and buf = serialise_u8(buf, offs+20, bilbyFsPadByte)
  and buf = serialise_u8(buf, offs+21, bilbyFsPadByte)
  and buf = serialise_u8(buf, offs+22, o.trans)
  and buf = serialise_u8(buf, offs+23, o.otype)
  in (buf, offs + bilbyFsObjHeaderSize)

_print_ObjHeader:(Obj take (ounion))! -> ()
_print_ObjHeader o =
  _cogent_debug "ObjHeader = {magic=" ;
  _cogent_debug_u32_hex o.magic ;
  _cogent_debug ",crc=" ;
  _cogent_debug_u32_hex(o.crc) ;
  _cogent_debug ",sqnum=" ;
  _cogent_debug_u64_hex(o.sqnum) ;
  _cogent_debug ",len=" ;
  _cogent_debug_u32(o.len) ;
  _cogent_debug ",offs=" ;
  _cogent_debug_u32(o.offs) ;
  _cogent_debug ",pad=" ;
  _cogent_debug_u8(bilbyFsPadByte) ;
  _cogent_debug ",pad=" ;
  _cogent_debug_u8(bilbyFsPadByte) ;
  _cogent_debug ",trans=" ;
  _cogent_debug_u8(o.trans) ;
  _cogent_debug ",otype=" ;
  _cogent_debug_u8(o.otype) ;
  _cogent_debug "}\n"

_print_ObjSuper:ObjSuper! -> ()
_print_ObjSuper o =
  _cogent_debug "ObjSuper = {nb_eb=" ;
  _cogent_debug_u32 o.nb_eb ;
  _cogent_debug ",eb_size=" ;
  _cogent_debug_u32(o.eb_size) ;
  _cogent_debug ",io_size=" ;
  _cogent_debug_u32(o.io_size) ;
  _cogent_debug ",nb_reserved_gc=" ;
  _cogent_debug_u32(o.nb_reserved_gc) ;
  _cogent_debug ",nb_reserved_del=" ;
  _cogent_debug_u32(o.nb_reserved_del) ;
  _cogent_debug ",cur_eb=" ;
  _cogent_debug_u32(o.cur_eb) ;
  _cogent_debug ",cur_offs=" ;
  _cogent_debug_u32(o.cur_offs) ;
  _cogent_debug ",last_inum=" ;
  _cogent_debug_u32(o.last_inum) ;
  _cogent_debug ",next_sqnum=" ;
  _cogent_debug_u64(o.next_sqnum) ;
  _cogent_debug "}\n"

_print_ObjDentry:ObjDentry! -> ()
_print_ObjDentry o =
  _cogent_debug "ObjDentry = {ino=" ;
  _cogent_debug_u32 o.ino ;
  _cogent_debug ",dtype=" ;
  _cogent_debug_u8(o.dtype) ;
  _cogent_debug ",nlen=" ;
  _cogent_debug_u16(o.nlen) ;
  _cogent_debug ",name=(not displayed)" ;
  _cogent_debug "}\n"

{-# cinline serialise_Obj #-}
serialise_Obj:(Buffer, BufOffs, Obj!) -> (Buffer, BufOffs)
serialise_Obj(buf, offs, o) =
  let (buf, offs) = serialise_ObjHeader(buf, offs, o)
  in serialise_ObjUnion(buf, offs, o.ounion, o.len)

deserialise_ObjUnion: (ExState, Buffer!, U32, (ObjType, U32)) -> R (ExState, ObjUnion, U32) (ErrCode, ExState)
deserialise_ObjUnion(ex, buf, offs, (otype, olen)) =
  if otype == bilbyFsObjTypeInode then
    deserialise_ObjInode(ex, buf, offs)
    | Error (e,ex) -> Error (e, ex)
    | Success (ex, o, offs) ->
      Success (ex, TObjInode o, offs)
  else if otype == bilbyFsObjTypeData then
    deserialise_ObjData(ex, buf, offs, olen)
    | Error (e,ex) -> Error (e, ex)
    | Success (ex, o, offs) ->
      Success (ex, TObjData o, offs)
  else if otype == bilbyFsObjTypeDentarr then
    deserialise_ObjDentarr(ex, buf, offs, olen)
    | Error (e,ex) -> Error (e, ex)
    | Success (ex, o, offs) ->
      Success (ex, TObjDentarr o, offs)
  else if otype == bilbyFsObjTypeDel then
    deserialise_ObjDel(ex, buf, offs)
    | Error (e,ex) -> Error (e, ex)
    | Success (ex, o, offs) ->
      Success (ex, TObjDel o, offs)
  else if otype == bilbyFsObjTypeSuper then
    deserialise_ObjSuper(ex, buf, offs)
    | Error (e,ex) -> Error (e, ex)
    | Success (ex, o, offs) ->
      Success (ex, TObjSuper o, offs)
  -- if otype == bilbyFsObjTypeSummary, we return an padding object,
  -- we should NOT call this deserialisation function for summaries.
  -- Main reason for this exception is avoid allocation of gigantic
  -- summaries.
  else -- if otype == bilbyFsObjTypePad then
    deserialise_ObjPad(ex, buf, offs, olen)
    | Error (e,ex) -> Error (e, ex)
    | Success (ex, o, offs) ->
      Success (ex, TObjPad o, offs)

is_len_and_type_ok: (U8, U32) -> Bool
is_len_and_type_ok(otype, olen) =
  if otype == bilbyFsObjTypeInode then
    olen == bilbyFsObjHeaderSize + bilbyFsObjInode
  else if otype == bilbyFsObjTypeData then
    olen >= bilbyFsObjHeaderSize + bilbyFsObjDataHeaderSize
  else if otype == bilbyFsObjTypeDentarr then
    -- dentarr on-flash must have 1 entry minimum
    olen >= bilbyFsObjHeaderSize + bilbyFsObjDentarrHeaderSize + bilbyFsObjDentryHeaderSize
  else if otype == bilbyFsObjTypeDel then
    olen == bilbyFsObjHeaderSize + bilbyFsObjDelSize
  else if otype == bilbyFsObjTypeSuper then
    olen == bilbyFsObjHeaderSize + bilbyFsObjSuperSize
  else if otype == bilbyFsObjTypeSum then
    olen >= bilbyFsObjHeaderSize + bilbyFsObjSummaryHeaderSize
  else if otype == bilbyFsObjTypePad then
    olen >= bilbyFsObjHeaderSize
  else
    False

deserialise_ObjHeader: (Buffer!, BufOffs, Obj take (..)) -> RR (Obj take (ounion)) BufOffs ErrCode
deserialise_ObjHeader (buf, offs, obj) =
  let magic = deserialise_le32(buf, offs)
  and crc = deserialise_le32(buf, offs+4)
  and sqnum = deserialise_le64(buf, offs+8)
  and len = deserialise_le32(buf, offs+16)
  -- skip 2 pad bytes
  and trans = deserialise_u8(buf, offs+22)
  and otype = deserialise_u8(buf, offs+23)
  and obj = obj {magic,crc,sqnum,offs,len,trans,otype}
  and end_offs = len + offs
  in if end_offs < offs || end_offs > buf.bound ||
        magic /= bilbyFsMagic ||
        (trans /= bilbyFsTransIn && trans /= bilbyFsTransCommit) ||
        not (is_len_and_type_ok(otype, len))
  then
    _cogent_debug "Invalid otype in object at " ;
    _cogent_debug_u32 offs;
    _cogent_debug ", len = " ;
    _cogent_debug_u32 len;
    _cogent_debug ", endoff = " ;
    _cogent_debug_u32 end_offs;
    _cogent_debug ", buf.bound = " ;
    _cogent_debug_u32 buf.bound;
    _cogent_debug ", magic = " ;
    _cogent_debug_u32_hex magic ;
    _cogent_debug ", otype = " ;
    _cogent_debug_u8 otype ;
    _cogent_debug ", trans = " ;
    _cogent_debug_u8 trans ;
    _cogent_debug "\n" ;
    (obj, Error eInval)
  else
    (obj, Success (offs + bilbyFsObjHeaderSize))

deserialise_Obj: (ExState, Buffer!, BufOffs) -> R (ExState, Obj, BufOffs) (ErrCode, ExState)
deserialise_Obj(ex, buf, offs) =
  newObj ex
  | Error ex ->
    Error (eNoMem, ex)
  | Success (ex, obj) ->
    let (obj, r) = deserialise_ObjHeader (buf, offs, obj)
    in r
    | Error e ->
      let ex = freeObj (ex, obj)
      in Error (e, ex)
    | Success offs ->
      deserialise_ObjUnion(ex, buf, offs, (obj.otype,obj.len)) !obj
      | Error (e, ex) ->
        _cogent_debug "Could not deserialise Obj_union at " ;
        _cogent_debug_u32 (offs+bilbyFsObjHeaderSize);
        _cogent_debug "\n" ;
        let ex = freeObj (ex, obj)
        in Error (e, ex)
      | Success (ex, ounion, offs') ->
        _cogent_debug "deserialise_Obj: otype =" ; 
        let obj = obj {ounion}
        and _ = _cogent_debug_u8 obj.otype !obj
        and _ = _cogent_debug "\n"
        in Success (ex, obj, offs')

newObj: ExState -> R (ExState, Obj take(..)) ExState
freeObj: (ExState, Obj take(..)) -> ExState

{-# cinline deep_freeObj #-}
deep_freeObj: (ExState, Obj) -> ExState
deep_freeObj(ex, obj) =
  let obj {magic, crc, sqnum, offs, len, trans, otype, ounion} = obj
  and ex = deep_freeObjUnion(ex, ounion)
  in freeObj(ex, obj)

type ObjUnion = <TObjDentarr ObjDentarr
  | TObjInode ObjInode
  | TObjData ObjData
  | TObjDel ObjDel
  | TObjSuper ObjSuper
  | TObjSummary ObjSummary
  | TObjPad ()>

{-# cinline serialise_ObjPad #-}
serialise_ObjPad: (Buffer,  BufOffs, U32) -> (Buffer, BufOffs)
serialise_ObjPad(buf, offs, olen) =
 let padlen = olen - bilbyFsObjHeaderSize
 and buf = buf_memset(buf, offs, padlen, bilbyFsPadByte)
 in (buf, offs + padlen)

{-# cinline deserialise_ObjPad #-}
deserialise_ObjPad: (ExState, Buffer!, BufOffs, U32) -> R (ExState, (), BufOffs) (ErrCode, ExState)
deserialise_ObjPad(ex, buf, offs, olen) =
  let len = olen - bilbyFsObjHeaderSize
  in if len > olen then
    Error (eInval, ex)
  else
    Success (ex, (), offs + len)

serialise_ObjUnion:(Buffer, BufOffs, ObjUnion!, U32) -> (Buffer, BufOffs)
serialise_ObjUnion(buf, offs, ou, olen) =
  ou
  | TObjDentarr o -> serialise_ObjDentarr(buf, offs, o)
  | TObjInode o -> serialise_ObjInode(buf, offs, o)
  | TObjData o -> serialise_ObjData(buf, offs, o, olen)
  | TObjDel o -> serialise_ObjDel(buf, offs, o)
  | TObjSuper o -> serialise_ObjSuper(buf, offs, o)
  | TObjSummary o -> serialise_ObjSummary(buf, offs, o)
  | TObjPad _ -> serialise_ObjPad(buf, offs, olen)

{-# cinline deep_freeObjDentry #-}
deep_freeObjDentry: (ExState, ObjDentry) -> ExState
deep_freeObjDentry(ex, o {name}) =
  let ex = freeObjDentry(ex, o)
  in wordarray_free[U8](ex, name)

{-# cinline deep_freeObjDentarr #-}
deep_freeObjDentarr: (ExState, ObjDentarr) -> ExState
deep_freeObjDentarr(ex, o {id,nb_dentry,entries}) =
  let ex = freeObjDentarr(ex, o)
  in array_free[ObjDentry] #{arr=entries, f=deep_freeObjDentry, ex}

{-# cinline deep_freeObjUnion #-}
deep_freeObjUnion: (ExState, ObjUnion) -> ExState
deep_freeObjUnion(ex, ounion) =
 ounion
 | TObjDentarr o -> deep_freeObjDentarr(ex, o)
 | TObjInode o {id,size,atime_sec,ctime_sec,
               mtime_sec,nlink,uid,gid,mode, flags} ->
   freeObjInode(ex, o)
 | TObjData o {id,odata} ->
   let ex = freeObjData(ex, o)
   in wordarray_free[U8](ex, odata)
 | TObjDel o {id} -> ex
 | TObjSuper o {nb_eb,eb_size,io_size,cur_eb,cur_offs,next_sqnum,
               last_inum, nb_reserved_gc, nb_reserved_del} ->
   freeObjSuper(ex, o)
 | TObjSummary o {nb_sum_entry,entries,sum_offs} ->
   let ex = wordarray_free[ObjSumEntry](ex, entries)
   in freeObjSummary(ex, o)
 | TObjPad _ -> ex

type ObjType = U8
type ObjTrans = U8
type ObjId = U64
type ObjIdDentarr = U64
type ObjIdData = U64
type ObjIdInode = U64

bilbyFsObjDelSize: U32
bilbyFsObjDelSize = 8

type ObjDel = #{ id : ObjId } take ()
{-# cinline serialise_ObjDel #-}
serialise_ObjDel:(Buffer, BufOffs, ObjDel!) -> (Buffer, BufOffs)
serialise_ObjDel(buf, offs, od) =
  let buf = serialise_le64(buf, offs, od.id)
  in (buf, offs + bilbyFsObjDelSize)

{-# cinline serialise_size_ObjDel #-}
serialise_size_ObjDel: ObjDel! -> U32
serialise_size_ObjDel _ = bilbyFsObjDelSize

deserialise_ObjDel: (ExState, Buffer!, BufOffs) -> R (ExState, ObjDel, BufOffs) (ErrCode, ExState)
deserialise_ObjDel(ex, buf, offs) =
  let id = deserialise_le64(buf, offs)
  -- Ensure type of oid is ObjData
  and idtype = id .&. binNot bilbyFsOidMaskAll
  in if idtype /= bilbyFsOidMaskData && 
        idtype /= bilbyFsOidMaskInode &&
        idtype /= bilbyFsOidMaskDentarr then
      Error (eInval, ex)
    else
      Success (ex, #{id}, offs + 8)

bilbyFsItypeReg: U8
bilbyFsItypeReg = 0

bilbyFsItypeDir: U8
bilbyFsItypeDir = 1

bilbyFsItypeLnk: U8
bilbyFsItypeLnk = 2

bilbyFsItypeBlk: U8
bilbyFsItypeBlk = 3

bilbyFsItypeChr: U8
bilbyFsItypeChr = 4

bilbyFsItypeFifo: U8
bilbyFsItypeFifo = 5

bilbyFsItypeSock: U8
bilbyFsItypeSock = 6

type ObjDentry = {
  ino : U32,
  dtype : U8,
  -- pad : U8,
  nlen : U16,
  name : WordArray U8
}

bilbyFsObjDentryHeaderSize:U32
bilbyFsObjDentryHeaderSize = 8
{-
  definition "PObjDentry data offs ==
      let nlen = Ple16 data (offs+6) (* includes \0 *)
      in ObjDentry.make
         (Ple32 data offs) (* ino *)
         (Pu8 data (offs+4)) (* dtype *)
         nlen
         (Pwordarray_u8 data (offs+8) nlen) (* len *)
         (* end 8 + nlen bytes *)"

  precond:
    dentry.nlen = u32_to_u16 (wordarray_length[U8] dentry.name)
    offs + 8 + wordarray_length[U8] dentry.name <= buf.bound
  postcond:
   r = serialise_ObjDentry(buf, offs, dentry) /\
   PObjDentry (fst r) offs = dentry /\ snd r = offs + 8 + nlen
-}
serialise_ObjDentry:(Buffer, BufOffs, ObjDentry!) -> (Buffer, BufOffs)
serialise_ObjDentry(buf, offs, dentry) =
  _print_ObjDentry dentry ;
  let buf = serialise_le32(buf, offs, dentry.ino)
  and buf = serialise_u8(buf, offs+4, dentry.dtype)
  and buf = serialise_u8(buf, offs+5, bilbyFsPadByte)
  and buf = serialise_le16(buf, offs+6, dentry.nlen)
  and buf = serialise_wordarray_U8(buf, offs+8, dentry.name)
  in (buf, offs + bilbyFsObjDentryHeaderSize + wordarray_length[U8] dentry.name)

{-# cinline serialise_size_ObjDentry #-}
serialise_size_ObjDentry: ObjDentry! -> U32
serialise_size_ObjDentry dent = bilbyFsObjDentryHeaderSize + wordarray_length[U8] dent.name

{-
  precond:
    dentry.nlen = u32_to_u16 (wordarray_length[U8] dentry.name)
    dentry.nlen < 256
    offs + 8 + u16_to_u32 (Ple16 data (offs+6)) <= buf.bound
  postcond:
!!h e.
  let nlen32 = u16_to_u32 (Ple16 data (offs+6))
  in if offs + 8 + nlen32 <= buf.bound then
    Error (fst(select(h,{eNoMem,eInval})), h)
  else
    Success (h, PObjDentry buf.data offs, offs + 8 + nlen32)
-}
deserialise_ObjDentry: (ExState, Buffer!, BufOffs, U32) -> R (ExState, ObjDentry, BufOffs) (ErrCode, ExState)
deserialise_ObjDentry(ex, buf, offs, end_offs) =
  let ino = deserialise_le32(buf, offs)
  and dtype = deserialise_u8(buf, offs+4)
  and nlen = deserialise_le16(buf, offs+6)

 -- There is a constrain on nlen to check that it is within the buffer bound.
 -- This has to be checked as we deserialise because nlen
 -- is read from the buffer (as opposed to bound checks
 -- encoded in the preconditions
  and nlen32 = u16_to_u32 nlen 
  and _ = _cogent_debug "deserialise_ObjDentry: nlen=" 
  and _ = _cogent_debug_u16 nlen 
  and _ = _cogent_debug " -- nlen32 "
  and _ = _cogent_debug_u32 nlen32 
  in if offs + bilbyFsObjDentryHeaderSize + nlen32 > buf.bound ||
        nlen32 > bilbyFsMaxNameLen + 1 ||
        nlen32 == 0 ||
        offs + bilbyFsObjDentryHeaderSize + nlen32 > end_offs
         then
    _cogent_debug "offs+8+nlen32 (";
    _cogent_debug_u32 (offs + bilbyFsObjDentryHeaderSize + nlen32) ;
    _cogent_debug  ") > buf_bound (" ;
    _cogent_debug_u32 (buf_bound buf);
    _cogent_debug ") or nlen32 (" ;
    _cogent_debug_u32 nlen32 ;
    _cogent_debug " > " ;
    _cogent_debug_u32 (bilbyFsMaxNameLen + 1) ;
    _cogent_debug ")\n" ;
    Error (eInval, ex)
  else
    -- deserialise_wordarray_U8 guarantees that: length name = nlen
    deserialise_wordarray_U8(ex, buf, offs + bilbyFsObjDentryHeaderSize, nlen32)
    | Error (e, ex) ->
      _cogent_debug "Error deserialise_wordarray_U8 \n" ;
      Error (e, ex)
    | Success (ex, name) ->
      newObjDentry ex
      | Error ex ->
        let ex = wordarray_free[U8](ex, name)
        in Error (eNoMem, ex)
      | Success (ex, dentry) ->
        let dentry = dentry {ino, dtype, nlen, name}
        in Success (ex, dentry, offs + bilbyFsObjDentryHeaderSize + nlen32)

newObjDentry: ExState -> R (ExState, ObjDentry take(..)) ExState
freeObjDentry: (ExState, ObjDentry take (..)) -> ExState

type ObjDentarr = {
  id : ObjId,
  nb_dentry : U32,
  entries : Array ObjDentry
}
newObjDentarr: ExState -> R (ExState, ObjDentarr take(..)) ExState
freeObjDentarr: (ExState, ObjDentarr take (..)) -> ExState

{-# cinline serialise_Arr_ObjDentry_f #-}
serialise_Arr_ObjDentry_f: #{elem:ObjDentry!, acc:(Buffer, BufOffs), obsv:()} -> (Buffer, BufOffs)
serialise_Arr_ObjDentry_f #{elem=dentry,acc=(buf,offs), obsv=()} =
  serialise_ObjDentry(buf, offs, dentry)

{-# cinline serialise_Array_ObjDentry #-}
serialise_Array_ObjDentry: (Buffer, BufOffs, (Array ObjDentry)!) -> (Buffer, BufOffs)
serialise_Array_ObjDentry(buf, offs, arr) =
  array_fold_no_break[ObjDentry, (Buffer, BufOffs), ()]
    #{arr, f=serialise_Arr_ObjDentry_f, acc=(buf, offs), obsv=()}

bilbyFsObjDentarrHeaderSize: U32
bilbyFsObjDentarrHeaderSize = 12

serialise_ObjDentarr:(Buffer, BufOffs, ObjDentarr!) -> (Buffer, BufOffs)
serialise_ObjDentarr(buf, offs, dentarr) =
  _cogent_debug "serialise_ObjDentarr {id=" ;
  _cogent_debug_u64_hex dentarr.id ;
  _cogent_debug ",nb_dentry=" ;
  _cogent_debug_u32 dentarr.nb_dentry ;
  _cogent_debug "\n" ;
  let buf = serialise_le64(buf, offs, dentarr.id)
  and buf = serialise_le32(buf, offs+8, dentarr.nb_dentry)
  in serialise_Array_ObjDentry(buf, offs+bilbyFsObjDentarrHeaderSize, dentarr.entries)

{-# cinline serialise_size_Arr_ObjDentry_f #-}
serialise_size_Arr_ObjDentry_f: #{elem:ObjDentry!, acc:U32, obsv:()} -> U32
serialise_size_Arr_ObjDentry_f #{elem=dentry,acc=sz, obsv=()} =
  sz + serialise_size_ObjDentry(dentry)

{-# cinline serialise_size_Array_ObjDentry #-}
serialise_size_Array_ObjDentry: (Array ObjDentry)! -> U32
serialise_size_Array_ObjDentry arr =
  array_fold_no_break[ObjDentry, U32, ()] #{arr, f=serialise_size_Arr_ObjDentry_f, acc=0, obsv=()}

{-# cinline serialise_size_ObjDentarr #-}
serialise_size_ObjDentarr: ObjDentarr! -> U32
serialise_size_ObjDentarr dentarr = bilbyFsObjDentarrHeaderSize + serialise_size_Array_ObjDentry dentarr.entries

{-# cinline deep_freeOptionObjDentry #-}
deep_freeOptionObjDentry: (ExState, Option ObjDentry) -> ExState
deep_freeOptionObjDentry (ex, opt_dent) =
  opt_dent | None -> ex
           | Some o -> deep_freeObjDentry(ex, o)

-- #{oelem:Option ObjDentry, acc: (ExState, U32), obsv: Buffer!} -> LoopResult (Option ObjDentry, (ExState, U32)) (Option ObjDentry, (ErrCode, ExState))
loop_deserialise_ObjDentry: ArrayMapF ObjDentry (ExState, U32) (Buffer!,U32) (ErrCode, ExState)
loop_deserialise_ObjDentry #{oelem, acc=(ex,offs), obsv=(buf,end_offs)} =
  let ex = deep_freeOptionObjDentry(ex, oelem) 
  in deserialise_ObjDentry(ex, buf, offs, end_offs)
  | Error (err, ex) ->
    _cogent_debug "could not deserialise deserialise_ObjDentry at " ;
    _cogent_debug_u32 offs ;
    _cogent_debug "\n" ;
    Break (None, (eInval, ex))
  | Success (ex, dent, offs) ->
    Iterate (Some dent, (ex, offs))

deserialise_Array_ObjDentry: (ExState, Buffer!, BufOffs, U32, U32) -> R (ExState, Array ObjDentry, BufOffs) (ErrCode, ExState)
deserialise_Array_ObjDentry(ex, buf, offs, nb_dentry, end_offs) =
  -- we always allocate an extra slot for potentially adding an entry
  array_create[ObjDentry] (ex, nb_dentry + 1)
  | Error ex ->
    _cogent_debug "Error of array_create in deserialise_Array_ObjDentry (length=" ;
    _cogent_debug_u32 nb_dentry ;
    _cogent_debug ")\n" ;
    Error (eNoMem, ex)
  | Success (ex, arr) ->
    array_map[ObjDentry, (ExState, U32), (Buffer!,U32), (ErrCode, ExState)]
      #{arr, frm=0, to=nb_dentry, f=loop_deserialise_ObjDentry, acc=(ex, offs), obsv=(buf,end_offs)}
    | Break (arr, (err, ex)) ->
      let ex = array_free[ObjDentry] #{arr, f=deep_freeObjDentry, ex}
      in Error (err, ex)
    | Iterate (arr, (ex, offs)) ->
      Success (ex, arr, offs)

deserialise_ObjDentarr: (ExState, Buffer!, BufOffs, U32) -> R (ExState, ObjDentarr, BufOffs) (ErrCode, ExState) 
deserialise_ObjDentarr(ex, buf, offs, olen) =
  let id = deserialise_le64(buf, offs)
  and nb_dentry = deserialise_le32(buf, offs+8)
  in deserialise_Array_ObjDentry(ex, buf, offs+bilbyFsObjDentarrHeaderSize, nb_dentry, offs+olen-bilbyFsObjHeaderSize)
  | Error (e,ex) ->
    _cogent_debug "deserialise_Array_Objdentry, offs+16" ;
    _cogent_debug "\n" ;
    Error (e, ex)
  | Success (ex, entries, offs) ->
    newObjDentarr ex
    | Error ex ->
      let ex = array_free[ObjDentry] #{arr=entries, f=deep_freeObjDentry, ex}
      in Error (eNoMem, ex)
    | Success (ex, dentarr) ->
      let dentarr = dentarr {id,nb_dentry,entries}
      in Success (ex, dentarr, offs)

bilbyFsSumEntryDelFlagMask: U32
bilbyFsSumEntryDelFlagMask = 0x80000000

type ObjSumEntry = #{
  id : U64,
  sqnum : U64,
  len : U32,
  del_flags_and_offs : U32,
  count : U16 -- nb of object covered by the deletion object
}

obj_sum_entry_offs: ObjSumEntry -> U32
obj_sum_entry_offs entry =
  entry.del_flags_and_offs .&. (complement bilbyFsSumEntryDelFlagMask)

obj_sum_entry_is_del: ObjSumEntry -> Bool
obj_sum_entry_is_del entry = 
  (entry.del_flags_and_offs .&. bilbyFsSumEntryDelFlagMask) /= 0


bilbyFsObjSumEntrySize : U32
bilbyFsObjSumEntrySize = 26

type ObjSummary = {
  nb_sum_entry : U32, -- nb_sum_entry must be <= wordarray_length sum.entries
                   -- the wordarray is ususally larger than what's get serialised.
                   -- Using an array for this would be too inefficient.
  entries : WordArray ObjSumEntry, -- only @nb_sum_entry element get serialised on medium
  -- At the very end of the summary is the offset of the summary itself.
  sum_offs : U32
}
bilbyFsObjSummaryHeaderSize: U32
bilbyFsObjSummaryHeaderSize = 4

bilbyFsObjSummaryOffsSize: U32
bilbyFsObjSummaryOffsSize = 4

newObjSummary: ExState -> R (ExState, ObjSummary take(..)) ExState
freeObjSummary: (ExState, ObjSummary take (..)) -> ExState

summary_init: (ExState, U32) -> R (ExState, ObjSummary, Obj) ExState
summary_init(ex, max_nb_sum_entry) =
  newObjSummary ex
  | Error ex ->
    Error ex
  | Success (ex, sum) ->
    wordarray_create[ObjSumEntry] (ex, max_nb_sum_entry)
    | Error ex ->
      let ex = freeObjSummary (ex, sum)
      in Error ex
    | Success (ex, entries) ->
      newObj ex
      | Error ex ->
        let ex = freeObjSummary (ex, sum)
        and ex = wordarray_free[ObjSumEntry] (ex, entries)
        in Error ex
      | Success (ex, sum_obj) ->
        let sum_obj = obj_init_default (sum_obj, bilbyFsObjTypeSum) 
        and sum_obj = sum_obj {trans=bilbyFsTransCommit, ounion = TObjPad ()}
        and sum_offs:U32 = 0
        in Success (ex, sum {nb_sum_entry=0, entries, sum_offs}, sum_obj)

summary_clean: (ExState, ObjSummary) -> ExState
summary_clean(ex, sum {entries}) =
  let ex = wordarray_free[ObjSumEntry] (ex, entries)
  in freeObjSummary(ex, sum)

serialise_ObjSummary:(Buffer, BufOffs, ObjSummary!) -> (Buffer, BufOffs)
serialise_ObjSummary(buf, offs, sum) =
  _cogent_debug "serialise_ObjSummary {nb_sym_entry=" ;
  _cogent_debug_u32 sum.nb_sum_entry ;
  _cogent_debug ",offs = " ;
  _cogent_debug_u32 offs ;
  _cogent_debug ",sum_offs = " ;
  _cogent_debug_u32 sum.sum_offs ;
  _cogent_debug "}\n" ;
  -- _cogent_assert(offs == sum.sum_offs) ;
  let buf = serialise_le32(buf, offs, sum.nb_sum_entry)
  and (buf, offs) = serialise_wordarray_ObjSumEntry(buf, offs+4, sum.entries, sum.nb_sum_entry)
  and _ = _cogent_debug "serialise_ObjSummary: offs = "
  and _ = _cogent_debug_u32 offs
  and _ = _cogent_debug ",sum_offs = "
  and _ = _cogent_debug_u32 sum.sum_offs
  and _ = _cogent_debug "\n"
  and buf = serialise_le32(buf, offs, sum.sum_offs)
  in (buf, offs + 4)

serialise_ObjSummary_crc:(Buffer, BufOffs, Obj, ObjSummary!) -> (Obj, Buffer, BufOffs)
serialise_ObjSummary_crc(buf, offs, sum_obj, sum) =
  let (buf, offs') = serialise_ObjHeader(buf, offs, sum_obj) !sum_obj
  and (buf, offs') = serialise_ObjSummary(buf, offs', sum)
  -- compute CRC32 from after crc field to end of object
  and crc = crc32_buf #{buf, frm=offs + 8, to=offs'} !buf
  and sum_obj = sum_obj {crc}
  and buf = serialise_le32(buf, offs + 4, crc)
  in (sum_obj, buf, offs')

{-# inline serialise_ObjSumEntry_f #-}
serialise_ObjSumEntry_f: #{elem:ObjSumEntry!, acc:(Buffer, BufOffs),  obsv:()} -> (Buffer, BufOffs)
serialise_ObjSumEntry_f #{elem=sumentry, acc=(buf,offs) , obsv} = 
  serialise_ObjSumEntry(buf, offs, sumentry)

serialise_ObjSumEntry:(Buffer, BufOffs, ObjSumEntry!) -> (Buffer, BufOffs)
serialise_ObjSumEntry(buf, offs, sumentry) =
  _cogent_debug "serialise_ObjSumEntry {id=" ;
  _cogent_debug_u64_hex sumentry.id ;
  _cogent_debug ",sqnum=" ;
  _cogent_debug_u64 sumentry.sqnum ;
  _cogent_debug ",del=" ;
  _cogent_debug_u32 (sumentry.del_flags_and_offs .&. bilbyFsSumEntryDelFlagMask) ;
  _cogent_debug ",offs=" ;
  _cogent_debug_u32 (obj_sum_entry_offs sumentry) ;
  _cogent_debug ",count=" ;
  _cogent_debug_u32 (u16_to_u32 sumentry.count) ;
  _cogent_debug "}\n" ;
  let buf = serialise_le64(buf, offs, sumentry.id)
  and buf = serialise_le64(buf, offs+8, sumentry.sqnum)
  and buf = serialise_le32(buf, offs+16, sumentry.len)
  and buf = serialise_le32(buf, offs+20, sumentry.del_flags_and_offs)
  and buf = serialise_le16(buf, offs+24, sumentry.count)
  in (buf, offs + bilbyFsObjSumEntrySize)

serialise_wordarray_ObjSumEntry: (Buffer, BufOffs, (WordArray ObjSumEntry)!, U32) -> (Buffer, BufOffs)
serialise_wordarray_ObjSumEntry(buf, offs, entries, nb_sum_entry) =
  let arrsz = bilbyFsObjSumEntrySize * nb_sum_entry 
  and end = if offs + arrsz > buf.bound then buf.bound else offs + arrsz !buf
  -- return partially serialised array if the bound is too small.
  and _ = _cogent_debug "serialise_wordarray_ObjSumEntry "
  and _ = _cogent_debug_u32 offs
  and _ = _cogent_debug " to "
  and _ = _cogent_debug_u32 end
  and _ = _cogent_debug "\n"
  in wordarray_fold_no_break[ObjSumEntry, (Buffer, BufOffs), ()]
       #{arr=entries, frm=0, to=nb_sum_entry, f=serialise_ObjSumEntry_f, acc=(buf, offs), obsv=()}

{-# cinline serialise_size_ObjSummary #-}
serialise_size_ObjSummary: U32 -> U32
serialise_size_ObjSummary nb_sum_entry =
  bilbyFsObjSummaryHeaderSize + nb_sum_entry * bilbyFsObjSumEntrySize + bilbyFsObjSummaryOffsSize

-- Size of the total object (including ObjHeader)
serialise_size_summary_Obj_with_extra: (ObjSummary!, U32) -> U32
serialise_size_summary_Obj_with_extra (summary, nb_extra) =
  bilbyFsObjHeaderSize + serialise_size_ObjSummary (summary.nb_sum_entry + nb_extra)

{-# inline deserialise_ObjSumEntry #-}
deserialise_ObjSumEntry: (Buffer!, BufOffs) -> (ObjSumEntry, BufOffs)
deserialise_ObjSumEntry(buf, offs) =
  let id = deserialise_le64(buf, offs)
  -- check if valid object id
  and sqnum = deserialise_le64(buf, offs+8)
  and len = deserialise_le32(buf, offs+16)
  and del_flags_and_offs = deserialise_le32(buf, offs+20)
  and count = deserialise_le16(buf, offs+24)
  and entry = #{id,sqnum,len,del_flags_and_offs,count}
  in (entry, offs+26)

{-# cinline deserialise_ObjSumEntry_map #-}
deserialise_ObjSumEntry_map: #{elem:ObjSumEntry,acc:BufOffs, obsv:Buffer!} -> (ObjSumEntry, BufOffs)
deserialise_ObjSumEntry_map #{elem=entry, acc=offs, obsv=buf} =
  let (entry, offs) = deserialise_ObjSumEntry(buf, offs)
  in (entry, offs)

{-# cinline deserialise_ObjSumEntry_map #-}
deserialise_wordarray_ObjSumEntry: (WordArray ObjSumEntry, Buffer!, BufOffs, U32) -> RR (WordArray ObjSumEntry) BufOffs ErrCode
deserialise_wordarray_ObjSumEntry (entries, buf, offs, nb_sum_entry) =
  let (entries,offs) = wordarray_map_no_break[ObjSumEntry, BufOffs, Buffer!]
                         #{arr=entries, frm=u8_to_u32 0, to=nb_sum_entry, f=deserialise_ObjSumEntry_map, acc=offs, obsv=buf}
  in (entries, Success offs)
  
deserialise_ObjSummary_crc: (ExState, Buffer!, BufOffs, Obj, ObjSummary) -> RR (ExState, Obj, ObjSummary) BufOffs ErrCode
deserialise_ObjSummary_crc (ex, buf, offs, obj, summary) =
  let obj {offs=_, magic, crc, sqnum, len, trans, otype, ounion} = obj
  and ex = deep_freeObjUnion(ex, ounion)
  and (obj, r) = deserialise_ObjHeader(buf, offs, obj)
  in r
  | Error e ->
    ((ex, obj {ounion =TObjPad ()}, summary), Error e)
  | Success offs' ->
    let (summary, r) = deserialise_ObjSummary(buf, offs', summary)
    in r
    | Error e ->
      ((ex, obj {ounion =TObjPad ()}, summary), Error e)
    | Success offs' ->
      let crcsum = crc32_buf #{buf, frm = offs + 8, to = offs'} !buf
      and crc = obj.crc !obj
      and obj {offs=_} = obj
      and obj = obj {offs}
      and _ = _cogent_debug "deserialise_ObjSummary_crc: crc check end_offs=" 
      and _ = _cogent_debug_u32 offs'
      and _ = _cogent_debug "\n" 
      and _ = _print_ObjHeader obj !obj
      and obj = obj {ounion = TObjPad ()} 
      in if crc == crcsum then
        ((ex, obj, summary), Success offs')
      else
        _cogent_debug "Invalid CRC Obj at offs=" ;
        _cogent_debug_u32 offs ;
        _cogent_debug "\n" ;
        ((ex, obj, summary), Error eInval)

deserialise_ObjSummary: (Buffer!, BufOffs, ObjSummary) -> RR ObjSummary BufOffs ErrCode
deserialise_ObjSummary(buf, offs, sum {entries}) =
  let nb_sum_entry = deserialise_le32(buf, offs)
  and (entries, r) = deserialise_wordarray_ObjSumEntry(entries, buf, offs + 4, nb_sum_entry)
  in r
  | Error e -> (sum {nb_sum_entry, entries}, Error e)
  | Success offs' ->
    let sum_offs = deserialise_le32(buf, offs')
    -- FIXME check that sum_offs == offs
    in (sum {nb_sum_entry, entries, sum_offs}, Success (offs'+4))

type ObjData = #{
  id : ObjId,
  odata : WordArray U8
}

serialise_wordarray_U8: (Buffer, BufOffs, (WordArray U8)!) -> Buffer
serialise_wordarray_U8(buf {data}, offs, wa) =
  let len = wordarray_length[U8] wa
  and end = if offs + len > buf.bound then buf.bound else offs + len !buf

  -- return partially serialised array if the bound is too small.
  and _ = _cogent_debug "serialise_wordarray_U8 "
  and _ = _cogent_debug_u32 offs
  and _ = _cogent_debug " to "
  and _ = _cogent_debug_u32 end
  and _ = _cogent_debug "\n"

  and data = wordarray_copy[U8] (data, wa, offs, 0, end)
  in buf {data}

serialise_ObjData:(Buffer, BufOffs, ObjData!, U32) -> (Buffer, BufOffs)
serialise_ObjData(buf, offs, od, olen) =
  let arrlen = olen - bilbyFsObjHeaderSize - 8
  and buf = serialise_le64(buf, offs, od.id)
-- Shrinks the buffer bound to only write the required length
-- so that we can have an ObjData that has an array larger than
-- needed and reuse that array.
  and bound = buf.bound !buf
  and buf = buf {bound = offs + 8 + arrlen}
  and buf = serialise_wordarray_U8(buf, offs+8, od.odata)
  and offs = buf.bound !buf
  and buf = buf {bound}
  in (buf, offs)

bilbyFsObjDataHeaderSize : U32
bilbyFsObjDataHeaderSize = 8

-- NOTE This value is wrong if odata array is larger than it needs to be
serialise_size_ObjData: ObjData! -> U32
serialise_size_ObjData od = bilbyFsObjDataHeaderSize + wordarray_length[U8] od.odata

deserialise_waU8_map: #{elem:U8,acc:BufOffs, obsv:(WordArray U8)!} -> (U8, BufOffs)
deserialise_waU8_map #{elem=_, acc=offs, obsv=data} =
 (wordarray_get[U8](data, offs), offs + 1)
-- We can't make this function polymorphic because we
-- don't have a polymorphic function to deserialise
-- array elements
deserialise_wordarray_U8: (ExState, Buffer!, BufOffs, U32) -> R (ExState, WordArray U8) (ErrCode, ExState)
deserialise_wordarray_U8 (ex, buf, offs, len) =
  wordarray_create[U8] (ex, len)
  | Error ex -> Error (eNoMem, ex) 
  | Success (ex, wa) ->
    let wa = wordarray_copy[U8] (wa, buf.data, 0, offs, len) !buf
    in Success (ex, wa)
  
{-
precondition:
    offs + 8 + len <= buf.bound
postcondition:
  !!h. if is_odata_id (le64 buf.data offs) then
    Error (eInval, h)
  else
    Success (h, PObjData buf.data offs, offs + 8 + len)
-}
deserialise_ObjData: (ExState, Buffer!, BufOffs, U32) -> R (ExState, ObjData, BufOffs) (ErrCode, ExState)
deserialise_ObjData(ex, buf, offs, olen) =
  let len = olen - bilbyFsObjHeaderSize - 8
  in if len > olen then
    Error (eInval, ex)
  else
    let id = deserialise_le64(buf, offs)
    -- Ensure type of oid is ObjData
    in if ((id .&. binNot bilbyFsOidMaskAll) .|. bilbyFsOidMaskData) /= id then
        Error (eInval, ex)
      else
        deserialise_wordarray_U8(ex, buf, offs + 8, len)
        | Error (e, ex) -> Error (e, ex)
        | Success (ex, odata) ->
          let od:ObjData = #{id,odata}
          in Success (ex, od, offs + 8 + len)

freeObjData: (ExState, ObjData take (..)) -> ExState
freeObjData(ex, od) = ex

type ObjSuper = { nb_eb : U32
                , eb_size : U32
                , io_size : U32
                , nb_reserved_gc : U32
                , nb_reserved_del : U32
                , cur_eb : U32
                , cur_offs : U32
                , last_inum : U32
                , next_sqnum : U64
}
newObjSuper: ExState -> R (ExState, ObjSuper take(..)) ExState
freeObjSuper: (ExState, ObjSuper take (..)) -> ExState

mkObjSuper: (ObjSuper take(..), UbiVolInfo!, UbiDevInfo!) -> ObjSuper
mkObjSuper (sup, vol, dev) = sup {nb_eb=wubi_vol_size vol,
    eb_size=wubi_vol_usable_leb_size vol,
    io_size=wubi_dev_min_io_size dev, nb_reserved_gc=0, nb_reserved_del=0,
    cur_eb=0, cur_offs=0, last_inum=0, next_sqnum=0}

bilbyFsObjSuperSize : U32
bilbyFsObjSuperSize = 40

serialise_ObjSuper:(Buffer, BufOffs, ObjSuper!) -> (Buffer, BufOffs)
serialise_ObjSuper(buf, offs, os) =
  let buf = serialise_le32(buf, offs, os.nb_eb)
  and buf = serialise_le32(buf, offs+4, os.eb_size)
  and buf = serialise_le32(buf, offs+8, os.io_size)
  and buf = serialise_le32(buf, offs+12, os.nb_reserved_gc)
  and buf = serialise_le32(buf, offs+16, os.nb_reserved_del)
  and buf = serialise_le32(buf, offs+20, os.cur_eb)
  and buf = serialise_le32(buf, offs+24, os.cur_offs)
  and buf = serialise_le32(buf, offs+28, os.last_inum)
  and buf = serialise_le64(buf, offs+32, os.next_sqnum)
  in (buf, offs+bilbyFsObjSuperSize)

serialise_size_ObjSuper: ObjSuper! -> U32
serialise_size_ObjSuper _ = bilbyFsObjSuperSize

deserialise_ObjSuper: (ExState, Buffer!, BufOffs) -> R (ExState, ObjSuper, BufOffs) (ErrCode, ExState)
deserialise_ObjSuper(ex, buf, offs) =
  newObjSuper ex
  | Error ex ->
    Error (eNoMem, ex)
  | Success (ex, sup) ->
    let nb_eb = deserialise_le32(buf, offs)
    and eb_size = deserialise_le32(buf, offs+4)
    and io_size = deserialise_le32(buf, offs+8)
    and nb_reserved_gc = deserialise_le32(buf, offs+12)
    and nb_reserved_del = deserialise_le32(buf, offs+16)
    and cur_eb = deserialise_le32(buf, offs+20)
    and cur_offs = deserialise_le32(buf, offs+24)
    and last_inum = deserialise_le32(buf, offs+28)
    and next_sqnum = deserialise_le64(buf, offs+32)
    and sup = sup {nb_eb, eb_size, io_size, nb_reserved_gc, nb_reserved_del, cur_eb, cur_offs, last_inum, next_sqnum}
    in Success (ex, sup, offs+bilbyFsObjSuperSize)

type ObjInodeFlags = U32

type ObjInode = {id : ObjId
           , size : U64
           , atime_sec : U64
           , ctime_sec : U64
           , mtime_sec : U64
           , nlink : U32
           , uid : U32
           , gid : U32
           , mode : U32
           , flags : ObjInodeFlags
           -- , pad : U64
}
newObjInode: ExState -> R (ExState, ObjInode take(..)) ExState
freeObjInode: (ExState, ObjInode take (..)) -> ExState

bilbyFsOidMaskInum : U64
bilbyFsOidMaskInum = upcast word32Max << 32

{-
 definition "PObjInode data offs ==
     ObjInode.make
       (((Ple64 data offs) & ~(bilbyFsOidMaskAll | u32_to_u64(Word32Max)) | bilbyFsOidMaskInode) (* id *)
       (Ple64 data (offs+8)) (* size *)
       (Ple64 data (offs+16)) (* atime *)
       (Ple64 data (offs+24)) (* ctime *)
       (Ple64 data (offs+32)) (* mtime *)
       (Ple32 data (offs+40)) (* nlink *)
       (Ple32 data (offs+44)) (* uid *)
       (Ple32 data (offs+48)) (* gid *)
       (Ple32 data (offs+52)) (* mode *)
       (Ple32 data (offs+56)) (* flags *)
       (* End 60 bytes *)"

serialise_ObjInode(buf,offs,oi) = (buf', offs')
 precondition:
   offs + 60 <= buf.bound
   oi.oid = (oid & ~(bilbyFsOidMaskAll | u32_to_u64(Word32Max))
 postcondition:
   oi = PObjInode buf'.data offs
-}

serialise_ObjInode:(Buffer, BufOffs, ObjInode!) -> (Buffer, BufOffs)
serialise_ObjInode(buf, offs, oi) =
  let buf = serialise_le64(buf, offs, oi.id)
  and buf = serialise_le64(buf, offs+8, oi.size)
  and buf = serialise_le64(buf, offs+16, oi.atime_sec)
  and buf = serialise_le64(buf, offs+24, oi.ctime_sec)
  and buf = serialise_le64(buf, offs+32, oi.mtime_sec)
  and buf = serialise_le32(buf, offs+40, oi.nlink)
  and _ = _cogent_debug "serialiseObjInode uid "
  and _ = _cogent_debug_u32 oi.uid
  and _ = _cogent_debug "\n"
  and buf = serialise_le32(buf, offs+44, oi.uid)
  and buf = serialise_le32(buf, offs+48, oi.gid)
  and buf = serialise_le32(buf, offs+52, oi.mode)
  in (serialise_le32(buf, offs+56, oi.flags), offs+60)

bilbyFsObjInode : U32
bilbyFsObjInode = 60

{-# cinline serialise_size_ObjInode #-}
serialise_size_ObjInode: ObjInode! -> U32
serialise_size_ObjInode _ = bilbyFsObjInode

{-# cinline binNot #-}
binNot: U64 -> U64
binNot w = word64Max .^. w


{-
 precondition:
  offs + 60 <= buf.bound
 postcondition:
 !!h. if isError r then
    r = Error (eInval, h)
  else
    r = Success (h, PObjInode buf.data offs, offs + 56)
-}
deserialise_ObjInode: (ExState, Buffer!, BufOffs) -> R (ExState, ObjInode, BufOffs) (ErrCode, ExState)
deserialise_ObjInode(ex, buf, offs) =
  let id = deserialise_le64(buf, offs)
  -- Ensure type of oid is ObjInode and xinfo = 0
  in if (id  .&. binNot (bilbyFsOidMaskAll .|. (u32_to_u64 word32Max)) .|. bilbyFsOidMaskInode) /= id then
      Error (eInval, ex)
  else
    newObjInode ex
    | Error ex ->
      Error (eNoMem, ex)
    | Success (ex, oi) ->
      let size = deserialise_le64(buf, offs + 8)
      and atime_sec = deserialise_le64(buf, offs + 16)
      and ctime_sec = deserialise_le64(buf, offs + 24)
      and mtime_sec = deserialise_le64(buf, offs + 32)
      and nlink = deserialise_le32(buf, offs + 40)
      and uid = deserialise_le32(buf, offs + 44)
      and _ = _cogent_debug "deserialiseObjInode uid "
      and _ = _cogent_debug_u32 uid
      and _ = _cogent_debug "\n"
      and gid = deserialise_le32(buf, offs + 48)
      and mode = deserialise_le32(buf, offs + 52)
      and flags = deserialise_le32(buf, offs + 56)
      and oi = oi{id,size,atime_sec,ctime_sec,mtime_sec,nlink,uid,gid,mode,flags}
      in Success (ex, oi, offs + 60)

{-
  deserialise_u8
    precondition:
     wellformed_buf buf
     offs + 1 > offs
    postcondition:
      if offs >= buf.bound then
        Error eInval
      else Success (buf[offs], offs+1)
       
-}
{-# cinline deserialise_u8 #-}
deserialise_u8: (Buffer!, BufOffs) -> U8
deserialise_u8(buf, offs) =
  wordarray_get[U8] (buf.data, offs)

{-# cinline deserialise_le16 #-}
deserialise_le16: (Buffer!, BufOffs) -> U16
deserialise_le16(buf, offs) =
  let b0 = wordarray_get[U8] (buf.data, offs)
  and b1 = wordarray_get[U8] (buf.data, offs + 1)
  in ((u8_to_u16(b1) << 8) .|. u8_to_u16(b0))

{-
  (* le32 is undefined if offs + 3 >= buf.bound *)
  definition "le32 data offs == (u8_to_u32(data[offs+3]) << 24) | (u8_to_u32(data[offs+2]) << 16) |
                (u8_to_u32(data[offs+1]) << 8) | u8_to_u32(data[offs])"

  deserialise_le32
    precondition:
     wellformed_buf buf
     offs + 4 > offs
    postcondition:
      le32(buf.data, offs)
-}
{-# cinline deserialise_le32 #-}
deserialise_le32: (Buffer!, BufOffs) -> U32
deserialise_le32 (buf, offs) =
  let b0 = wordarray_get[U8] (buf.data, offs)
  and b1 = wordarray_get[U8] (buf.data, offs + 1)
  and b2 = wordarray_get[U8] (buf.data, offs + 2)
  and b3 = wordarray_get[U8] (buf.data, offs + 3)
  in ((u8_to_u32(b3) << 24) .|. (u8_to_u32(b2) << 16) .|.
      (u8_to_u32(b1) << 8) .|. u8_to_u32(b0))

{-# cinline deserialise_le64 #-}
deserialise_le64: (Buffer!, BufOffs) -> U64
deserialise_le64(buf, offs) =
  let b0 = wordarray_get[U8] (buf.data, offs)
  and b1 = wordarray_get[U8] (buf.data, offs + 1)
  and b2 = wordarray_get[U8] (buf.data, offs + 2)
  and b3 = wordarray_get[U8] (buf.data, offs + 3)
  and b4 = wordarray_get[U8] (buf.data, offs + 4)
  and b5 = wordarray_get[U8] (buf.data, offs + 5)
  and b6 = wordarray_get[U8] (buf.data, offs + 6)
  and b7 = wordarray_get[U8] (buf.data, offs + 7)
  in ((u8_to_u64(b7) << 56) .|. (u8_to_u64(b6) << 48) .|.
      (u8_to_u64(b5) << 40) .|. (u8_to_u64(b4) << 32) .|.
      (u8_to_u64(b3) << 24) .|. (u8_to_u64(b2) << 16) .|.
      (u8_to_u64(b1) << 8) .|. u8_to_u64(b0))
-- similar to above

deserialise_Obj_crc: (ExState, Buffer!, BufOffs) -> R (ExState, Obj, BufOffs) (ErrCode, ExState)
deserialise_Obj_crc(ex, buf, offs) =
  _cogent_debug "deserialise_Obj_crc offs=" ;
  _cogent_debug_u32 offs ;
  _cogent_debug "\n" ;
  deserialise_Obj(ex, buf, offs)
  | Error (err, ex) ->
    _cogent_debug "Could not deserialise Obj at " ;
    _cogent_debug_u32 offs ;
    _cogent_debug "\n" ;
    Error (err, ex)
  | Success (ex, obj, end_offs) ->
    -- assert (end_offs == offs + obj.len) !obj ;
    let crcsum = crc32_buf #{buf, frm = offs + 8, to = end_offs} !buf
    and crc = obj.crc !obj
    and obj {offs=_} = obj
    and obj = obj {offs}
    and _ = _cogent_debug "deserialise_Obj_crc: crc check end_offs=" 
    and _ = _cogent_debug_u32 end_offs
    and _ = _cogent_debug "\n" 
    and obj {ounion} = obj
    and _ = _print_ObjHeader obj !obj
    and obj = obj {ounion} 
    in if crc == crcsum then
      Success (ex, obj, end_offs)
    else
      _cogent_debug "Invalid CRC Obj at offs=" ;
      _cogent_debug_u32 offs ;
      _cogent_debug "\n" ;
      let ex = deep_freeObj(ex, obj)
      in Error (eInval, ex)

{-# cinline setu8 #-}
setu8:  #{elem: U8, acc: (), obsv: U8! } -> #{elem: U8, acc: () }
setu8 #{elem=_, acc, obsv=elem} = #{elem,acc}

{-# cinline serialise_u8 #-}
serialise_u8: (Buffer, BufOffs, U8) -> Buffer
serialise_u8(buf {bound,data}, offs, val) =
  let #{arr=data, acc=_} = wordarray_modify[U8,(),U8] #{arr=data, idx=offs, f=setu8, acc=(), obsv=val}
  in buf {bound,data}

{-# cinline serialise_size_u8 #-}
serialise_size_u8: U8 -> U32
serialise_size_u8 _ = 1

{-
 serialise_le32
    precondition:
     offs + 4 > offs
     offs + 4 <= buf.bound
     wellformed_buf buf
    postcondition:
     le32(buf.data, offs) = val
-}
{-# cinline serialise_le32 #-}
serialise_le32: (Buffer, BufOffs, U32) -> Buffer
serialise_le32(buf, offs, val) =
  let buf = serialise_u8(buf, offs, u32_to_u8(val))
  and buf = serialise_u8(buf, offs+1, u32_to_u8(val >> 8))
  and buf = serialise_u8(buf, offs+2, u32_to_u8(val >> 16))
  in serialise_u8(buf, offs+3, u32_to_u8(val >> 24))

{-# cinline serialise_le16 #-}
serialise_le16: (Buffer, BufOffs, U16) -> Buffer
serialise_le16(buf, offs, val) =
  let buf = serialise_u8(buf, offs, u16_to_u8(val))
  in serialise_u8(buf, offs+1, u16_to_u8(val >> 8))

{-# cinline serialise_size_le32 #-}
serialise_size_le32: U32 -> U32
serialise_size_le32 _ = 4

u64_to_u8: U64 -> U8

{-
     see serialise_le32
-}
{-# cinline serialise_le64 #-}
serialise_le64: (Buffer, BufOffs, U64) -> Buffer
serialise_le64(buf, offs, val) =
  let buf = serialise_u8(buf, offs, u64_to_u8(val))
  and buf = serialise_u8(buf, offs+1, u64_to_u8(val >> 8))
  and buf = serialise_u8(buf, offs+2, u64_to_u8(val >> 16))
  and buf = serialise_u8(buf, offs+3, u64_to_u8(val >> 24))
  and buf = serialise_u8(buf, offs+4, u64_to_u8(val >> 32))
  and buf = serialise_u8(buf, offs+5, u64_to_u8(val >> 40))
  and buf = serialise_u8(buf, offs+6, u64_to_u8(val >> 48))
  in        serialise_u8(buf, offs+7, u64_to_u8(val >> 56))

{-# cinline serialise_size_le64 #-}
serialise_size_le64: U64 -> U32
serialise_size_le64 _ = 8

-- This function does not work with ounion.ObjPad and ounion.ObjData
{-# cinline serialise_size_Obj #-}
serialise_size_Obj: Obj! -> U32
serialise_size_Obj o =
  bilbyFsObjHeaderSize + serialise_size_ObjUnion o.ounion

-- This function cannot be used with an ObjPad
serialise_size_ObjUnion: ObjUnion! -> U32
serialise_size_ObjUnion  ounion =
 ounion
 | TObjInode o -> serialise_size_ObjInode o
 | TObjData o -> serialise_size_ObjData o
 | TObjDentarr o -> serialise_size_ObjDentarr o
 | TObjDel o -> serialise_size_ObjDel o
 | TObjSuper o -> serialise_size_ObjSuper o
 | TObjSummary o -> serialise_size_ObjSummary o.nb_sum_entry
 | TObjPad o -> 0

{-# cinline deep_freeObjInode #-}
deep_freeObjInode: (ExState, ObjInode) -> ExState
deep_freeObjInode(ex, v) = freeObjInode(ex, v)

{-# cinline deep_freeObjData #-}
deep_freeObjData: (ExState, ObjData) -> ExState
deep_freeObjData(ex, v) =
  let v {odata,id} = v
  and ex = wordarray_free[U8] (ex, odata) in
  freeObjData(ex, v)

{-# cinline deep_freeObjSuper #-}
deep_freeObjSuper: (ExState, ObjSuper) -> ExState
deep_freeObjSuper(ex, v) = freeObjSuper(ex, v)

serialise_Obj_crc: (Buffer, U32, Obj) -> (Buffer, U32, Obj)
serialise_Obj_crc (buf, offs, obj) =
  let (buf, offs') = serialise_Obj(buf, offs, obj) !obj
  -- compute CRC32 from after crc field to end of object
  and crc = crc32_buf #{buf, frm=offs + 8, to=offs'} !buf
  and obj = obj {crc, offs}
  and buf = serialise_le32(buf, offs + 4, crc)
  in (buf, offs', obj)

-- This is silly but we can't build a complete Obj
-- otherwise we can't guarantee that we will get
-- ObjSuper back
serialise_Obj_Super_crc: (ExState,Buffer, U32, Obj take (ounion), ObjSuper!) -> (ExState, Buffer, U32, Obj take (ounion))
serialise_Obj_Super_crc (ex,buf, offs, obj, sup) =
  let obj = obj {ounion = TObjPad ()}
  and (buf, offs') = serialise_ObjHeader(buf, offs, obj) !obj
  and obj {ounion} = obj
  and ex = deep_freeObjUnion(ex, ounion)
  and (buf, offs') = serialise_ObjSuper(buf, offs', sup)
  -- compute CRC32 from after crc field to end of object
  and crc = crc32_buf#{buf, frm=offs + 8, to=offs'} !buf
  and obj = obj {crc}
  and buf = serialise_le32(buf, offs + 4, crc)
  in (ex, buf, offs', obj)

