--
-- Copyright 2016, NICTA
--
-- This software may be distributed and modified according to the terms of
-- the GNU General Public License version 2. Note that NO WARRANTY is provided.
-- See "LICENSE_GPLv2.txt" for details.
--
-- @TAG(NICTA_GPL)
--

include "bilbyfs.cogent"
include "ostore.cogent"

set_read_only_mode : FsopState -> FsopState
set_read_only_mode(fsop_st {is_ro}) = fsop_st { is_ro = True }

obj_dentry_new_init: (ExState, VfsIno, (WordArray U8)!, U8) -> RR ExState ObjDentry ErrCode
obj_dentry_new_init(ex, ino, name, dtype) =
  newObjDentry(ex)
  | Error ex -> (ex, Error eNoMem)
  | Success (ex, odent) ->
    wordarray_clone[U8] (ex, name)
    | Error ex -> (freeObjDentry(ex, odent), Error eNoMem)
    | Success (ex, name) ->
      let nlen = u32_to_u16(wordarray_length[U8] name) !name
      in (ex, Success (odent {dtype,ino,nlen,name}))

vnode_init_perm: (ExState, VfsInode!, VfsInode, VfsMode) -> (ExState, VfsInode)
vnode_init_perm (ex, vdir, inode, mode) =
  let v_uid = os_get_current_fsuid(ex) !ex
  and is_gid = is_set ((vfs_inode_get_mode vdir), s_ISGID)
  and mode = if is_gid && vmode_is_dir(mode) then mode .|. s_ISGID else mode
  and v_gid = if is_gid then vfs_inode_get_gid (vdir) else os_get_current_fsgid(ex) !ex
  and inode = vfs_inode_set_uid (inode, v_uid)
  and inode = vfs_inode_set_gid (inode, v_gid)
  and inode = vfs_inode_set_mode (inode, mode)
  in (ex, inode)

init_vnode: (ExState, OstoreState, VfsInode!, VfsInode, VfsMode) -> RR (ExState, OstoreState, VfsInode) () ErrCode
init_vnode(ex, ostore_st, vdir, vnode, mode) =
  let (ostore_st, r) = ostore_alloc_inode(ostore_st)
  in r
  | Success v_ino ->
    _cogent_debug "init_vnode allocate ino " ;
    _cogent_debug_u32 v_ino ;
    _cogent_debug "\n" ;
    let vnode = vnode { fs = #{a=0} }
    and (ex, vnode) = vnode_init_perm(ex, vdir, vnode, mode)
    and v_flags:VfsMode = 0
    and v_flags = v_flags .|. x_NOCMTIME
    and (ex, time) = os_get_current_time ex
    and v_nlink:U32 = 1
    and v_size:U64 = 0
    and vnode = vfs_inode_set_ino (vnode, v_ino)
    and vnode = vfs_inode_set_flags (vnode, v_flags)
    and vnode = vfs_inode_set_ctime (vnode, time)
    and vnode = vfs_inode_set_mtime (vnode, time)
    and vnode = vfs_inode_set_nlink (vnode, v_nlink)
    and vnode = vfs_inode_set_size (vnode, v_size)
    in ((ex, ostore_st, vnode), Success ())
  | Error err -> ((ex, ostore_st, vnode), Error err)

extract_dentarr_from_union:(ExState, ObjUnion) -> R (ExState, ObjDentarr) ExState
extract_dentarr_from_union(ex, ounion) =
  ounion
  | TObjPad _       -> Error ex
  | TObjInode v     -> Error (deep_freeObjInode(ex,v))
  | TObjData v      -> Error (deep_freeObjData(ex,v))
  | TObjDel v       -> Error ex
  | TObjSuper v     -> Error (deep_freeObjSuper(ex,v))
  | TObjSummary v   -> Error (summary_clean(ex,v))
  | TObjDentarr odent -> Success (ex, odent)

read_or_create_dentarr:(ExState, MountState!, OstoreState, ObjId) -> RR (ExState, OstoreState) (Obj take (ounion),  ObjDentarr, Bool) ErrCode
read_or_create_dentarr(ex, mount_st, ostore_st, oid) =
  let ((ex, ostore_st), r) = ostore_read(ex, mount_st, ostore_st, oid)
  in r
  | Success obj ->
    let obj {ounion} = obj
    in extract_dentarr_from_union(ex, ounion)
    | Error (ex) ->
      let obj {crc,magic,sqnum,offs, len, trans, otype} = obj
      and ex = freeObj(ex, obj)
      in ((ex, ostore_st), Error eInval)
    | Success (ex, dentarr) ->
      ((ex, ostore_st), Success (obj, dentarr, False))
  | Error e ->
    if e /= eNoEnt then
      ((ex, ostore_st), Error e)
    else
      newObj(ex)
      | Error ex -> ((ex, ostore_st), Error eNoMem)
      | Success (ex, obj) ->
        array_create[ObjDentry] (ex, 1) --  Empty slot at the end
        | Error ex ->
          let ex = freeObj(ex, obj)
          in ((ex, ostore_st), Error eNoMem)
        | Success (ex, entries) ->
          newObjDentarr ex
          | Error ex ->
            let ex = freeObj(ex, obj)
            and ex = array_free[ObjDentry] #{arr=entries, f=deep_freeObjDentry, ex}
            in ((ex, ostore_st), Error eNoMem)
          | Success (ex, dentarr) ->
            let nb_dentry:U32 = 0
            and dentarr = dentarr {id=oid,nb_dentry,entries}
            and obj = obj_init_default(obj, bilbyFsObjTypeDentarr)
            and obj = obj {len=bilbyFsObjHeaderSize + bilbyFsObjDentarrHeaderSize}
            -- obj.len is updated everytime we touch dentarrs.
            in ((ex, ostore_st), Success (obj, dentarr, True))

add_dentry_modifier: #{oelem: Option ObjDentry, acc:(ExState, Option ObjDentry)} -> #{oelem: Option ObjDentry, acc: (ExState, Option ObjDentry)}
add_dentry_modifier #{oelem=old_entry, acc=(ex, opt_newentry)} =
 opt_newentry
 | Some newentry ->
   let ex = free_opt_ObjDentry (ex, old_entry)
   in #{oelem=Some newentry, acc=(ex, None)}
 | None -> #{oelem=old_entry, acc=(ex, None)}

free_opt_ObjDentry : (ExState, Option ObjDentry) -> ExState
free_opt_ObjDentry (ex, opt_entry) =
  opt_entry
  | Some old -> deep_freeObjDentry(ex, old)
  | None -> ex

dentarr_add_dentry: (ExState, ObjDentarr, VfsInode!, (WordArray U8)!, U8) -> RR (ExState, ObjDentarr) () ErrCode
dentarr_add_dentry(ex, odent, vnode, name, dtype) =
  let nb_dentry = odent.nb_dentry !odent
  and name_len = wordarray_length[U8](name)
  -- Do we need the MaxNbDentarrEntries check?
  -- Probably yes, because we need evidences that dentarr will fit in a transaction.
  in if nb_dentry + 1 > bilbyFsMaxNbDentarrEntries ||
        name_len > bilbyFsMaxNameLen+1 then -- name_len includes \0
    ((ex, odent), Error eNameTooLong)
  else
    let (ex, r) = obj_dentry_new_init(ex, vfs_inode_get_ino (vnode), name, dtype)
    in r
    | Error e -> ((ex, odent), Error e)
    | Success newentry ->
      let odent {id, entries} = odent
      -- Mark this as a bug found via verification.
      and last_index = array_length[ObjDentry] entries - 1 !entries
      and #{arr=entries, acc=(ex, opt_entry)} = array_modify[ObjDentry, (ExState, Option ObjDentry)]
                                                  #{arr=entries, idx=last_index, f=add_dentry_modifier, acc=(ex, Some newentry)}
      and nb_dentry = nb_dentry + 1
      and ex = free_opt_ObjDentry (ex, opt_entry)
      in ((ex, odent {id, nb_dentry, entries}), Success ())

del_dentry_modifier: #{elem:ObjDentry, acc: ExState, obsv: (WordArray U8)!} -> RR ExState () ObjDentry
del_dentry_modifier #{elem=dentry, acc=ex, obsv=name} =
  let same_names = wordarray_cmp(name, dentry.name) !dentry in
  if same_names then
    let ex = deep_freeObjDentry(ex, dentry)
    in (ex, Success ())
  else
    (ex, Error dentry)

dentarr_del_dentry: (ExState, ObjDentarr, (WordArray U8)!) -> (ExState, ObjDentarr)
dentarr_del_dentry(ex, odent {entries}, name) =
  let #{arr=entries, acc=ex} = array_filter[ObjDentry, ExState, WordArray U8]
                                 #{arr=entries, f=del_dentry_modifier, acc=ex, obsv=name}
  and nb_dentry = odent.nb_dentry - 1 !odent
  in (ex, odent {nb_dentry, entries})

set_obj: #{oelem: Option Obj, acc: (ExState, Option Obj)} -> #{oelem:Option Obj, acc:(ExState, Option Obj)}
set_obj #{oelem=opt_obj, acc=(ex, newopt_obj)} =
  newopt_obj
  | Some newo ->
    opt_obj
    | Some o ->
      let ex = deep_freeObj(ex, o)
      in #{oelem=Some newo, acc=(ex, None)}
    | None -> #{oelem=Some newo, acc=(ex, None)}
  | None -> #{oelem=opt_obj, acc=(ex, None)}

free_opt_obj: (ExState, Option Obj) -> ExState
free_opt_obj (ex, opt_obj) =
  opt_obj
  | None -> ex
  | Some o -> deep_freeObj (ex, o)

arrayobj_create1: (ExState, Obj) -> R (ExState, Array Obj) ExState
{-
arrayobj_create1(ex, o1) =
  array_create[Obj] (ex, 1)
  | Error (ex) ->
    let ex = deep_freeObj(ex, o1)
    in (Error ex)
  | Success (ex, arr) ->
    let array_modify' = array_modify[Obj, (ExState, Option Obj)]
    and #{arr, acc=(ex, opt1)} = array_modify' #{arr=arr, idx=0, f=set_obj, acc=(ex, Some o1)}
    and ex = free_opt_obj (ex, opt1)
    in Success (ex, arr)
    -}

arrayobj_create2: (ExState, Obj, Obj) -> R (ExState, Array Obj) (ExState, Obj)
arrayobj_create2(ex, o1, o2) =
  array_create[Obj] (ex, 2)
  | Error (ex) ->
    let ex = deep_freeObj(ex, o1)
    in Error (ex, o2)
  | Success (ex, arr) ->
    let #{arr=arr, acc=(ex, opt1)} = array_modify[Obj, (ExState, Option Obj)]
                                       #{arr=arr, idx=0, f=set_obj, acc=(ex, Some o1)}
    and #{arr=arr, acc=(ex, opt2)} = array_modify[Obj, (ExState, Option Obj)]
                                       #{arr=arr, idx=1, f=set_obj, acc=(ex, Some o2)}
    and ex = free_opt_obj (ex, opt1)
    and ex = free_opt_obj (ex, opt2)
    in Success (ex, arr)

arrayobj_create3: (ExState, Obj, Obj, Obj) -> R (ExState, Array Obj) ExState
{-
arrayobj_create3(ex, o1, o2, o3) =
  array_create[Obj] (ex, 3)
  | Error (ex) ->
    let ex = deep_freeObj(ex, o1)
    and ex = deep_freeObj(ex, o2)
    and ex = deep_freeObj(ex, o3)
    in Error ex
  | Success (ex, arr) ->
    let #{arr=arr, acc=(ex, opt1)} = array_modify[Obj, (ExState, Option Obj)]
                                       #{arr=arr, idx=0, f=set_obj, acc=(ex, Some o1)}
    and #{arr=arr, acc=(ex, opt2)} = array_modify[Obj, (ExState, Option Obj)]
                                       #{arr=arr, idx=1, f=set_obj, acc=(ex, Some o2)}
    and #{arr=arr, acc=(ex, opt3)} = array_modify[Obj, (ExState, Option Obj)]
                                       #{arr=arr, idx=2, f=set_obj, acc=(ex, Some o3)}
    and ex = free_opt_obj (ex, opt1)
    and ex = free_opt_obj (ex, opt2)
    and ex = free_opt_obj (ex, opt3)
    in Success (ex, arr)
-}

arrayobj_create4_ret2: (ExState, Obj, Obj, Obj, Obj) -> R (ExState, Array Obj) (ExState, Obj)
arrayobj_create4: (ExState, Obj, Obj, Obj, Obj) -> R (ExState, Array Obj) ExState
{-
arrayobj_create4(ex, o1, o2, o3, o4) =
  array_create[Obj] (ex, 4)
  | Error (ex) ->
    let ex = deep_freeObj(ex, o1)
    and ex = deep_freeObj(ex, o2)
    and ex = deep_freeObj(ex, o3)
    and ex = deep_freeObj(ex, o4)
    in Error ex
  | Success (ex, arr) ->
    let #{arr=arr, acc=(ex, opt1)} = array_modify[Obj, (ExState, Option Obj)]
                                       #{arr=arr, idx=0, f=set_obj, acc=(ex, Some o1)}
    and #{arr=arr, acc=(ex, opt2)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=1, f=set_obj, acc=(ex, Some o2)}
    and #{arr=arr, acc=(ex, opt3)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=2, f=set_obj, acc=(ex, Some o3)}
    and #{arr=arr, acc=(ex, opt4)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=3, f=set_obj, acc=(ex, Some o4)}
    and ex = free_opt_obj (ex, opt1)
    and ex = free_opt_obj (ex, opt2)
    and ex = free_opt_obj (ex, opt3)
    and ex = free_opt_obj (ex, opt4)
    in Success (ex, arr)
-}

arrayobj_create5: (ExState, Obj, Obj, Obj, Obj, Obj) -> R (ExState, Array Obj) ExState
{-
arrayobj_create5(ex, o1, o2, o3, o4, o5) =
  array_create[Obj] (ex, 5)
  | Error (ex) ->
    let ex = deep_freeObj(ex, o1)
    and ex = deep_freeObj(ex, o2)
    and ex = deep_freeObj(ex, o3)
    and ex = deep_freeObj(ex, o4)
    and ex = deep_freeObj(ex, o5)
    in Error ex
  | Success (ex, arr) ->
    let #{arr=arr, acc=(ex, opt1)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=0, f=set_obj, acc=(ex, Some o1)}
    and #{arr=arr, acc=(ex, opt2)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=1, f=set_obj, acc=(ex, Some o2)}
    and #{arr=arr, acc=(ex, opt3)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=2, f=set_obj, acc=(ex, Some o3)}
    and #{arr=arr, acc=(ex, opt4)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=3, f=set_obj, acc=(ex, Some o4)}
    and #{arr=arr, acc=(ex, opt5)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=4, f=set_obj, acc=(ex, Some o5)}
    and ex = free_opt_obj (ex, opt1)
    and ex = free_opt_obj (ex, opt2)
    and ex = free_opt_obj (ex, opt3)
    and ex = free_opt_obj (ex, opt4)
    and ex = free_opt_obj (ex, opt5)
    in Success (ex, arr)
-}

arrayobj_create6: (ExState, Obj, Obj, Obj, Obj, Obj, Obj) -> R (ExState, Array Obj) ExState
{-
arrayobj_create6(ex, o1, o2, o3, o4, o5, o6) =
  array_create[Obj] (ex, 6)
  | Error (ex) ->
    let ex = deep_freeObj(ex, o1)
    and ex = deep_freeObj(ex, o2)
    and ex = deep_freeObj(ex, o3)
    and ex = deep_freeObj(ex, o4)
    and ex = deep_freeObj(ex, o5)
    and ex = deep_freeObj(ex, o6)
    in Error ex
  | Success (ex, arr) ->
    let #{arr=arr, acc=(ex, opt1)} = array_modify[Obj, (ExState, Option Obj)]
                                       #{arr=arr, idx=0, f=set_obj, acc=(ex, Some o1)}
    and #{arr=arr, acc=(ex, opt2)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=1, f=set_obj, acc=(ex, Some o2)}
    and #{arr=arr, acc=(ex, opt3)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=2, f=set_obj, acc=(ex, Some o3)}
    and #{arr=arr, acc=(ex, opt4)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=3, f=set_obj, acc=(ex, Some o4)}
    and #{arr=arr, acc=(ex, opt5)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=4, f=set_obj, acc=(ex, Some o5)}
    and #{arr=arr, acc=(ex, opt6)} = array_modify[Obj, (ExState, Option Obj)]
                                        #{arr=arr, idx=5, f=set_obj, acc=(ex, Some o6)}
    and ex = free_opt_obj (ex, opt1)
    and ex = free_opt_obj (ex, opt2)
    and ex = free_opt_obj (ex, opt3)
    and ex = free_opt_obj (ex, opt4)
    and ex = free_opt_obj (ex, opt5)
    and ex = free_opt_obj (ex, opt6)
    in Success (ex, arr)
-}


dentarr_calculate_sz_change: (Bool, Obj) -> RR Obj U32 ErrCode
dentarr_calculate_sz_change(created, objdent) =
  let sz = serialise_size_Obj(objdent) !objdent
  in if not created then
    safe_sub32(sz, objdent.len) !objdent
    | Error () ->
      _cogent_debug "dentarr_calculate_sz_change underflow " ;
      (objdent, Error eOverflow)
    | Success sz_change ->
      (objdent {len=sz}, Success sz_change)
  else
    (objdent {len=sz}, Success sz)

dentarr_del_calculate_sz_change: (ExState, Obj take (ounion), ObjDentarr) -> RR (ExState, Obj) U32 ErrCode
dentarr_del_calculate_sz_change(ex, obj, dentarr) =
  let is_del = (array_nb_elem[ObjDentry] dentarr.entries) == 0 !dentarr
  and id = dentarr.id !dentarr
  and (ex, ounion):(ExState, ObjUnion) =
      if is_del then (deep_freeObjDentarr (ex, dentarr), let v:ObjDel = #{id} in TObjDel v) else (ex, TObjDentarr dentarr)
  and obj = obj {ounion}
  and len = serialise_size_Obj(obj) !obj
  in safe_sub32(obj.len, len) !obj
  | Error () -> ((ex, obj), Error eOverflow)
  | Success sz_change ->
    ((ex, obj {len}), Success sz_change)

obj_inode_new: (ExState, VfsInode!) -> RR ExState Obj ErrCode
obj_inode_new(ex, vnode) =
  newObj(ex)
  | Error ex -> (ex, Error eNoMem)
  | Success (ex, obj) ->
    newObjInode ex
    | Error ex ->
      let ex = freeObj (ex, obj)
      in (ex, Error eNoMem)
    | Success (ex, inode) ->
      let obj = obj_init_default(obj, bilbyFsObjTypeInode)
      and id = obj_id_inode_mk(vfs_inode_get_ino vnode)
      and size = vfs_inode_get_size vnode
      and mtime = vfs_inode_get_mtime vnode
      and ctime = vfs_inode_get_ctime vnode
      and atime_sec = upcast mtime.tv_sec
      and ctime_sec = upcast ctime.tv_sec
      and mtime_sec = upcast mtime.tv_sec
      and nlink = vfs_inode_get_nlink vnode
      and uid = vfs_inode_get_uid vnode
      and gid = vfs_inode_get_gid vnode
      and mode = vfs_inode_get_mode vnode
      and flags  = vfs_inode_get_flags vnode
      and inode = inode {id,size,atime_sec,ctime_sec,mtime_sec,nlink,uid,gid,mode,flags}
      and obj  = obj {ounion = TObjInode inode}
      and len = serialise_size_Obj obj !obj
      and obj = obj {len}
      in (ex, Success obj)

obj_data_new: (ExState, ObjId, U32, WordArray U8) -> RR ExState Obj (ErrCode, WordArray U8)
obj_data_new(ex, id, len, odata) =
  newObj(ex)
  | Error ex -> (ex, Error (eNoMem, odata))
  | Success (ex, obj) ->
    let od = #{id, odata}
    and obj = obj_init_default(obj, bilbyFsObjTypeData)
    and obj = obj {len = bilbyFsObjHeaderSize + 8 + len}
    in (ex, Success (obj {ounion = TObjData od}))

obj_del_new: (ExState, ObjId) -> RR ExState Obj ErrCode
obj_del_new(ex, id) =
  newObj(ex)
    | Error ex -> (ex, Error eNoMem)
    | Success (ex, obj) ->
      let obj = obj_init_default(obj, bilbyFsObjTypeDel)
      and del = #{id}
      and obj = obj {ounion = TObjDel del}
      and len = serialise_size_Obj(obj) !obj
      and obj = obj {len}
      in (ex, Success obj)

dentarr_read_and_add: (ExState, MountState!, OstoreState, VfsInode!, CString!, VfsInode!, U8) -> RR (ExState, OstoreState) (U64, Obj) ErrCode
dentarr_read_and_add (ex, mount_st, ostore_st, vdir, name, vnode, dt) =
  let oid = obj_id_dentarr_mk(vfs_inode_get_ino vdir, name)
  and ((ex, ostore_st), r) = read_or_create_dentarr(ex, mount_st, ostore_st, oid)
  in r
  | Error err ->
    ((ex, ostore_st), Error err)
  | Success (dentarr_obj, dentarr, created) ->
    let ((ex, dentarr), r) = dentarr_add_dentry(ex, dentarr, vnode, name, dt)
    in r
    | Error err ->
      let dentarr_obj = dentarr_obj {ounion = TObjDentarr dentarr}
      and ex = deep_freeObj(ex, dentarr_obj)
      in ((ex, ostore_st), Error err)
    | Success () ->
      let dentarr_obj = dentarr_obj {ounion = TObjDentarr dentarr}
      and (dentarr_obj, r) = dentarr_calculate_sz_change(created, dentarr_obj)
      in r
      | Error err ->
        let ex = deep_freeObj (ex, dentarr_obj)
        in ((ex, ostore_st), Error err)
      | Success sz_change ->
        safe_add64 (vfs_inode_get_size vdir, upcast sz_change)
        | Error () ->
          _cogent_debug "create dir inode size increase overflow" ;
          _cogent_debug " sz_change = " ;
          _cogent_debug_u32_hex sz_change ;
          _cogent_debug "\n" ;
          let ex = deep_freeObj (ex, dentarr_obj)
          in ((ex, ostore_st), Error eOverflow)
        | Success new_v_size ->
          ((ex, ostore_st), Success (new_v_size, dentarr_obj))

type FsopCreateP = #{ex:ExState, fs_st: FsState, vdir: VfsInode, name: (WordArray U8)!, mode: VfsMode, vnode: VfsInode}
type FsopRR = #{ex:ExState, fs_st:FsState, vdir:VfsInode, vnode:VfsInode}
fsop_create : FsopCreateP -> RR FsopRR () ErrCode
fsop_create #{ex, fs_st = fs_st {ostore_st}, vdir, name, mode, vnode} =
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error eRoFs)
  else
   let ((ex, ostore_st, vnode), r) = init_vnode(ex, ostore_st, vdir, vnode, mode .|. s_IFREG) !vdir
   in r
   | Error err ->
     (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
   | Success () ->
     let ((ex, ostore_st), r) = dentarr_read_and_add (ex, fs_st.mount_st, ostore_st, vdir, name, vnode, bilbyFsITypeReg) !fs_st !vdir !vnode
     in r
     | Error err ->
       (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
     | Success (new_v_size, dentarr_obj) ->
       let (ex, r) = obj_inode_new(ex, vnode) !vnode
       in r
       | Error err ->
         let ex = deep_freeObj(ex, dentarr_obj)
         in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
       | Success inode ->
         let v_size' = vfs_inode_get_size vdir !vdir
         and v_mtime' = vfs_inode_get_mtime vdir !vdir
         and v_ctime' = vfs_inode_get_ctime vdir !vdir
         and (ex, time) = os_get_current_time(ex)
         and vdir = vfs_inode_set_size(vdir, new_v_size)
         and vdir = vfs_inode_set_mtime(vdir, time)
         and vdir = vfs_inode_set_ctime(vdir, time)
         and (ex, r) = obj_inode_new(ex, vdir) !vdir
         in r
         | Error err ->
            let ex = deep_freeObj(ex, dentarr_obj)
            and ex = deep_freeObj(ex, inode)
            and vdir = vfs_inode_set_size(vdir, v_size')
            and vdir = vfs_inode_set_mtime(vdir, v_mtime')
            and vdir = vfs_inode_set_ctime(vdir, v_ctime')
            in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
         | Success dir ->
           arrayobj_create3(ex, dentarr_obj, inode, dir)
           | Error ex ->
               let vdir = vfs_inode_set_size(vdir, v_size')
               and vdir = vfs_inode_set_mtime(vdir, v_mtime')
               and vdir = vfs_inode_set_ctime(vdir, v_ctime')
               in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error eNoMem)
           | Success (ex, arr) ->
               let ((ex, ostore_st, arr), r) = ostore_write(ex, fs_st.mount_st, ostore_st, arr, ostoreWriteNone) !fs_st
               in r
               | Error err ->
                 let vdir = vfs_inode_set_size(vdir, v_size')
                 and vdir = vfs_inode_set_mtime(vdir, v_mtime')
                 and vdir = vfs_inode_set_ctime(vdir, v_ctime')
                 and ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
                 in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
               | Success () ->
                 let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
                 in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Success ())

dentarr_read_and_del: (ExState, MountState!, OstoreState, VfsInode!, CString!) -> RR (ExState, OstoreState) (U64, Obj) ErrCode
dentarr_read_and_del (ex, mount_st, ostore_st, vdir, name) =
  let oid = obj_id_dentarr_mk(vfs_inode_get_ino vdir, name)
  and ((ex, ostore_st), r) = ostore_read(ex, mount_st, ostore_st, oid)
  in r
  | Error e ->
     ((ex, ostore_st), Error e)
  | Success (dentarr_obj {ounion}) ->
    extract_dentarr_from_union (ex, ounion)
    | Error ex ->
       -- invariant on ostore_read
       _cogent_assert False ;
       let ex = freeObj (ex, dentarr_obj)
       in ((ex, ostore_st), Error eInval)
    | Success (ex, dentarr) ->
      let (ex, dentarr) = dentarr_del_dentry (ex, dentarr, name)
      and ((ex, dentarr_obj), r) = dentarr_del_calculate_sz_change (ex, dentarr_obj, dentarr)
      in r
      | Error e ->
        _cogent_debug "dentarr_read_and_del: dentarr_del_calculate_sz_change: failed\n" ;
        let dentarr_obj {ounion} = dentarr_obj
        and ex = deep_freeObjUnion (ex, ounion)
        and ex = freeObj (ex, dentarr_obj)
        in ((ex, ostore_st), Error e)
      | Success sz_change ->
        safe_sub64(vfs_inode_get_size vdir, upcast sz_change)
        | Error () ->
          _cogent_debug "dentarr_read_and_del: dir size substraction failed\n" ;
          let ex = deep_freeObj (ex, dentarr_obj)
          in ((ex, ostore_st), Error eOverflow)
        | Success new_v_size ->
          ((ex, ostore_st), Success (new_v_size, dentarr_obj))

type FsopUnlinkP = #{ex:ExState, fs_st:FsState, vdir:VfsInode, name:(WordArray U8)!, vnode:VfsInode}
fsop_unlink : FsopUnlinkP -> RR FsopRR () ErrCode
fsop_unlink #{ex, fs_st = fs_st {ostore_st}, vdir, name, vnode} =
-- invariant on fs_st
-- vdir has correspondence with the object coming out of the object store.
-- vdir.n_link > 0
-- name in or not in directory
-- vnode has a correspondence with the object coming out of the object store.
-- vnode.n_link > 0
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error eRoFs)
  else
    let ((ex, ostore_st), r) = dentarr_read_and_del (ex, fs_st.mount_st, ostore_st, vdir, name) !fs_st !vdir
    in r
    | Error err ->
      _cogent_debug "fsop_unlink: dentarr_read_and_del failed\n" ;
      (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
    | Success (new_v_size, dentarr_obj) ->
      -- assumption v_nlink > 0 for fsop_unlink
      let vnode = vfs_inode_dec_nlink vnode
      and (ex, time) = os_get_current_time(ex)
      -- and vdir = vfs_inode_set_mtime(vnode, time)
      and vnode_ctime = vfs_inode_get_ctime vnode !vnode
      and vnode = vfs_inode_set_ctime(vnode, time)
      and (ex, r) = obj_inode_new(ex, vnode) !vnode
      in r
      | Error err ->
        let ex = deep_freeObj(ex, dentarr_obj)
        and vnode = vfs_inode_inc_nlink vnode
        and vnode = vfs_inode_set_ctime (vnode, vnode_ctime)
        in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
      | Success inode ->
        let v_size' = vfs_inode_get_size(vdir) !vdir
        and v_mtime' = vfs_inode_get_mtime(vdir) !vdir
        and v_ctime' = vfs_inode_get_ctime(vdir) !vdir
        and vdir = vfs_inode_set_size(vdir, new_v_size)
        and vdir = vfs_inode_set_mtime(vdir, time)
        and vdir = vfs_inode_set_ctime(vdir, time)
        and (ex, r) = obj_inode_new(ex, vdir) !vdir
        in r
        | Error err ->
           let ex = deep_freeObj(ex, dentarr_obj)
           and ex = deep_freeObj(ex, inode)
           and vdir = vfs_inode_set_size(vdir, v_size')
           and vdir = vfs_inode_set_mtime(vdir, v_mtime')
           and vdir = vfs_inode_set_ctime(vdir, v_ctime')
           and vnode = vfs_inode_inc_nlink vnode
           and vnode = vfs_inode_set_ctime (vnode, vnode_ctime)
           in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
        | Success dir ->
          arrayobj_create3(ex, dentarr_obj, inode, dir)
          | Error ex ->
              let vdir = vfs_inode_set_size(vdir, v_size')
              and vdir = vfs_inode_set_mtime(vdir, v_mtime')
              and vdir = vfs_inode_set_ctime(vdir, v_ctime')
              and vnode = vfs_inode_inc_nlink vnode
              and vnode = vfs_inode_set_ctime (vnode, vnode_ctime)
              in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error eNoMem) 
          | Success (ex, arr) ->
            let ((ex, ostore_st, arr), r) = ostore_write(ex, fs_st.mount_st, ostore_st, arr, ostoreWriteNone) !fs_st
            in r
            | Error err ->
              let vdir = vfs_inode_set_size(vdir, v_size')
              and vdir = vfs_inode_set_mtime(vdir, v_mtime')
              and vdir = vfs_inode_set_ctime(vdir, v_ctime')
              and ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
              and vnode = vfs_inode_inc_nlink vnode
              and vnode = vfs_inode_set_ctime (vnode, vnode_ctime)
              in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
            | Success () ->
              let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
              in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Success ())

fsop_mkdir : FsopCreateP -> RR FsopRR () ErrCode
fsop_mkdir #{ex, fs_st = fs_st {ostore_st}, vdir, name, mode, vnode} =
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error eRoFs)
  else
   let ((ex, ostore_st, vnode), r) = init_vnode(ex, ostore_st, vdir, vnode, mode .|. s_IFDIR) !vdir
   in r
   | Error err ->
     (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
   | Success () ->
     let ((ex, ostore_st), r) = dentarr_read_and_add (ex, fs_st.mount_st, ostore_st, vdir, name, vnode, bilbyFsITypeDir) !fs_st !vdir !vnode
     in r
     | Error err ->
       (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
     | Success (new_v_size, dentarr_obj) ->
       -- directory must have a linkcount of 2 initially
       let vnode = vfs_inode_set_nlink (vnode, 2)
       and (ex, r) = obj_inode_new(ex, vnode) !vnode
       in r
       | Error err ->
         let ex = deep_freeObj(ex, dentarr_obj)
         in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
       | Success inode ->
         let v_size' = vfs_inode_get_size vdir !vdir
         and v_mtime' = vfs_inode_get_mtime vdir !vdir
         and v_ctime' = vfs_inode_get_ctime vdir !vdir
         and (ex, time) = os_get_current_time(ex)
         and vdir = vfs_inode_set_size(vdir, new_v_size)
         and vdir = vfs_inode_set_mtime(vdir, time)
         and vdir = vfs_inode_set_ctime(vdir, time)
         and vdir = vfs_inode_inc_nlink vdir
         and (ex, r) = obj_inode_new(ex, vdir) !vdir
         in r
         | Error err ->
           let ex = deep_freeObj(ex, dentarr_obj)
           and ex = deep_freeObj(ex, inode)
           and vdir = vfs_inode_set_size(vdir, v_size')
           and vdir = vfs_inode_set_mtime(vdir, v_mtime')
           and vdir = vfs_inode_set_ctime(vdir, v_ctime')
           and vdir = vfs_inode_dec_nlink vdir
           in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
         | Success dir ->
           arrayobj_create3(ex, dentarr_obj, inode, dir)
           | Error ex ->
             let vdir = vfs_inode_set_size(vdir, v_size')
             and vdir = vfs_inode_set_mtime(vdir, v_mtime')
             and vdir = vfs_inode_set_ctime(vdir, v_ctime')
             and vdir = vfs_inode_dec_nlink vdir
             in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error eNoMem)
           | Success (ex, arr) ->
             let ((ex, ostore_st, arr), r) = ostore_write(ex, fs_st.mount_st, ostore_st, arr, ostoreWriteNone) !fs_st
             in r
             | Error err ->
               let vdir = vfs_inode_set_size(vdir, v_size')
               and vdir = vfs_inode_set_mtime(vdir, v_mtime')
               and vdir = vfs_inode_set_ctime(vdir, v_ctime')
               and ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
               and vdir = vfs_inode_dec_nlink vdir
               in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
             | Success () ->
               let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
               in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Success ())


fsop_rmdir : FsopUnlinkP -> RR FsopRR () ErrCode
fsop_rmdir #{ex, fs_st = fs_st {ostore_st}, vdir, name, vnode} =
-- invariant on fs_st
-- vdir has correspondence with the object coming out of the object store.
-- vdir.n_link > 0
-- name in or not in directory
-- vnode has a correspondence with the object coming out of the object store.
-- vnode.n_link > 0
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error eRoFs)
  else
   let is_empty = check_dir_empty #{mount_st = fs_st.mount_st, ostore_st, vdir = vnode} !vnode !fs_st !ostore_st
   in if not is_empty then
     (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error eNotEmpty)
   else
    let ((ex, ostore_st), r) = dentarr_read_and_del (ex, fs_st.mount_st, ostore_st, vdir, name) !fs_st !vdir
    in r
    | Error err ->
      (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
    | Success (new_v_size, dentarr_obj) ->
              -- assumption v_nlink > 0 for fsop_unlink
              let vnode = vfs_inode_set_nlink(vnode, 0)
              and (ex, r) = obj_inode_new(ex, vnode) !vnode
              in r
              | Error err ->
                let ex = deep_freeObj(ex, dentarr_obj)
                and vnode = vfs_inode_set_nlink(vnode, 2)
                in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
              | Success inode ->
                let v_size' = vfs_inode_get_size(vdir) !vdir
                and v_mtime' = vfs_inode_get_mtime(vdir) !vdir
                and v_ctime' = vfs_inode_get_ctime(vdir) !vdir
                and (ex, v_mtime) = os_get_current_time(ex)
                and (ex, v_ctime) = os_get_current_time(ex)
                and vdir = vfs_inode_set_size(vdir, new_v_size)
                and vdir = vfs_inode_set_mtime(vdir, v_mtime)
                and vdir = vfs_inode_set_ctime(vdir, v_ctime)
                and vdir = vfs_inode_dec_nlink(vdir)
                and (ex, r) = obj_inode_new(ex, vdir) !vdir
                in r
                | Error err ->
                   let ex = deep_freeObj(ex, dentarr_obj)
                   and ex = deep_freeObj(ex, inode)
                   and vdir = vfs_inode_set_size(vdir, v_size')
                   and vdir = vfs_inode_set_mtime(vdir, v_mtime')
                   and vdir = vfs_inode_set_ctime(vdir, v_ctime')
                   and vnode = vfs_inode_set_nlink(vnode, 2)
                   and vdir = vfs_inode_inc_nlink(vdir)
                   in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
                | Success dir ->
                  arrayobj_create3(ex, dentarr_obj, inode, dir)
                  | Error ex ->
                      let vdir = vfs_inode_set_size(vdir, v_size')
                      and vdir = vfs_inode_set_mtime(vdir, v_mtime')
                      and vdir = vfs_inode_set_ctime(vdir, v_ctime')
                      and vnode = vfs_inode_set_nlink(vnode, 2)
                      and vdir = vfs_inode_inc_nlink(vdir)
                      in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error eNoMem)
                  | Success (ex, arr) ->
                    let ((ex, ostore_st, arr), r) = ostore_write(ex, fs_st.mount_st, ostore_st, arr, ostoreWriteNone) !fs_st
                    in r
                    | Error err ->
                      _cogent_debug "fsop_rmdir: ostore_write : failed.\n";
                      let vdir = vfs_inode_set_size(vdir, v_size')
                      and vdir = vfs_inode_set_mtime(vdir, v_mtime')
                      and vdir = vfs_inode_set_ctime(vdir, v_ctime')
                      and ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
                      and vnode = vfs_inode_set_nlink(vnode, 2)
                      and vdir = vfs_inode_inc_nlink(vdir)
                      in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
                    | Success () ->
                      let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
                      in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Success ())

type FsState' = {
  fsop_st : FsopState,
  mount_st : MountState,
  ostore_st : OstoreState take (ubi_vol)
}
freeFsState2: (ExState, FsState' take(..)) -> ExState

type FsopLookupP = #{ex:ExState, fs_st:FsState, vdir:VfsInode, name:CString!}
type FsopLookupRR = #{ex:ExState, fs_st:FsState, vdir:VfsInode}
fsop_lookup: FsopLookupP -> RR FsopLookupRR VfsIno ErrCode
fsop_lookup #{ex, fs_st = fs_st {mount_st, ostore_st}, vdir, name} =
  if wordarray_length[U8] name > bilbyFsMaxNameLen + 1 then -- wordarray_length counts the \0
    (#{ex, fs_st = fs_st {mount_st, ostore_st}, vdir}, Error eNameTooLong)
  else
    let dir_inum = vfs_inode_get_ino vdir !vdir
    and oid = obj_id_dentarr_mk(dir_inum, name)
    and ((ex, ostore_st), r) = ostore_read(ex, mount_st, ostore_st, oid) !mount_st
    in r
    | Error err ->
      (#{ex, fs_st = fs_st {mount_st, ostore_st}, vdir}, Error err)
    | Success (obj {crc,magic,sqnum,offs,len,trans,otype,ounion}) ->
      let ex = freeObj(ex, obj)
      in extract_dentarr_from_union(ex, ounion)
      | Error ex -> -- medium invariant broken?
        (#{ex, fs_st = fs_st {mount_st, ostore_st}, vdir}, Error eRoFs)
      | Success (ex, dentarr) ->
        let fs_st = fs_st {mount_st, ostore_st}
        in array_fold[ObjDentry, (), CString, VfsIno]
             #{arr=dentarr.entries, f=find_name, acc=(), obsv=name} !dentarr
        | Iterate _ ->
          let ex = deep_freeObjDentarr(ex, dentarr)
          in (#{ex, fs_st, vdir}, Error eNoEnt) 
        | Break inum ->
          let ex = deep_freeObjDentarr(ex, dentarr)
          in (#{ex, fs_st, vdir}, Success inum)

find_name: ArrayFoldF ObjDentry () CString VfsIno
find_name #{elem=de, acc=_, obsv=name} =
  if wordarray_cmp (de.name, name) then
    Break (de.ino)
  else
    Iterate ()

type FsopFillSuperP = #{ex:ExState, fs_st:FsState', vsup:VfsMountInfo, is_silent:Bool, root:VfsInode}
type FsopFillSuperRR = #{ex:ExState, vsup:VfsMountInfo, root:VfsInode}
type FsopFillSuperE = #{err:ErrCode, fs_st:FsState'}
fsop_fill_super: FsopFillSuperP -> RR FsopFillSuperRR FsState FsopFillSuperE
fsop_fill_super #{ex, fs_st = fs_st {mount_st}, vsup, is_silent, root} =
  let ubi_num = wubi_vol_ubi_num mount_st.vol !mount_st
  and vol_id = wubi_vol_vol_id mount_st.vol !mount_st
  in wubi_open_volume #{ex, ubi_num, vol_id, mode=ubiReadWrite}
  | Error ex ->
    _cogent_debug "Could not Open UBI device" ;
    (#{ex, vsup, root}, Error #{err=eNoEnt, fs_st = fs_st {mount_st}}) 
  | Success (ex, ubi_vol) ->
    let s_magic = upcast bilbyFsMagic
    and s_blocksize = bilbyFsBlockSize
    and s_blocksize_bits = bilbyFsBlockShift
    and s_maxbytes = os_MAX_FILESIZE
    and vsup = vsup {s_magic, s_blocksize, s_blocksize_bits, s_maxbytes}
    and mount_st {super} = mount_st

    and nb_eb = wubi_vol_size mount_st.vol !mount_st
    and eb_size = wubi_vol_usable_leb_size mount_st.vol !mount_st
    and io_size = wubi_dev_min_io_size mount_st.dev !mount_st
    and nb_reserved_gc = bilbyFsDefaultNbReservedGc
    and nb_reserved_del = bilbyFsDefaultNbReservedDel

    and cur_eb = bilbyFsFirstLogEbNum
    and cur_offs:U32 = 0
    and next_sqnum:U64 = 0
    and last_inum:U32 = 0
    and super = super {nb_eb,eb_size,io_size,cur_eb,cur_offs,next_sqnum,last_inum,nb_reserved_gc,nb_reserved_del}

    and super_offs:U32 = 0
    and mount_st = mount_st {super_offs, super}
    and fs_st {ostore_st} = fs_st
    -- This is a workaround to the take inner field issue 
    in newFsState(ex)
    | Error (ex) ->
      let ex = wubi_close(ex, ubi_vol)
      in (#{ex, vsup, root}, Error #{err=eNoMem, fs_st = fs_st {mount_st, ostore_st}})
    | Success (ex, fs_st') ->
      let fs_st {fsop_st} = fs_st
      -- and ex = freeFsState2(ex, fs_st)
      and ostore_st = ostore_st {ubi_vol}
      and ((ex, mount_st, ostore_st), r) = ostore_mount(ex, mount_st, ostore_st)
      in r
      | Success () ->
        let ex = freeFsState2(ex, fs_st)
        and fs_st = fs_st' {fsop_st, mount_st, ostore_st}
        and root = vfs_inode_set_ino(root, bilbyFsRootIno)
        in (#{ex, vsup, root}, Success fs_st)
      | Error err ->
        if err == eNoData then
          let (#{ex, fs_st = fs_st', vnode = root}, r) = fsop_format_default #{ex, fs_st = fs_st' {mount_st, fsop_st, ostore_st}, vnode=root}
          in r
          | Error err ->
            let fs_st' {mount_st, fsop_st, ostore_st} = fs_st'
            and ostore_st {ubi_vol} = ostore_st
            and ex = wubi_close(ex, ubi_vol)
            and ex = freeFsState(ex, fs_st')
            and fs_st = fs_st {mount_st, fsop_st, ostore_st}
            in (#{ex, vsup, root}, Error #{err, fs_st})
          | Success () ->
            let ex = freeFsState2(ex, fs_st)
            and root = vfs_inode_set_ino(root, bilbyFsRootIno)
            in (#{ex, vsup, root}, Success fs_st')
        else
          let ostore_st {ubi_vol} = ostore_st
          and ex = wubi_close(ex, ubi_vol)
          and ex = freeFsState(ex, fs_st')
          and fs_st = fs_st {mount_st, fsop_st, ostore_st}
          in (#{ex, vsup, root}, Error #{err, fs_st}) 

type BilbyFsReaddirContext = {
  dentarr : ObjDentarr,
  cur_dentry : U32
}
newBilbyFsReaddirContext: ExState -> R (ExState, BilbyFsReaddirContext take(..)) ExState
freeBilbyFsReaddirContext: (ExState, BilbyFsReaddirContext take (..)) -> ExState

get_rdctx:(ExState, Option BilbyFsReaddirContext, VfsInode!) -> R (ExState, BilbyFsReaddirContext) (ErrCode, ExState)
get_rdctx(ex, opt_rdctx, vdir) =
  opt_rdctx
  | None ->
    newBilbyFsReaddirContext(ex)
    | Error ex -> Error (eNoMem, ex)
    | Success (ex, rdctx) ->
      array_create[ObjDentry] (ex, 1)
      | Error ex ->
        let ex = freeBilbyFsReaddirContext(ex, rdctx)
        in Error (eNoMem, ex)
      | Success (ex, entries) ->
        newObjDentarr ex
        | Error ex ->
          let ex = freeBilbyFsReaddirContext(ex, rdctx)
          and ex = array_free[ObjDentry] #{arr=entries, f=deep_freeObjDentry, ex}
          in Error (eNoMem, ex)
        | Success (ex, dentarr) ->
          let id:ObjId = obj_id_inode_mk (vfs_inode_get_ino vdir)
          and nb_dentry:U32 = 0
          and dentarr = dentarr {id, nb_dentry, entries}
          and rdctx = rdctx {dentarr,cur_dentry=0}
          in Success (ex, rdctx)
  | Some rdctx ->
    Success (ex, rdctx)

next_inode_id: ObjId -> ObjId
next_inode_id(oid) =
  let inum = inum_from_obj_id(oid)
  in if inum == word32Max then
    nilObjId
  else
    obj_id_inode_mk(inum + 1)

read_next_dentry: (ExState, MountState!, OstoreState, BilbyFsReaddirContext) -> RR (ExState, OstoreState, BilbyFsReaddirContext) Bool ErrCode
read_next_dentry(ex, mount_st, ostore_st, rdctx) =
  let cur_dentry = rdctx.cur_dentry !rdctx
  and len_dentarr = array_nb_elem[ObjDentry] rdctx.dentarr.entries !rdctx
  and did = rdctx.dentarr.id !rdctx -- FIXME only used in debug message below
  in if cur_dentry + 1 >= len_dentarr then
   -- We iterated through all dentries of rdctx.dentarr
   -- let's get the next one.
    _cogent_debug "readdir next_obj_id(" ; _cogent_debug_u64_hex did ; _cogent_debug ")\n" ;
    ostore_next_obj_id(mount_st, ostore_st, rdctx.dentarr.id) !ostore_st !rdctx
    | Error () -> ((ex, ostore_st, rdctx), Success True)
    | Success nxt ->
      let ((ex, ostore_st), r) = ostore_read(ex, mount_st, ostore_st, nxt)
      in r
      | Error err ->
        ((ex, ostore_st, rdctx), Error err)
      | Success (obj {crc,magic,sqnum,offs,len,trans,otype,ounion}) ->
        let ex = freeObj(ex, obj)
        in extract_dentarr_from_union(ex, ounion)
        | Error (ex) -> -- medium invariant broken?
          ((ex, ostore_st, rdctx), Error eRoFs) 
        | Success (ex, dentarr) ->
          let rdctx {dentarr = dentarr', cur_dentry} = rdctx
          and ex = deep_freeObjDentarr(ex, dentarr')
          and rdctx = rdctx {dentarr,cur_dentry=0}
          in ((ex, ostore_st, rdctx), Success False)
  else -- We simply get the next entry of rdctx.dentarr
    let rdctx {cur_dentry} = rdctx
    and rdctx = rdctx {cur_dentry = cur_dentry+1}
    in ((ex, ostore_st, rdctx), Success False)

dtype_to_vtype: U8 -> VfsType
dtype_to_vtype dtype =
 if dtype == bilbyFsITypeReg then vfs_type_reg
 else if dtype == bilbyFsITypeDir then vfs_type_dir
 else if dtype == bilbyFsITypeLnk then vfs_type_link
 else if dtype == bilbyFsITypeBlk then vfs_type_blk
 else if dtype == bilbyFsITypeChr then vfs_type_chr
 else if dtype == bilbyFsITypeFifo then vfs_type_fifo
 else vfs_type_sock

vmode_to_vtype: VfsMode -> VfsType
vmode_to_vtype vm = (vm .&. s_IFMT)

vtype_to_dtype: VfsType -> U8
vtype_to_dtype vt =
 if vt == vfs_type_reg then bilbyFsITypeReg
 else if vt == vfs_type_dir then bilbyFsITypeDir
 else if vt == vfs_type_link then bilbyFsITypeLnk
 else if vt == vfs_type_blk then bilbyFsITypeBlk
 else if vt == vfs_type_chr then bilbyFsITypeChr
 else if vt == vfs_type_fifo then bilbyFsITypeFifo
 else bilbyFsITypeSock

emit_dir: #{elem:ObjDentry!, acc:(VfsDirContext, Bool), obsv:()} -> (VfsDirContext, Bool)
emit_dir #{elem=dentry, acc=(vctx, _), obsv=()} =
  _cogent_debug "emit_dir " ;
  -- _cogent_debug dentry.name ;
  _cogent_debug "\n" ;
  vfs_dir_emit #{dirctx=vctx , name=dentry.name, ino=dentry.ino, ftype=dtype_to_vtype(dentry.dtype)}
  | Break #{dirctx=vctx} -> (vctx, True)
  | Iterate #{dirctx=vctx} -> (vctx, False)

type ReadDirLoopParams = (ExState, OstoreState, VfsDirContext, BilbyFsReaddirContext)
readdir_loop: #{acc:ReadDirLoopParams, obsv:MountState!, idx:U64} ->
    LRR ReadDirLoopParams (R Bool ErrCode)
readdir_loop #{acc=(ex, ostore_st, vctx, rdctx), obsv=mount_st, idx} =
  _cogent_debug "readdir_loop " ; _cogent_debug_u64_hex idx ; _cogent_debug "\n";
  let ((ex, ostore_st, rdctx), r) = read_next_dentry(ex, mount_st, ostore_st, rdctx)
  in r
  | Error err ->
    ((ex, ostore_st, vctx, rdctx), Break (Error err))
  | Success no_more_dentry ->
    if no_more_dentry then
      _cogent_debug "readdir no more entries" ;
      let vctx {pos} = vctx
      and vctx = vctx {pos=2}
      in ((ex, ostore_st, vctx, rdctx), Break (Success no_more_dentry))
    else
      let vctx {pos} = vctx
      and vctx = vctx {pos=pos+1}
      and _ = _cogent_debug "readdir_loop use "
      and _ = _cogent_debug_u32 rdctx.cur_dentry !rdctx
      and _ = _cogent_debug "\n"
      and (vctx, over) = array_use_value[ObjDentry, (VfsDirContext, Bool), ()]
                           #{arr=rdctx.dentarr.entries, idx=rdctx.cur_dentry, f=emit_dir, acc=(vctx, False), obsv=()} !rdctx
      in if over then
        _cogent_debug "readdir emit dir said over\n" ;
        ((ex, ostore_st, vctx, rdctx), Break (Success no_more_dentry))
      else -- We can keep going
        ((ex, ostore_st, vctx, rdctx), Iterate ())

type ReadDirParams = #{ex:ExState, fs_st:FsState, vctx:VfsDirContext, opt_rdctx: Option BilbyFsReaddirContext}
fsop_readdir: (ReadDirParams, VfsInode!) -> RR ReadDirParams () ErrCode
fsop_readdir (#{ex, fs_st, vctx, opt_rdctx}, vdir) =
  get_rdctx(ex, opt_rdctx, vdir)
  | Error (err, ex)  ->
     (#{ex, fs_st, vctx, opt_rdctx=None}, Error err)
  | Success (ex, rdctx) ->
    let fs_st {ostore_st} = fs_st
    and oid = rdctx.dentarr.id !rdctx
    and ((ex, ostore_st, vctx, rdctx), r) =
          seq64[ReadDirLoopParams, MountState, R Bool ErrCode]
            #{frm=oid, to=next_inode_id(obj_id_inode_mk(vfs_inode_get_ino vdir)),
              step=1, f=readdir_loop, acc=(ex, ostore_st, vctx, rdctx), obsv=fs_st.mount_st} !fs_st
    in r
    | Iterate () ->
      _cogent_assert False ;
      let fs_st = fs_st {ostore_st}
      in (#{ex, fs_st, vctx, opt_rdctx=Some rdctx}, Error eInval)
    | Break res ->
      res
      | Error err ->
        let fs_st = fs_st {ostore_st}
        in (#{ex, fs_st, vctx, opt_rdctx=Some rdctx}, Error err)
      | Success no_more ->
        let fs_st = fs_st {ostore_st}
        in (#{ex, fs_st, vctx, opt_rdctx=Some rdctx}, Success ())

fsop_dir_release: (ExState, Option BilbyFsReaddirContext) -> ExState
fsop_dir_release (ex, opt_rdctx) =
  opt_rdctx
  | None ->
  ex
  | Some (v {dentarr}) ->
    let ex = deep_freeObjDentarr(ex, dentarr)
    in freeBilbyFsReaddirContext(ex, v)

check_dir_empty: #{mount_st:MountState!, ostore_st:OstoreState!, vdir: VfsInode!} -> Bool
check_dir_empty #{mount_st, ostore_st, vdir} =
  let is_dir = vmode_is_dir (vfs_inode_get_mode (vdir))
  in if not is_dir then
    True
  else
    let id = obj_id_inode_mk(vfs_inode_get_ino (vdir))
    in ostore_next_obj_id(mount_st, ostore_st, id)
    | Error () -> True
    | Success nxt -> not (obj_id_is_dentarr nxt)

obj_dentarr_or_del_new: (ExState, Obj take (ounion), ObjDentarr) -> R (ExState, Obj) (ErrCode, ExState)
obj_dentarr_or_del_new(ex, odent, dent) =
  let len = array_nb_elem[ObjDentry] dent.entries !dent
  in if len > 0 then
    let len = bilbyFsObjHeaderSize + serialise_size_ObjDentarr dent !dent
    in Success (ex, odent {len, ounion=TObjDentarr dent, otype = bilbyFsObjTypeDentarr})
  else
    let odel = #{id=dent.id} !dent
    and len = bilbyFsObjHeaderSize + serialise_size_ObjDel odel !odel
    and ex = deep_freeObjDentarr(ex, dent)
    in Success (ex, odent {len, ounion=TObjDel odel, otype = bilbyFsObjTypeDel})

type FsopDoMoveHelperP = #{ex:ExState, mount_st:MountState!, ostore_st:OstoreState, old_dent_size: U32, new_dent_size: U32, new_o:Obj, old_o:Obj, old_vdir:VfsInode, old_vnode: VfsInode, new_vdir: VfsInode, opt_new_vnode: Option VfsInode} 
type FsopDoMoveHelperRR = #{ex:ExState, ostore_st:OstoreState, old_vdir:VfsInode, old_vnode: VfsInode, new_vdir: VfsInode, opt_new_vnode: Option VfsInode}
fsop_do_move_helper: FsopDoMoveHelperP -> RR FsopDoMoveHelperRR () ErrCode
fsop_do_move_helper #{ex, mount_st, ostore_st, old_dent_size, new_dent_size, new_o, old_o, old_vdir, old_vnode, new_vdir, opt_new_vnode} =
  _cogent_debug "fsop_do_move_helper\n" ;
  -- update old_vdir.v_size
  let old_dent_size' = serialise_size_Obj old_o !old_o
  and old_o = old_o {len=old_dent_size'}
  and old_vdir_size = vfs_inode_get_size old_vdir !old_vdir
  and old_vdir = vfs_inode_set_size (old_vdir, old_vdir_size - upcast old_dent_size + upcast old_dent_size')
  -- update new_vdir.v_size
  and new_dent_size' = serialise_size_Obj(new_o) !new_o
  and new_o = new_o {len=new_dent_size'}
  and new_vdir_size = vfs_inode_get_size new_vdir !new_vdir
  and new_vdir = vfs_inode_set_size (new_vdir, new_vdir_size - upcast new_dent_size + upcast new_dent_size')

  and (ex, r) = obj_inode_new (ex, old_vnode) !old_vnode
  in r
  | Error err ->
    let ex = deep_freeObj (ex, old_o)
    and ex = deep_freeObj (ex, new_o)
    in (#{ex, ostore_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error err)
  | Success obj_old_vnode ->
    let (ex, r) = obj_inode_new(ex, old_vdir) !old_vdir
    in r
    | Error err ->
      let ex = deep_freeObj (ex, old_o)
      and ex = deep_freeObj (ex, new_o)
      and ex = deep_freeObj (ex, obj_old_vnode)
      in (#{ex, ostore_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error err)
    | Success obj_old_vdir ->
      let (ex, r) = obj_inode_new (ex, new_vdir) !new_vdir
      in r
      | Error err ->
        let ex = deep_freeObj (ex, old_o)
        and ex = deep_freeObj (ex, new_o)
        and ex = deep_freeObj (ex, obj_old_vnode)
        and ex = deep_freeObj (ex, obj_old_vdir)
        in (#{ex, ostore_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error err)
      | Success obj_new_vdir ->
        -- case opt_new_vnode
        opt_new_vnode
        | None -> 
            let opt_new_vnode:Option VfsInode = None
            in arrayobj_create5(ex, old_o, obj_old_vdir, obj_old_vnode, new_o, obj_new_vdir)
            | Error ex ->
              (#{ex, ostore_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error eNoMem)
            | Success (ex, arr) ->
              let ((ex, ostore_st, arr), r) = ostore_write(ex, mount_st, ostore_st, arr, ostoreWriteNone)
              in r
              | Error err ->
                let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
                in (#{ex, ostore_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error err) 
              | Success () ->
                let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
                in (#{ex, ostore_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Success ())
        | Some new_vnode ->
          let (ex, r) = obj_inode_new(ex, new_vnode) !new_vnode
          in r
          | Error err ->
            let ex = deep_freeObj(ex, old_o)
            and ex = deep_freeObj(ex, new_o)
            and ex = deep_freeObj(ex, obj_old_vnode)
            and ex = deep_freeObj(ex, obj_old_vdir)
            and ex = deep_freeObj(ex, obj_new_vdir)
            in (#{ex, ostore_st, old_vdir, old_vnode, new_vdir, opt_new_vnode = Some new_vnode}, Error err) 
          | Success obj_new_vnode ->
            let opt_new_vnode:Option VfsInode = Some new_vnode
            in arrayobj_create6(ex, old_o, obj_old_vdir, obj_old_vnode, new_o, obj_new_vdir, obj_new_vnode)
            | Error ex ->
              (#{ex, ostore_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error eNoMem) 
            | Success (ex, arr) ->
              let ((ex, ostore_st, arr), r) = ostore_write(ex, mount_st, ostore_st, arr, ostoreWriteNone)
              in r
              | Error err ->
                let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
                in (#{ex, ostore_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error err)
              | Success () ->
                let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
                in (#{ex, ostore_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Success ())

move_read_or_create_dentarrs: (ExState, MountState!, OstoreState, VfsInode!, VfsInode!, CString!, CString!) -> RR (ExState, OstoreState) (Obj take (ounion), Obj take (ounion), ObjDentarr, ObjDentarr, U32, U32) ErrCode
move_read_or_create_dentarrs(ex, mount_st, ostore_st, old_vdir, new_vdir, old_name, new_name) =
  _cogent_debug "move_read_or_create_dentarrs\n" ;
  let oldoid = obj_id_dentarr_mk (vfs_inode_get_ino old_vdir, old_name)
  and newoid = obj_id_dentarr_mk (vfs_inode_get_ino new_vdir, new_name)
  and ((ex, ostore_st), r) = read_or_create_dentarr(ex, mount_st, ostore_st, oldoid)
  in r
  | Error err ->
    ((ex, ostore_st), Error err)
  | Success (old_o, old_dent, created) ->
     -- if we created the dentarr, the dentarr did not exist then we substract 0
    let old_dent_size = if created then 0 else old_o.len !old_o
    and ((ex, ostore_st), r) = read_or_create_dentarr(ex, mount_st, ostore_st, newoid)
    in r
    | Error err ->
      let old_o = old_o {ounion = TObjDentarr old_dent}
      and ex = deep_freeObj(ex, old_o)
      in ((ex, ostore_st), Error err) 
    | Success (new_o, new_dent, created) ->
      -- if we created the dentarr, the dentarr did not exist then we substract 0
      let new_dent_size = if created then 0 else new_o.len !new_o
      in ((ex, ostore_st), Success (old_o, new_o, old_dent, new_dent, old_dent_size, new_dent_size))

type FsopDoMoveDelP = #{ex:ExState, fs_st:FsState, old_vdir:VfsInode, old_name:(WordArray U8)!, old_vnode:VfsInode, new_vdir: VfsInode, new_name: (WordArray U8)!, new_vnode: VfsInode}
type FsopDoMoveDelRR = #{ex:ExState, fs_st:FsState, old_vdir:VfsInode, old_vnode:VfsInode, new_vdir: VfsInode, opt_new_vnode: Option VfsInode}
fsop_do_move_del: FsopDoMoveDelP -> RR FsopDoMoveDelRR () ErrCode
-- we need to delete the new_vnode
fsop_do_move_del #{ex, fs_st = fs_st {ostore_st}, old_vdir, old_name, old_vnode, new_vdir, new_name, new_vnode} = 
  _cogent_debug "fsop_do_move_del\n" ;
  let opt_new_vnode:Option VfsInode = Some new_vnode
  and ((ex, ostore_st), r) = move_read_or_create_dentarrs(ex, fs_st.mount_st, ostore_st, old_vdir, new_vdir, old_name, new_name) !fs_st !old_vdir !new_vdir
  in r
  | Error err ->
    (#{ex, fs_st = fs_st {ostore_st}, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error err)
  | Success (old_o, new_o, old_dent, new_dent, old_dent_size, new_dent_size) ->
    let fs_st = fs_st {ostore_st}
    and (ex, old_dent) = dentarr_del_dentry(ex, old_dent, old_name)
    and (ex, new_dent) = dentarr_del_dentry(ex, new_dent, new_name)
    and dtype = vtype_to_dtype (vmode_to_vtype (vfs_inode_get_mode old_vnode)) !old_vnode
    and ((ex, new_dent), r) = dentarr_add_dentry(ex, new_dent, old_vnode, new_name, dtype) !old_vnode
    in r
    | Error err ->
      let old_o = old_o {ounion = TObjDentarr old_dent}
      and ex = deep_freeObj(ex, old_o)
      and new_o = new_o {ounion = TObjDentarr new_dent}
      and ex = deep_freeObj(ex, new_o)
      in (#{ex, fs_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error err)
    | Success () ->
      obj_dentarr_or_del_new(ex, old_o, old_dent)
      | Error (err, ex) ->
        let new_o = new_o {ounion = TObjDentarr new_dent}
        and ex = deep_freeObj(ex, new_o)
        in (#{ex, fs_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error err) 
      | Success (ex, old_o) ->
        let new_o = new_o {ounion = TObjDentarr new_dent}
        and fs_st {ostore_st} = fs_st
        and (#{ex, ostore_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, r) = fsop_do_move_helper #{ex, mount_st = fs_st.mount_st, ostore_st, old_dent_size, new_dent_size, new_o, old_o, old_vdir, old_vnode, new_vdir, opt_new_vnode} !fs_st
        in r
        | Error err ->
          (#{ex, fs_st = fs_st {ostore_st}, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error err) 
        | Success () ->
          (#{ex, fs_st = fs_st {ostore_st}, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Success ())

type FsopDoMoveP = #{ex:ExState, fs_st:FsState, old_vdir:VfsInode, old_name:(WordArray U8)!, old_vnode:VfsInode, new_vdir: VfsInode, new_name: (WordArray U8)!}
type FsopDoMoveRR = #{ex:ExState, fs_st:FsState, old_vdir:VfsInode, old_vnode:VfsInode, new_vdir: VfsInode}
fsop_do_move: FsopDoMoveP -> RR FsopDoMoveRR () ErrCode
fsop_do_move #{ex, fs_st = fs_st {ostore_st}, old_vdir, old_name, old_vnode, new_vdir, new_name} =
  _cogent_debug "fsop_do_move\n" ;
  let ((ex, ostore_st), r) = move_read_or_create_dentarrs(ex, fs_st.mount_st, ostore_st, old_vdir, new_vdir, old_name, new_name) !fs_st !old_vdir !new_vdir
  in r
  | Error err ->
    (#{ex, fs_st = fs_st {ostore_st}, old_vdir, old_vnode, new_vdir}, Error err)
  | Success (old_o, new_o, old_dent, new_dent, old_dent_size, new_dent_size) ->
    let fs_st = fs_st {ostore_st}
    and (ex, old_dent) = dentarr_del_dentry(ex, old_dent, old_name)
    and dtype = vtype_to_dtype (vmode_to_vtype (vfs_inode_get_mode old_vnode)) !old_vnode
    and ((ex, new_dent), r) = dentarr_add_dentry(ex, new_dent, old_vnode, new_name, dtype) !old_vnode
    in r
    | Error err ->
      let old_o = old_o {ounion = TObjDentarr old_dent}
      and ex = deep_freeObj(ex, old_o)
      and new_o = new_o {ounion = TObjDentarr new_dent}
      and ex = deep_freeObj(ex, new_o)
      in (#{ex, fs_st, old_vdir, old_vnode, new_vdir}, Error err) 
    | Success () ->
      obj_dentarr_or_del_new(ex, old_o, old_dent)
      | Error (err, ex) ->
        let new_o = new_o {ounion = TObjDentarr new_dent}
        and ex = deep_freeObj(ex, new_o)
        in (#{ex, fs_st, old_vdir, old_vnode, new_vdir}, Error err) 
      | Success (ex, old_o) ->
        let new_o = new_o {ounion = TObjDentarr new_dent}
        and fs_st {ostore_st} = fs_st
        and opt_new_vnode:Option VfsInode = None
        and (#{ex, ostore_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, r) = fsop_do_move_helper #{ex, mount_st = fs_st.mount_st, ostore_st, old_dent_size, new_dent_size, new_o, old_o, old_vdir, old_vnode, new_vdir, opt_new_vnode} !fs_st
        in r
        | Error err ->
          let ex = free_opt_VfsInode (ex, opt_new_vnode)
          in (#{ex, fs_st = fs_st {ostore_st}, old_vdir, old_vnode, new_vdir}, Error err)
        | Success () ->
          let ex = free_opt_VfsInode (ex, opt_new_vnode)
          in (#{ex, fs_st = fs_st {ostore_st}, old_vdir, old_vnode, new_vdir}, Success ())

newVfsInode: ExState -> R (ExState, VfsInode take (..)) ExState
freeVfsInode: (ExState, VfsInode take (..)) -> ExState

deep_freeVfsInode: (ExState, VfsInode) -> ExState
deep_freeVfsInode(ex, v) = freeVfsInode(ex, v)

-- when we call this function we know that opt_vnode = None
-- see fsop_do_move
free_opt_VfsInode: (ExState, Option VfsInode) -> ExState
free_opt_VfsInode(ex, opt_vnode) =
 opt_vnode
 | None -> ex
 | Some v -> deep_freeVfsInode(ex, v)

opt_vnode_set_nlink: (Option VfsInode, U32) -> Option VfsInode
opt_vnode_set_nlink (opt, nlink) =
 opt
 | None -> None
 | Some v -> Some (vfs_inode_set_nlink (v, nlink))

-- Move is moving a file/dir from one dir to an other.
type FsopMoveP = #{ex:ExState, fs_st:FsState, old_vdir:VfsInode, old_name:(WordArray U8)!, old_vnode:VfsInode, new_vdir: VfsInode, new_name: (WordArray U8)!, opt_new_vnode: Option VfsInode}
type FsopMoveRR = #{ex:ExState, fs_st:FsState, old_vdir:VfsInode, old_vnode:VfsInode, new_vdir: VfsInode, opt_new_vnode: Option VfsInode}
fsop_move: FsopMoveP -> RR FsopMoveRR () ErrCode
fsop_move #{ex, fs_st = fs_st {ostore_st}, old_vdir, old_name, old_vnode, new_vdir, new_name, opt_new_vnode} =
  _cogent_debug "fsop_move\n" ;
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st = fs_st {ostore_st}, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error eRoFs) 
  else
    let old_is_dir = vmode_is_dir (vfs_inode_get_mode old_vnode) !old_vnode
    and new_vdir_nlink = (vfs_inode_get_nlink new_vdir) !new_vdir
    and old_vnode_nlink = (vfs_inode_get_nlink old_vnode) !old_vnode
    and old_vnode_ctime = (vfs_inode_get_ctime old_vnode) !old_vnode
    and old_vdir_mtime = (vfs_inode_get_mtime old_vdir) !old_vdir
    and old_vdir_ctime = (vfs_inode_get_ctime old_vdir) !old_vdir
    and old_vdir_size = (vfs_inode_get_size old_vdir) !old_vdir
    and new_vdir_size = (vfs_inode_get_size new_vdir) !new_vdir
    in opt_new_vnode
    | Some new_vnode ->
      let new_is_dir = vmode_is_dir (vfs_inode_get_mode new_vnode) !new_vnode
      and is_empty = check_dir_empty #{mount_st = fs_st.mount_st, ostore_st, vdir=new_vnode} !fs_st !ostore_st !new_vnode
      in if not is_empty then
        let fs_st = fs_st {ostore_st}
        and opt_new_vnode:Option VfsInode = Some new_vnode
        in (#{ex, fs_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error eNotEmpty) 
      else
        let fs_st = fs_st {ostore_st}
        -- clear_nlink new_vnode
        and new_vnode_nlink = vfs_inode_get_nlink new_vnode !new_vnode
        and new_vnode = vfs_inode_set_nlink(new_vnode, if new_is_dir then 0 else new_vnode_nlink - 1)
        -- new_vdir decrement nlink
        and new_vdir = vfs_inode_set_nlink(new_vdir, if new_is_dir then new_vdir_nlink - 1 else new_vdir_nlink)
        -- if old_is_dir then drop_nlink old_vnode
        and old_vnode = vfs_inode_set_nlink(old_vnode, if old_is_dir then old_vnode_nlink - 1 else old_vnode_nlink)
        -- if old_is_dir then inc_nlink new_vdir
        and new_vdir = vfs_inode_set_nlink(new_vdir, if old_is_dir then new_vdir_nlink + 1 else new_vdir_nlink)
        -- update ctime, mtime ...
        and (ex, time) = os_get_current_time ex
        and old_vnode = vfs_inode_set_ctime(old_vnode,time)
        and old_vdir = vfs_inode_set_mtime(old_vdir, time)
        and old_vdir = vfs_inode_set_ctime(old_vdir, time)
        and (#{ex, fs_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, r) = fsop_do_move_del #{ex, fs_st, old_vdir, old_name, old_vnode, new_vdir, new_name, new_vnode}
        in r
        | Error err ->
          -- rolling back changes
          let opt_new_vnode = opt_vnode_set_nlink (opt_new_vnode, new_vnode_nlink)
          and old_vnode = vfs_inode_set_nlink(old_vnode,  old_vnode_nlink)
          and old_vnode = vfs_inode_set_ctime(old_vnode, old_vnode_ctime)
          and new_vdir = vfs_inode_set_nlink(new_vdir, new_vdir_nlink)
          and new_vdir = vfs_inode_set_size(new_vdir, new_vdir_size)
          and old_vdir = vfs_inode_set_mtime(old_vdir, old_vdir_mtime)
          and old_vdir = vfs_inode_set_ctime(old_vdir, old_vdir_ctime)
          and old_vdir = vfs_inode_set_size(old_vdir, old_vdir_size)
          in (#{ex, fs_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error err) 
        | Success () ->
          (#{ex, fs_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Success ())
    | None ->
      let fs_st = fs_st {ostore_st}
      -- if old_is_dir then drop_nlink old_vnode
      and old_vnode = vfs_inode_set_nlink(old_vnode, if old_is_dir then old_vnode_nlink - 1 else old_vnode_nlink)
      -- if old_is_dir then inc_nlink new_vdir
      and new_vdir = vfs_inode_set_nlink(new_vdir, if old_is_dir then new_vdir_nlink + 1 else new_vdir_nlink)
      -- update times
      and (ex, time) = os_get_current_time ex
      and old_vnode = vfs_inode_set_ctime(old_vnode, time)
      and old_vdir = vfs_inode_set_mtime(old_vdir, time)
      and old_vdir = vfs_inode_set_ctime(old_vdir, time)
      and (#{ex, fs_st, old_vdir, old_vnode, new_vdir}, r) = fsop_do_move #{ex, fs_st, old_vdir, old_name, old_vnode, new_vdir, new_name}
      in r
      | Error err ->
        -- rolling back changes
        let old_vnode = vfs_inode_set_nlink(old_vnode,  old_vnode_nlink)
        and old_vnode = vfs_inode_set_ctime(old_vnode, old_vnode_ctime)
        and new_vdir = vfs_inode_set_nlink(new_vdir, new_vdir_nlink)
        and new_vdir = vfs_inode_set_size(new_vdir, new_vdir_size)
        and old_vdir = vfs_inode_set_mtime(old_vdir, old_vdir_mtime)
        and old_vdir = vfs_inode_set_ctime(old_vdir, old_vdir_ctime)
        and old_vdir = vfs_inode_set_size(old_vdir, old_vdir_size)
        and opt_new_vnode:Option VfsInode = None
        in (#{ex, fs_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Error err) 
      | Success () ->
        let opt_new_vnode:Option VfsInode = None
        in (#{ex, fs_st, old_vdir, old_vnode, new_vdir, opt_new_vnode}, Success ())

type FsopDoRenameHelper1P = #{ex:ExState, mount_st:MountState!, ostore_st:OstoreState, dent_size: U32, obj:Obj, vdir:VfsInode, old_vnode: VfsInode, opt_new_vnode: Option VfsInode} 
type FsopDoRenameHelper1R = #{ex:ExState, ostore_st:OstoreState, vdir:VfsInode, old_vnode: VfsInode, opt_new_vnode: Option VfsInode}
fsop_do_rename_helper1: FsopDoRenameHelper1P -> RR FsopDoRenameHelper1R () ErrCode
fsop_do_rename_helper1 #{ex, mount_st, ostore_st, dent_size, obj, vdir, old_vnode, opt_new_vnode} =
-- old and new are stored in the same dentarr
  _cogent_debug "fsop_do_rename_helper1\n" ;
  -- update old_vdir.v_size
  let dent_size' = serialise_size_Obj obj !obj
  and obj = obj {len=dent_size'}
  and vdir_size = vfs_inode_get_size vdir !vdir
  and vdir = vfs_inode_set_size (vdir, vdir_size - upcast dent_size + upcast dent_size') 

  and (ex, r) = obj_inode_new (ex, old_vnode) !old_vnode
  in r
  | Error err ->
    let ex = deep_freeObj (ex, obj)
    in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error err) 
  | Success obj_old_vnode ->
    let (ex, r) = obj_inode_new (ex, vdir) !vdir
    in r
    | Error err ->
      let ex = deep_freeObj (ex, obj)
      and ex = deep_freeObj (ex, obj_old_vnode)
      in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error err) 
    | Success obj_vdir ->
      -- case opt_new_vnode
      opt_new_vnode
      | None ->
          let opt_new_vnode:Option VfsInode = None
          in arrayobj_create3(ex, obj, obj_vdir, obj_old_vnode)
          | Error ex ->
            (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error eNoMem) 
          | Success (ex, arr) ->
            let ((ex, ostore_st, arr), r) = ostore_write(ex, mount_st, ostore_st, arr, ostoreWriteNone)
            in r
            | Error err ->
              let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
              in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error err) 
            | Success () ->
              let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
              in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Success ())
      | Some new_vnode ->
        let (ex, r) = obj_inode_new(ex, new_vnode) !new_vnode
        in r
        | Error err ->
          let ex = deep_freeObj(ex, obj)
          and ex = deep_freeObj(ex, obj_vdir)
          and ex = deep_freeObj(ex, obj_old_vnode)
          and opt_new_vnode:Option VfsInode = Some new_vnode
          in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error err)
        | Success obj_new_vnode ->
          let opt_new_vnode:Option VfsInode = Some new_vnode
          in arrayobj_create4(ex, obj, obj_vdir, obj_old_vnode, obj_new_vnode)
          | Error ex ->
            (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error eNoMem)
          | Success (ex, arr) ->
            let ((ex, ostore_st, arr), r) = ostore_write(ex, mount_st, ostore_st, arr, ostoreWriteNone)
            in r
            | Error err ->
              let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
              in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error err) 
            | Success () ->
              let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
              in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Success ())

type FsopDoRenameHelperP = #{ex:ExState, mount_st:MountState!, ostore_st:OstoreState, old_dent_size: U32, new_dent_size: U32, new_o:Obj, old_o:Obj, vdir:VfsInode, old_vnode: VfsInode, opt_new_vnode: Option VfsInode}
type FsopDoRenameHelperRR = #{ex:ExState, ostore_st:OstoreState, vdir:VfsInode, old_vnode: VfsInode, opt_new_vnode: Option VfsInode}
fsop_do_rename_helper: FsopDoRenameHelperP -> RR FsopDoRenameHelperRR () ErrCode
fsop_do_rename_helper #{ex, mount_st, ostore_st, old_dent_size, new_dent_size, new_o, old_o, vdir, old_vnode, opt_new_vnode} =
-- old and new are stored in two different dentarr
  _cogent_debug "fsop_do_rename_helper\n" ;
  -- update old_vdir.v_size
  let old_dent_size' = serialise_size_Obj old_o !old_o
  and old_o = old_o {len=old_dent_size'}
  and vdir_size = vfs_inode_get_size vdir !vdir
  and vdir = vfs_inode_set_size (vdir, vdir_size - upcast old_dent_size + upcast old_dent_size')
  -- update vdir.v_size with new_o
  and new_dent_size' = serialise_size_Obj new_o !new_o
  and new_o = new_o {len=new_dent_size'}
  and vdir_size = vfs_inode_get_size vdir !vdir
  and vdir = vfs_inode_set_size (vdir, vdir_size - upcast new_dent_size + upcast new_dent_size')

  and (ex, r) = obj_inode_new(ex, old_vnode) !old_vnode
  in r
  | Error err ->
    let ex = deep_freeObj(ex, old_o)
    and ex = deep_freeObj(ex, new_o)
    in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error err)
  | Success obj_old_vnode ->
    let (ex, r) = obj_inode_new(ex, vdir) !vdir
    in r
    | Error err ->
      let ex = deep_freeObj(ex, old_o)
      and ex = deep_freeObj(ex, new_o)
      and ex = deep_freeObj(ex, obj_old_vnode)
      in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error err)
    | Success obj_vdir ->
      -- case opt_new_vnode
      opt_new_vnode
      | None ->
          let opt_new_vnode:Option VfsInode = None
          in arrayobj_create4(ex, old_o, obj_vdir, obj_old_vnode, new_o)
          | Error ex ->
            (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error eNoMem)
          | Success (ex, arr) ->
            let ((ex, ostore_st, arr), r) = ostore_write(ex, mount_st, ostore_st, arr, ostoreWriteNone)
            in r
            | Error err ->
              let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
              in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error err) 
            | Success () ->
              let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
              in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Success ())
      | Some new_vnode ->
        let (ex, r) = obj_inode_new(ex, new_vnode) !new_vnode
        in r
        | Error err ->
          let ex = deep_freeObj(ex, old_o)
          and ex = deep_freeObj(ex, new_o)
          and ex = deep_freeObj(ex, obj_old_vnode)
          and ex = deep_freeObj(ex, obj_vdir)
          and opt_new_vnode:Option VfsInode = Some new_vnode
          in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error err) 
        | Success obj_new_vnode ->
          let opt_new_vnode:Option VfsInode = Some new_vnode
          in arrayobj_create5(ex, old_o, obj_vdir, obj_old_vnode, new_o, obj_new_vnode)
          | Error ex ->
            (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error eNoMem)
          | Success (ex, arr) ->
            let ((ex, ostore_st, arr), r) = ostore_write(ex, mount_st, ostore_st, arr, ostoreWriteNone)
            in r
            | Error err ->
              let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
              in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Error err) 
            | Success () ->
              let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
              in (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, Success ())

rename_read_or_create_dentarrs: (ExState, MountState!, OstoreState, ObjId, ObjId) -> RR (ExState, OstoreState) (Obj take (ounion), Obj take (ounion), ObjDentarr, ObjDentarr, U32, U32) ErrCode
rename_read_or_create_dentarrs(ex, mount_st, ostore_st, oldoid, newoid) =
  _cogent_debug "rename_read_or_create_dentarrs\n" ;
-- we know that oldoid and newoid have to be different.
  let ((ex, ostore_st), r) = read_or_create_dentarr(ex, mount_st, ostore_st, oldoid)
  in r
  | Error err -> ((ex, ostore_st), Error err) 
  | Success (old_o, old_dent, created) ->
    -- if we created the dentarr, the dentarr did not exist then we substract 0
    let old_dent_size = if created then 0 else old_o.len !old_o
    and ((ex, ostore_st), r) = read_or_create_dentarr(ex, mount_st, ostore_st, newoid)
    in r
    | Error err ->
      let old_o = old_o {ounion = TObjDentarr old_dent}
      and ex = deep_freeObj(ex, old_o)
      in ((ex, ostore_st), Error err)
    | Success (new_o, new_dent, created) ->
      -- if we created the dentarr, the dentarr did not exist then we substract 0
      let new_dent_size = if created then 0 else new_o.len !new_o
      in ((ex, ostore_st), Success (old_o, new_o, old_dent, new_dent, old_dent_size, new_dent_size))

type FsopDoRenameP = #{ex:ExState, fs_st:FsState, vdir:VfsInode, old_name:(WordArray U8)!, old_vnode:VfsInode, new_name: (WordArray U8)!}
type FsopDoRenameRR = #{ex:ExState, fs_st:FsState, vdir:VfsInode, old_vnode:VfsInode}
fsop_do_rename: FsopDoRenameP -> RR FsopDoRenameRR () ErrCode
fsop_do_rename #{ex, fs_st, vdir, old_name, old_vnode, new_name} =
  _cogent_debug "fsop_do_rename\n" ;
  let oldoid = obj_id_dentarr_mk (vfs_inode_get_ino vdir, old_name) !vdir
  and newoid = obj_id_dentarr_mk (vfs_inode_get_ino vdir, new_name) !vdir
  and fs_st {ostore_st} = fs_st
  in if oldoid == newoid then
    let ((ex, ostore_st), r) = read_or_create_dentarr(ex, fs_st.mount_st, ostore_st, oldoid) !fs_st
    in r
    | Error err ->
      (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode}, Error err) 
    | Success (obj, dentarr, created) ->
      let dent_size = if created then 0 else obj.len !obj
      and fs_st = fs_st {ostore_st}
      and (ex, dentarr) = dentarr_del_dentry(ex, dentarr, old_name)
      and dtype = vtype_to_dtype (vmode_to_vtype (vfs_inode_get_mode old_vnode)) !old_vnode
      and ((ex, dentarr), r) = dentarr_add_dentry(ex, dentarr, old_vnode, new_name, dtype) !old_vnode
      in r
      | Error err ->
        let obj = obj {ounion = TObjDentarr dentarr}
        and ex = deep_freeObj(ex, obj)
        in (#{ex, fs_st, vdir, old_vnode}, Error err)
      | Success () ->
        obj_dentarr_or_del_new(ex, obj, dentarr)
        | Error (err, ex) ->
          (#{ex, fs_st, vdir, old_vnode}, Error err) 
        | Success (ex, obj) ->
          let fs_st {ostore_st} = fs_st
          and opt_new_vnode:Option VfsInode = None
          and (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, r) = fsop_do_rename_helper1 #{ex, mount_st = fs_st.mount_st, ostore_st, dent_size, obj, vdir, old_vnode, opt_new_vnode} !fs_st
          in r
          | Error err ->
            let ex = free_opt_VfsInode (ex, opt_new_vnode)
            in (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode}, Error err)
          | Success () -> 
            let ex = free_opt_VfsInode (ex, opt_new_vnode)
            in (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode}, Success ())
  else
    let ((ex, ostore_st), r) = rename_read_or_create_dentarrs(ex, fs_st.mount_st, ostore_st, oldoid, newoid) !fs_st
    in r
    | Error err ->
      (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode}, Error err) 
    | Success (old_o, new_o, old_dent, new_dent, old_dent_size, new_dent_size) ->
      let fs_st = fs_st {ostore_st}
      and (ex, old_dent) = dentarr_del_dentry(ex, old_dent, old_name)
--  cannot be a new_name in dentarr otherwise, we would have a new_vnode
--  and (ex, new_dent) = dentarr_del_dentry(ex, new_dent, new_name)
      and dtype = vtype_to_dtype (vmode_to_vtype (vfs_inode_get_mode old_vnode)) !old_vnode
      and ((ex, new_dent), r) = dentarr_add_dentry(ex, new_dent, old_vnode, new_name, dtype) !old_vnode
      in r
      | Error err ->
        let old_o = old_o {ounion = TObjDentarr old_dent}
        and ex = deep_freeObj(ex, old_o)
        and new_o = new_o {ounion = TObjDentarr new_dent}
        and ex = deep_freeObj(ex, new_o)
        in (#{ex, fs_st, vdir, old_vnode}, Error err) 
      | Success () ->
        obj_dentarr_or_del_new(ex, old_o, old_dent)
        | Error (err, ex) ->
          let new_o = new_o {ounion = TObjDentarr new_dent}
          and ex = deep_freeObj(ex, new_o)
          in (#{ex, fs_st, vdir, old_vnode}, Error err) 
        | Success (ex, old_o) ->
          let new_o = new_o {ounion = TObjDentarr new_dent}
          and fs_st {ostore_st} = fs_st
          and (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, r) = fsop_do_rename_helper #{ex, mount_st = fs_st.mount_st, ostore_st, old_dent_size, new_dent_size, new_o, old_o, vdir, old_vnode, opt_new_vnode = None} !fs_st
          in r
          | Error err ->
            let ex = free_opt_VfsInode(ex, opt_new_vnode)
            in (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode}, Error err) 
          | Success () ->
            let ex = free_opt_VfsInode(ex, opt_new_vnode)
            in (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode}, Success ())

type FsopDoRenameDelP = #{ex:ExState, fs_st:FsState, vdir:VfsInode, old_name:(WordArray U8)!, old_vnode:VfsInode, new_name: (WordArray U8)!, new_vnode: VfsInode}
type FsopDoRenameDelRR = #{ex:ExState, fs_st:FsState, vdir:VfsInode, old_vnode:VfsInode, opt_new_vnode: Option VfsInode}
fsop_do_rename_del: FsopDoRenameDelP -> RR FsopDoRenameDelRR () ErrCode
fsop_do_rename_del #{ex, fs_st, vdir, old_name, old_vnode, new_name, new_vnode} =
  _cogent_debug "fsop_do_rename_del\n" ;
  let oldoid = obj_id_dentarr_mk (vfs_inode_get_ino vdir, old_name) !vdir
  and newoid = obj_id_dentarr_mk (vfs_inode_get_ino vdir, new_name) !vdir
  and fs_st {ostore_st} = fs_st
  in if oldoid == newoid then
    let ((ex, ostore_st), r) = read_or_create_dentarr(ex, fs_st.mount_st, ostore_st, oldoid) !fs_st
    in r
    | Error err ->
      (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode, opt_new_vnode = Some new_vnode}, Error err) 
    | Success (obj, dentarr, created) ->
      let dent_size = if created then 0 else obj.len !obj
      and fs_st = fs_st {ostore_st}
      and (ex, dentarr) = dentarr_del_dentry(ex, dentarr, new_name)
      and (ex, dentarr) = dentarr_del_dentry(ex, dentarr, old_name)
      and dtype = vtype_to_dtype (vmode_to_vtype (vfs_inode_get_mode old_vnode)) !old_vnode
      and ((ex, dentarr), r) = dentarr_add_dentry(ex, dentarr, old_vnode, new_name, dtype) !old_vnode
      in r
      | Error err ->
        let obj = obj {ounion = TObjDentarr dentarr}
        and ex = deep_freeObj(ex, obj)
        in (#{ex, fs_st, vdir, old_vnode, opt_new_vnode = Some new_vnode}, Error err) 
      | Success () ->
        obj_dentarr_or_del_new(ex, obj, dentarr)
        | Error (err, ex) ->
          (#{ex, fs_st, vdir, old_vnode, opt_new_vnode = Some new_vnode}, Error err) 
        | Success (ex, obj) ->
          let fs_st {ostore_st} = fs_st
          and (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, r) = fsop_do_rename_helper1 #{ex, mount_st = fs_st.mount_st, ostore_st, dent_size, obj, vdir, old_vnode, opt_new_vnode = Some new_vnode} !fs_st
          in r
          | Error err ->
            (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode, opt_new_vnode}, Error err) 
          | Success () ->
            (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode, opt_new_vnode}, Success ())
  else
    let ((ex, ostore_st), r) = rename_read_or_create_dentarrs(ex, fs_st.mount_st, ostore_st, oldoid, newoid) !fs_st
    in r
    | Error err ->
      (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode, opt_new_vnode = Some new_vnode}, Error err) 
    | Success (old_o, new_o, old_dent, new_dent, old_dent_size, new_dent_size) ->
      let fs_st = fs_st {ostore_st}
      and (ex, old_dent) = dentarr_del_dentry(ex, old_dent, old_name)
      and (ex, new_dent) = dentarr_del_dentry(ex, new_dent, new_name)
      and dtype = vtype_to_dtype (vmode_to_vtype (vfs_inode_get_mode old_vnode)) !old_vnode
      and ((ex, new_dent), r) = dentarr_add_dentry(ex, new_dent, old_vnode, new_name, dtype) !old_vnode
      in r
      | Error err ->
        let old_o = old_o {ounion = TObjDentarr old_dent}
        and ex = deep_freeObj(ex, old_o)
        and new_o = new_o {ounion = TObjDentarr new_dent}
        and ex = deep_freeObj(ex, new_o)
        in (#{ex, fs_st, vdir, old_vnode, opt_new_vnode = Some new_vnode}, Error err) 
      | Success () ->
        obj_dentarr_or_del_new(ex, old_o, old_dent)
        | Error (err, ex) ->
          let new_o = new_o {ounion = TObjDentarr new_dent}
          and ex = deep_freeObj(ex, new_o)
          in (#{ex, fs_st, vdir, old_vnode, opt_new_vnode = Some new_vnode}, Error err) 
        | Success (ex, old_o) ->
          let new_o = new_o {ounion = TObjDentarr new_dent}
          and fs_st {ostore_st} = fs_st
          and (#{ex, ostore_st, vdir, old_vnode, opt_new_vnode}, r) = fsop_do_rename_helper #{ex, mount_st = fs_st.mount_st, ostore_st, old_dent_size, new_dent_size, new_o, old_o, vdir, old_vnode, opt_new_vnode = Some new_vnode} !fs_st
          in r
          | Error err ->
            (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode, opt_new_vnode}, Error err) 
          | Success () ->
            (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode, opt_new_vnode}, Success ())

-- Rename is changing the name of a file/dir to another in the same directory
type FsopRenameP = #{ex:ExState, fs_st:FsState, vdir:VfsInode, old_name:(WordArray U8)!, old_vnode:VfsInode, new_name: (WordArray U8)!, opt_new_vnode: Option VfsInode}
type FsopRenameRR = #{ex:ExState, fs_st:FsState, vdir:VfsInode, old_vnode:VfsInode, opt_new_vnode: Option VfsInode}
fsop_rename: FsopRenameP -> RR FsopRenameRR () ErrCode
fsop_rename #{ex, fs_st = fs_st {ostore_st}, vdir, old_name, old_vnode, new_name, opt_new_vnode} =
  _cogent_debug "fsop_rename\n" ;
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st = fs_st {ostore_st}, vdir, old_vnode, opt_new_vnode}, Error eRoFs)
  else
    let old_is_dir = vmode_is_dir (vfs_inode_get_mode (old_vnode)) !old_vnode
    and old_vnode_nlink = vfs_inode_get_nlink (old_vnode) !old_vnode
    and old_vnode_ctime = vfs_inode_get_ctime (old_vnode) !old_vnode
    and vdir_mtime = vfs_inode_get_mtime (vdir) !vdir
    and vdir_ctime = vfs_inode_get_ctime (vdir) !vdir
    and vdir_size = vfs_inode_get_size (vdir) !vdir
    in opt_new_vnode
    | Some new_vnode ->
      let new_is_dir = vmode_is_dir (vfs_inode_get_mode (new_vnode)) !new_vnode
      and is_empty = check_dir_empty #{mount_st = fs_st.mount_st, ostore_st, vdir=new_vnode} !fs_st !ostore_st !new_vnode
      and _ = _cogent_debug "fsop_rename: check_dir_empty "
      and _ = _cogent_debug_u32 (if is_empty then 1 else 0)
      and _ = _cogent_debug "\n"
      -- True if not a directory
      in if not is_empty then
        let fs_st = fs_st {ostore_st}
        and opt_new_vnode:Option VfsInode = Some new_vnode
        in (#{ex, fs_st, vdir, old_vnode, opt_new_vnode}, Error eNotEmpty) 
      else
        let fs_st = fs_st {ostore_st}
        -- clear_nlink new_vnode
        and new_vnode_nlink = vfs_inode_get_nlink (new_vnode) !new_vnode
        and new_vnode_nlink_count = if new_is_dir then 0 else new_vnode_nlink - 1
        and new_vnode = vfs_inode_set_nlink(new_vnode, new_vnode_nlink_count)
        -- if old_is_dir then drop_nlink old_vnode
        and old_vnode_nlink = if old_is_dir then old_vnode_nlink - 1 else old_vnode_nlink
        and old_vnode = vfs_inode_set_nlink (old_vnode, old_vnode_nlink)
        -- update ctime, mtime ...
        and (ex, time) = os_get_current_time ex
        and time = vfs_inode_get_ctime (old_vnode) !old_vnode
        and vdir = vfs_inode_set_mtime (vdir, time)
        and vdir = vfs_inode_set_ctime (vdir, time)
        and (#{ex, fs_st, vdir, old_vnode, opt_new_vnode}, r) = fsop_do_rename_del #{ex, fs_st, vdir, old_name, old_vnode, new_name, new_vnode}
        in r
        | Error err ->
          -- rolling back changes
          let opt_new_vnode = opt_vnode_set_nlink (opt_new_vnode, new_vnode_nlink)
          and old_vnode = vfs_inode_set_nlink (old_vnode, old_vnode_nlink)
          and old_vnode = vfs_inode_set_ctime (old_vnode, old_vnode_ctime)
          and vdir = vfs_inode_set_mtime (vdir, vdir_mtime)
          and vdir = vfs_inode_set_ctime (vdir, vdir_ctime)
          and vdir = vfs_inode_set_size (vdir, vdir_size)
          in (#{ex, fs_st, vdir, old_vnode, opt_new_vnode}, Error err) 
        | Success () ->
          (#{ex, fs_st, vdir, old_vnode, opt_new_vnode}, Success ())
    | None ->
      let fs_st = fs_st {ostore_st}
      -- if old_is_dir then drop_nlink old_vnode
      and v_nlink = if old_is_dir then old_vnode_nlink - 1 else old_vnode_nlink
      and old_vnode = vfs_inode_set_nlink(old_vnode, v_nlink)
      -- update times
      and (ex, time) = os_get_current_time ex
      and old_vnode = vfs_inode_set_ctime(old_vnode, time)
      and vdir = vfs_inode_set_mtime(vdir, time)
      and vdir = vfs_inode_set_ctime(vdir, time)
      and (#{ex, fs_st, vdir, old_vnode}, r) = fsop_do_rename #{ex, fs_st, vdir, old_name, old_vnode, new_name}
      in r
      | Error err ->
        -- rolling back changes
        let old_vnode = vfs_inode_set_nlink (old_vnode, old_vnode_nlink)
        and old_vnode = vfs_inode_set_ctime(old_vnode, old_vnode_ctime)
        and vdir = vfs_inode_set_mtime(vdir, vdir_mtime)
        and vdir = vfs_inode_set_ctime(vdir, vdir_ctime)
        and vdir = vfs_inode_set_size(vdir, vdir_size)
        in (#{ex, fs_st, vdir, old_vnode, opt_new_vnode = None}, Error err)
      | Success () ->
        (#{ex, fs_st, vdir, old_vnode, opt_new_vnode = None}, Success ())

extract_inode_from_union:(ExState, ObjUnion) -> R (ExState, ObjInode) ExState
extract_inode_from_union(ex, ounion) =
  ounion
  | TObjPad _       -> Error ex
  | TObjData v      -> Error (deep_freeObjData(ex,v))
  | TObjDel v       -> Error ex
  | TObjSuper v     -> Error (deep_freeObjSuper(ex,v))
  | TObjSummary v   -> Error (summary_clean(ex,v))
  | TObjDentarr v   -> Error (deep_freeObjDentarr(ex,v))
  | TObjInode v     -> Success (ex, v)

type FsopIgetP = #{ex:ExState, fs_st: FsState, inum:VfsIno, vnode: VfsInode} 
type FsopIgetRR = #{ex:ExState, fs_st: FsState, vnode: VfsInode} 
fsop_iget: FsopIgetP -> RR FsopIgetRR () ErrCode
fsop_iget #{ex, fs_st = fs_st {ostore_st}, inum, vnode} =
  let oid = obj_id_inode_mk inum
  and ((ex, ostore_st), r) = ostore_read(ex, fs_st.mount_st, ostore_st, oid) !fs_st
  in r
  | Error e ->
    (#{ex, fs_st = fs_st {ostore_st}, vnode}, Error e) 
  | Success (obj {ounion}) ->
    let fs_st = fs_st {ostore_st}
    in extract_inode_from_union (ex, ounion)
    | Error ex ->
      _cogent_assert False ;
      let ex = freeObj(ex, obj)
      in (#{ex, fs_st, vnode}, Error eInval) 
    | Success (ex, oi) ->
      let vnode = vfs_inode_set_ino (vnode, inum_from_obj_id oi.id) !oi
      and vnode = vfs_inode_set_nlink(vnode, oi.nlink) !oi
      and vnode = vfs_inode_set_size(vnode, oi.size) !oi
      and vnode = vfs_inode_set_mtime(vnode, u64_to_TimeSpec oi.mtime_sec) !oi
      and vnode = vfs_inode_set_ctime(vnode, u64_to_TimeSpec oi.ctime_sec) !oi
      and vnode = vfs_inode_set_uid(vnode, oi.uid) !oi
      and vnode = vfs_inode_set_gid(vnode, oi.gid) !oi
      and vnode = vfs_inode_set_mode(vnode, oi.mode) !oi
      and vnode = vfs_inode_set_flags(vnode, oi.flags) !oi
      and ex = deep_freeObj(ex, obj {ounion = TObjInode oi})
      in (#{ex, fs_st, vnode}, Success ())

extract_data_from_union:(ExState, ObjUnion) -> R (ExState, ObjData) ExState
extract_data_from_union(ex, ounion) =
  ounion
  | TObjPad _       -> Error ex
  | TObjInode v     -> Error (deep_freeObjInode(ex,v))
  | TObjDel v       -> Error ex
  | TObjSuper v     -> Error (deep_freeObjSuper(ex,v))
  | TObjSummary v   -> Error (summary_clean(ex,v))
  | TObjDentarr v   -> Error (deep_freeObjDentarr(ex,v))
  | TObjData v      -> Success (ex, v)

read_block:(ExState, FsState, VfsInode!, Buffer, OSPageOffset) -> RR (ExState, FsState, Buffer) () ErrCode
read_block(ex, fs_st {ostore_st}, vnode, buf, block) =
  let oid = obj_id_data_mk(vfs_inode_get_ino(vnode), u64_to_u32(block)) !vnode
  and ((ex, ostore_st), r) = ostore_read(ex, fs_st.mount_st, ostore_st, oid) !fs_st
  in r
  | Error e ->
    let fs_st = fs_st {ostore_st}
    in if e == eNoEnt then
      let buf = buf_memset(buf, 0, bilbyFsBlockSize, 0)
      in ((ex, fs_st, buf), Success ())
    else
      ((ex, fs_st, buf), Error e)
  | Success (obj {ounion}) ->
    let fs_st = fs_st {ostore_st}
    in extract_data_from_union(ex, ounion)
    | Error ex ->
      _cogent_assert False ;
      let ex = freeObj(ex, obj)
      in ((ex, fs_st, buf), Error eInval) 
    | Success (ex, od) ->
      let ex = freeObj(ex, obj)
      and size = wordarray_length[U8] (od.odata) !od
      in if size > bilbyFsBlockSize then
        _cogent_debug "bad object data" ;
        let ex = deep_freeObjData(ex, od)
        in ((ex, fs_st, buf), Error eInval)
      else
        let buf {data} = buf
        --and data = wordarray_copy_n[U8] #{dest=data, src=od.odata, size} !od
        and data = wordarray_copy[U8] (data, od.odata, 0, 0, size) !od
        and buf = buf {data}
        and buf = buf_memset (buf, size, bilbyFsBlockSize - size, 0)
        and ex = deep_freeObjData(ex, od)
        in ((ex, fs_st, buf), Success ())

type FsopReadPageP = #{ex:ExState, fs_st: FsState, vnode: VfsInode, block: OSPageOffset, addr: Buffer}
type FsopReadPageRR = #{ex:ExState, fs_st: FsState, vnode: VfsInode, addr: Buffer}

fsop_readpage: FsopReadPageP -> RR FsopReadPageRR () ErrCode 
fsop_readpage #{ex, fs_st, vnode, block, addr} =
  -- block has to fit in u32
  let size = vfs_inode_get_size(vnode) !vnode
  and limit = size >> upcast bilbyFsBlockShift
  in if block > limit then
   let addr = buf_memset(addr, 0, bilbyFsBlockSize, 0)
   in (#{ex, fs_st, vnode, addr}, Error eNoEnt)
  else if block == limit && (size % upcast bilbyFsBlockSize == 0) then
    (#{ex, fs_st, vnode, addr}, Success ())
  else
   let ((ex, fs_st, addr), r) = read_block(ex, fs_st, vnode, addr, block) !vnode
   in r
   | Error err  -> (#{ex, fs_st, vnode, addr}, Error err) 
   | Success () -> (#{ex, fs_st, vnode, addr}, Success ())

type FsopWriteP = #{ex:ExState, fs_st: FsState, vnode: VfsInode, pos: OSPageOffset, len:U32, addr: Buffer}
type FsopWriteRR = #{ex:ExState, fs_st: FsState, vnode: VfsInode, addr: Buffer}
fsop_write_begin: FsopWriteP -> RR FsopWriteRR () ErrCode
fsop_write_begin #{ex, fs_st, vnode, pos, len, addr} =
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st, vnode, addr}, Error eRoFs) 
  else
    let (#{ex, fs_st, vnode, addr}, r) = fsop_readpage #{ex, fs_st, vnode, block=pos >> upcast bilbyFsBlockShift, addr}
    in r
    | Error err ->
      if err == eNoEnt then
        (#{ex, fs_st, vnode, addr}, Success ())
      else
        _bilbyfs_error "fsop_write_begin: Error\n" ;
        (#{ex, fs_st, vnode, addr}, Error err)
    | Success () ->
      (#{ex, fs_st, vnode, addr}, Success ())

get_data_back: (ExState, WordArray U8, Option Obj) -> (ExState, WordArray U8)
get_data_back (ex, dummy_data, opto) =
  opto
  | None ->
    _cogent_assert False ;
    (ex, dummy_data)
  | Some obj {ounion} ->
    extract_data_from_union (ex, ounion)
    | Error ex ->
      let ex = freeObj(ex, obj)
      in (ex, dummy_data)
    | Success (ex, od {odata}) ->
      let ex = freeObjData(ex, od)
      and ex = freeObj(ex, obj)
      and ex = wordarray_free[U8] (ex, dummy_data)
      in (ex, odata)

fsop_write_end: FsopWriteP -> RR FsopWriteRR () ErrCode
fsop_write_end #{ex, fs_st, vnode, pos, len, addr} =
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st, vnode, addr}, Error eRoFs)
  else
    let isize = vfs_inode_get_size vnode !vnode
    and v_size = if pos + upcast len > isize then pos + upcast len else isize
    and mtime = vfs_inode_get_mtime vnode !vnode
    and (ex, time) = os_get_current_time(ex)
    and vnode = vfs_inode_set_mtime(vnode,time)
    and vnode = vfs_inode_set_size(vnode, v_size)
    and (ex, r) = obj_inode_new(ex, vnode) !vnode
    in r
    | Error err ->
       (#{ex, fs_st, vnode, addr}, Error err)
    | Success ovnode ->
      -- We allocate a WordArray to convince the type
      -- system that we have always return a valid page
      -- even if extract_data_from_union returns an error
      -- which we can prove never happens in practice
      wordarray_create[U8] (ex, 1)
      | Error ex ->
        let ex = deep_freeObj(ex, ovnode)
        in (#{ex, fs_st, vnode, addr}, Error eNoMem)
      | Success (ex, dummy_data) ->
        let block = u64_to_u32 (pos >> upcast bilbyFsBlockShift)
        and oid = obj_id_data_mk (vfs_inode_get_ino vnode, block) !vnode
        and start = pos .&. (os_PAGE_CACHE_SIZE - 1)
        and end = u64_to_u32 start + len
        -- get data out
        and addr {data} = addr
        and (ex, r) = obj_data_new(ex, oid, end, data)
        in r
        | Error (err, data) ->
          let ex = deep_freeObj(ex, ovnode)
          and ex = wordarray_free[U8](ex, dummy_data)
          and addr = addr {data}
          in (#{ex, fs_st, vnode, addr}, Error err)
        | Success odata ->
          arrayobj_create2(ex, ovnode, odata)
          | Error (ex, odata) ->
            let (ex, data) = get_data_back (ex, dummy_data, Some odata)
            and addr = addr {data}
            in (#{ex, fs_st, vnode, addr}, Error eNoMem)
          | Success (ex, arr) ->
            let fs_st {ostore_st} = fs_st
            and ((ex, ostore_st, arr), r) = ostore_write(ex, fs_st.mount_st, ostore_st, arr, ostoreWriteNone) !fs_st
            and (arr, optobj) = array_remove[Obj] (arr, 1)
            and (ex, data) = get_data_back (ex, dummy_data, optobj)
            and addr = addr {data}
            and ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
            in r
            | Error err ->
              let vnode = vfs_inode_set_size(vnode, isize)
              and vnode = vfs_inode_set_mtime(vnode, mtime)
              in (#{ex, fs_st = fs_st {ostore_st}, vnode, addr}, Error err)
            | Success () ->
              (#{ex, fs_st = fs_st {ostore_st}, vnode, addr}, Success ())

type FsopVfsInodeP = #{ex: ExState, fs_st: FsState, vnode: VfsInode}
type FsopVfsInodeE = #{err: ErrCode, ex: ExState, fs_st: FsState, vnode: VfsInode}
fsop_evict_inode: FsopVfsInodeP -> RR FsopVfsInodeP () ErrCode
fsop_evict_inode #{ex, fs_st, vnode} =
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st, vnode}, Error eRoFs)
  else
    let nlink = vfs_inode_get_nlink vnode !vnode
    in if nlink /= 0 then
      (#{ex, fs_st, vnode}, Success ())
    else
      let oid = obj_id_inode_mk(vfs_inode_get_ino vnode) !vnode
      and (ex, r) = obj_del_new (ex,oid)
      in r
      | Error err ->
        (#{ex, fs_st, vnode}, Error err)
      | Success odel ->
        arrayobj_create1(ex, odel)
        | Error ex -> (#{ex, fs_st, vnode}, Error eNoMem)
        | Success (ex, arr) ->
          let fs_st {ostore_st} = fs_st
          and ((ex, ostore_st, arr), r) = ostore_write(ex, fs_st.mount_st, ostore_st, arr, ostoreWriteNone) !fs_st
          in r
          | Error err ->
            let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
            in (#{ex, fs_st = fs_st {ostore_st}, vnode}, Error err)
          | Success () ->
            let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
            in (#{ex, fs_st = fs_st {ostore_st}, vnode}, Success ())

fsop_write_inode: FsopVfsInodeP -> RR FsopVfsInodeP () ErrCode
fsop_write_inode #{ex, fs_st, vnode} =
  let (ex, r) = obj_inode_new(ex, vnode) !vnode
  in r
  | Error err ->
    (#{ex, fs_st, vnode}, Error err)
  | Success oi ->
    arrayobj_create1(ex, oi)
    | Error ex -> (#{ex, fs_st, vnode}, Error eNoMem)
    | Success (ex, arr) ->
      let fs_st {ostore_st} = fs_st
      and ((ex, ostore_st, arr), r) = ostore_write(ex, fs_st.mount_st, ostore_st, arr, ostoreWriteNone) !fs_st
      in r
      | Error err ->
        let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
        in (#{ex, fs_st = fs_st {ostore_st}, vnode}, Error err)
      | Success () ->
        let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
        in (#{ex, fs_st = fs_st {ostore_st}, vnode}, Success ())

type FsopFollowLinkP = #{ex:ExState, fs_st: FsState, vnode: VfsInode, path: Buffer}
fsop_follow_link: FsopFollowLinkP -> RR FsopFollowLinkP () ErrCode
fsop_follow_link #{ex, fs_st, vnode, path} =
  let ((ex, fs_st, path), r) = read_block(ex, fs_st, vnode, path, 0) !vnode
  in r
  | Error err ->
    (#{ex, fs_st, vnode, path}, Error err) 
  | Success () ->
    (#{ex, fs_st, vnode, path}, Success ())

type FsopGetattrP = #{ex:ExState, fs_st: FsState, stat: VfsStat, vnode: VfsInode!}
type FsopGetattrR = #{ex:ExState, fs_st: FsState, stat: VfsStat}
fsop_getattr: FsopGetattrP -> FsopGetattrR
fsop_getattr #{ex, fs_st, stat, vnode} =
  let stat = vfs_stat_set_ino (stat, vfs_inode_get_ino(vnode))
  and stat = vfs_stat_set_nlink (stat, vfs_inode_get_nlink(vnode))
  and size = vfs_inode_get_size(vnode)
  and stat = vfs_stat_set_size (stat, size)
  and stat = vfs_stat_set_atime (stat, vfs_inode_get_ctime(vnode))
  and stat = vfs_stat_set_ctime (stat, vfs_inode_get_ctime(vnode))
  and stat = vfs_stat_set_mtime (stat, vfs_inode_get_mtime(vnode))
  and stat = vfs_stat_set_mode (stat, vfs_inode_get_mode(vnode))
  and stat = vfs_stat_set_uid (stat, vfs_inode_get_uid vnode)
  and stat = vfs_stat_set_gid (stat, vfs_inode_get_gid vnode)
  and stat = vfs_stat_set_blksize (stat, bilbyFsBlockSize)
  and size = align64 (size, upcast bilbyFsBlockSize)
  and blocks = if vmode_is_dir (vfs_inode_get_mode vnode) then 0 else size / 512
  and stat = vfs_stat_set_blocks (stat, blocks)
  in #{ex, fs_st, stat}

type FsopSetattrP = #{ex:ExState, fs_st: FsState, iattr: VfsIattr!, vnode: VfsInode}
type FsopSetattrRR = #{ex:ExState, fs_st: FsState, vnode: VfsInode}
fsop_do_setattr: FsopSetattrP -> RR FsopSetattrRR () ErrCode
fsop_do_setattr #{ex, fs_st, iattr, vnode} =
  let mode = vfs_inode_get_mode vnode !vnode
  and uid = vfs_inode_get_uid vnode !vnode
  and gid = vfs_inode_get_gid vnode !vnode
  and mtime = vfs_inode_get_mtime vnode !vnode
  and ctime = vfs_inode_get_ctime vnode !vnode
  and valid = vfs_iattr_get_valid iattr !iattr
  and vnode = if is_set(valid, vfs_ATTR_MODE) then vfs_inode_set_mode (vnode, vfs_iattr_get_mode iattr) else vnode
  and vnode = if is_set(valid, vfs_ATTR_UID) then vfs_inode_set_uid (vnode, vfs_iattr_get_uid iattr) else vnode
  and vnode = if is_set(valid, vfs_ATTR_GID) then vfs_inode_set_gid (vnode, vfs_iattr_get_gid iattr) else vnode
  and vnode = if is_set(valid, vfs_ATTR_MTIME) then vfs_inode_set_mtime (vnode, vfs_iattr_get_mtime iattr) else vnode
  and vnode = if is_set(valid, vfs_ATTR_CTIME) then vfs_inode_set_ctime (vnode, vfs_iattr_get_ctime iattr) else vnode
  and (#{ex, fs_st, vnode}, r) = fsop_write_inode #{ex, fs_st, vnode}
  in r
  | Error err ->
    let vnode = vfs_inode_set_mode (vnode, mode)
    and vnode = vfs_inode_set_uid (vnode, uid)
    and vnode = vfs_inode_set_gid (vnode, gid)
    and vnode = vfs_inode_set_mtime (vnode, mtime)
    and vnode = vfs_inode_set_ctime (vnode, ctime)
    in (#{ex, fs_st, vnode}, Error err)
  | Success () ->
    (#{ex, fs_st, vnode}, Success ())

truncate_arrayobj_create: (ExState, Option Obj, Option Obj, Obj) -> R (ExState, Array Obj) ExState
truncate_arrayobj_create(ex, o1, o2, o3) =
  array_create[Obj] (ex, 3)
  | Error ex ->
    let ex = free_opt_obj (ex, o1)
    and ex = free_opt_obj (ex, o2)
    and ex = deep_freeObj (ex, o3)
    in Error ex
  | Success (ex, arr) ->
    let #{arr=arr, acc=(ex, opt1)} = array_modify[Obj, (ExState, Option Obj)] #{arr=arr, idx=0, f=set_obj, acc=(ex, o1)}
    and #{arr=arr, acc=(ex, opt2)} = array_modify[Obj, (ExState, Option Obj)] #{arr=arr, idx=1, f=set_obj, acc=(ex, o2)}
    and #{arr=arr, acc=(ex, opt3)} = array_modify[Obj, (ExState, Option Obj)] #{arr=arr, idx=2, f=set_obj, acc=(ex, Some o3)}
    and ex = free_opt_obj (ex, opt1)
    and ex = free_opt_obj (ex, opt2)
    and ex = free_opt_obj (ex, opt3)
    in Success (ex, arr)


truncate_last_block: FsopTruncateP -> RR FsopSetattrRR (Option Obj) ErrCode
truncate_last_block #{ex, fs_st, vnode, newsize} =
  let oldsize = vfs_inode_get_size vnode !vnode
  and newsize_aligned = align64 (newsize, upcast bilbyFsBlockSize)
  in if newsize /= newsize_aligned && newsize < oldsize then
    let block = newsize >> upcast bilbyFsBlockShift
    and oid = obj_id_data_mk(vfs_inode_get_ino vnode, u64_to_u32 block) !vnode
    and fs_st {ostore_st} = fs_st
    and ((ex, ostore_st), r) = ostore_read(ex, fs_st.mount_st, ostore_st, oid) !fs_st
    in r
    | Error err ->
      (#{ex, fs_st = fs_st {ostore_st}, vnode}, Error err) 
    | Success obj ->
      let szdata = u64_to_u32 (newsize - (newsize_aligned - upcast bilbyFsBlockSize))
      and len = bilbyFsObjHeaderSize + 8 + szdata
      and obj = obj {len}
      -- we shrink the last data block simply by changing obj.len
      in (#{ex, fs_st = fs_st {ostore_st}, vnode}, Success (Some obj))
  else
    (#{ex, fs_st, vnode}, Success None)

truncate_deletion_obj: FsopTruncateP -> RR FsopSetattrRR (Option Obj) ErrCode
truncate_deletion_obj #{ex, fs_st, vnode, newsize} =
  let oldsize = vfs_inode_get_size vnode !vnode
  and newsize_aligned = align64 (newsize, upcast bilbyFsBlockSize)
  in if newsize_aligned < oldsize then
    let block = newsize_aligned >> upcast bilbyFsBlockShift
    and oid = obj_id_data_mk (vfs_inode_get_ino vnode, u64_to_u32 block) !vnode
    and (ex, r) = obj_del_new (ex,oid)
    in r
    | Error   err -> (#{ex, fs_st, vnode}, Error err) 
    | Success obj -> (#{ex, fs_st, vnode}, Success (Some obj))
  else (#{ex, fs_st, vnode}, Success None)

type FsopTruncateP = #{ex:ExState, fs_st: FsState, vnode: VfsInode, newsize: U64}
fsop_do_truncate: FsopTruncateP -> RR FsopSetattrRR () ErrCode
fsop_do_truncate #{ex, fs_st, vnode, newsize} =
  _cogent_debug "fsop_do_truncate " ;
  _cogent_debug_u64 newsize ;
  _cogent_debug "\n" ;
  let oldsize = vfs_inode_get_size vnode !vnode
  and v_mtime = vfs_inode_get_mtime vnode !vnode
  and v_ctime = vfs_inode_get_ctime vnode !vnode
  and (ex, time) = os_get_current_time(ex)
  and vnode = vfs_inode_set_mtime (vnode, time)
  and vnode = vfs_inode_set_ctime (vnode, time)
  and vnode = vfs_inode_set_size (vnode, newsize)
  and (ex, r) = obj_inode_new(ex, vnode) !vnode
  in r
  | Error err ->
    (#{ex, fs_st, vnode}, Error err)
  | Success oi ->
    let (#{ex, fs_st, vnode}, r) = truncate_last_block #{ex, fs_st, vnode, newsize}
    in r
    | Error err ->
      let ex = deep_freeObj(ex, oi)
      in (#{ex, fs_st, vnode}, Error err)
    | Success optlastblock ->
      let (#{ex, fs_st, vnode}, r) = truncate_deletion_obj #{ex, fs_st, vnode, newsize}
      in r
      | Error err ->
        let ex = deep_freeObj(ex, oi)
        and ex = deep_opt_freeObj(ex, optlastblock)
        in (#{ex, fs_st, vnode}, Error err) 
      | Success optdel ->
        let osw_flag = (optdel
              | None -> ostoreWriteDel
              | Some _ -> ostoreWriteNone) !optdel
        in truncate_arrayobj_create(ex, optlastblock, optdel, oi)
        | Error ex ->
          (#{ex, fs_st, vnode}, Error eNoMem)
        | Success (ex, arr) ->
          let fs_st {ostore_st} = fs_st
          and ((ex, ostore_st, arr), r) = ostore_write(ex, fs_st.mount_st, ostore_st, arr, osw_flag) !fs_st
          in r
          | Error err ->
            let vnode = vfs_inode_set_size(vnode, oldsize)
            and vnode = vfs_inode_set_mtime(vnode, v_mtime)
            and vnode = vfs_inode_set_ctime(vnode, v_ctime)
            and ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
            in (#{ex, fs_st = fs_st {ostore_st}, vnode}, Error err)
          | Success () ->
            let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
            in (#{ex, fs_st = fs_st {ostore_st}, vnode}, Success ()) 

fsop_setattr: FsopSetattrP -> RR FsopSetattrRR () ErrCode
fsop_setattr #{ex, fs_st, iattr, vnode} =
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  and valid = vfs_iattr_get_valid iattr !iattr
  in if is_ro then
    (#{ex, fs_st, vnode}, Error eRoFs) 
  else if is_set(valid, vfs_ATTR_SIZE) then
    let newsize = vfs_iattr_get_size iattr !iattr
    in fsop_do_truncate #{ex, fs_st, vnode, newsize}
  else
    fsop_do_setattr #{ex, fs_st, iattr, vnode}

type FsopFsP = #{ex:ExState, fs_st: FsState}
fsop_sync_fs: FsopFsP -> RR FsopFsP () ErrCode
fsop_sync_fs #{ex, fs_st} =
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st}, Error eRoFs)
  else
    let fs_st {ostore_st,fsop_st} = fs_st
    and ((ex, ostore_st), r) = ostore_sync(ex, fs_st.mount_st, ostore_st, ostoreWriteNone) !fs_st
    in r
    | Error err ->
      (#{ex, fs_st = fs_st {ostore_st,fsop_st = fsop_st {is_ro= err == eIO }}}, Error err) 
    | Success () ->
      (#{ex, fs_st = fs_st {ostore_st,fsop_st} }, Success ())

type FsopSymlinkP = #{ex:ExState, fs_st: FsState, vdir: VfsInode, name: (WordArray U8)!, symname: (WordArray U8), vnode: VfsInode}
type FsopSymlinkRR = #{ex:ExState, fs_st:FsState, vdir:VfsInode, symname:WordArray U8, vnode:VfsInode}
fsop_symlink : FsopSymlinkP -> RR FsopSymlinkRR () ErrCode
fsop_symlink #{ex, fs_st = fs_st {ostore_st}, vdir, name, symname, vnode} =
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  and sz_sym = wordarray_length[U8] symname !symname
  in if is_ro then
    (#{ex, fs_st = fs_st {ostore_st}, vdir, symname, vnode}, Error eRoFs)
  else if sz_sym > bilbyFsBlockSize then
    (#{ex, fs_st = fs_st {ostore_st}, vdir, symname, vnode}, Error eNameTooLong)
  else
   let ((ex, ostore_st, vnode), r) = init_vnode(ex, ostore_st, vdir, vnode, s_IFLNK .|. s_IRWXUGO) !vdir
   in r
   | Error err ->
     (#{ex, fs_st = fs_st {ostore_st}, vdir, symname, vnode}, Error err)
   | Success () ->
     let ((ex, ostore_st), r) = dentarr_read_and_add (ex, fs_st.mount_st, ostore_st, vdir, name, vnode, bilbyFsITypeLnk) !fs_st !vdir !vnode
     in r
     | Error err ->
       (#{ex, fs_st = fs_st {ostore_st}, vdir, symname, vnode}, Error err)
     | Success (new_v_size, dentarr_obj) ->
       let fs_st = fs_st {ostore_st}
       -- We allocate a WordArray to convince the type
       -- system that we have always return a valid page
       -- even if extract_data_from_union returns an error
       -- which we can prove never happens in practice
       in wordarray_create[U8] (ex, 1)
       | Error ex ->
         let ex = deep_freeObj(ex, dentarr_obj)
         in (#{ex, fs_st, vdir, symname, vnode}, Error eNoMem)
       | Success (ex, dummy_data) ->
         let oid = obj_id_data_mk (vfs_inode_get_ino vnode, 0) !vnode
         and (ex, r) = obj_data_new(ex, oid, sz_sym, symname)
         in r
         | Error (err, symname) ->
           let ex = wordarray_free[U8](ex, dummy_data)
           and ex = deep_freeObj(ex, dentarr_obj)
           in (#{ex, fs_st, vdir, symname, vnode}, Error err)
         | Success odata ->
           let (ex, r) = obj_inode_new(ex, vnode) !vnode
           in r
           | Error err ->
             let ex = deep_freeObj(ex, dentarr_obj)
             and (ex, symname) = get_data_back (ex, dummy_data, Some odata)
             in (#{ex, fs_st, vdir, symname, vnode}, Error err)
           | Success inode ->
             let v_size' = vfs_inode_get_size vdir !vdir
             and v_mtime' = vfs_inode_get_mtime vdir !vdir
             and v_ctime' = vfs_inode_get_ctime vdir !vdir
             and (ex, time) = os_get_current_time(ex)
             and vdir = vfs_inode_set_size(vdir, new_v_size)
             and vdir = vfs_inode_set_mtime(vdir, time)
             and vdir = vfs_inode_set_ctime(vdir, time)
             and (ex, r) = obj_inode_new(ex, vdir) !vdir
             in r
             | Error err ->
               let ex = deep_freeObj(ex, dentarr_obj)
               and ex = deep_freeObj(ex, inode)
               and (ex, symname) = get_data_back (ex, dummy_data, Some odata)
               and vdir = vfs_inode_set_size(vdir, v_size')
               and vdir = vfs_inode_set_mtime(vdir, v_mtime')
               and vdir = vfs_inode_set_ctime(vdir, v_ctime')
               in (#{ex, fs_st, vdir, symname, vnode}, Error err)
             | Success dir ->
               arrayobj_create4_ret2(ex, dentarr_obj, odata, inode, dir)
               | Error (ex, odata) ->
                 let vdir = vfs_inode_set_size(vdir, v_size')
                 and vdir = vfs_inode_set_mtime(vdir, v_mtime')
                 and vdir = vfs_inode_set_ctime(vdir, v_ctime')
                 and (ex, symname) = get_data_back (ex, dummy_data, Some odata)
                 in (#{ex, fs_st, vdir, symname, vnode}, Error eNoMem)
               | Success (ex, arr) ->
                 let fs_st {ostore_st} = fs_st
                 and ((ex, ostore_st, arr), r) = ostore_write(ex, fs_st.mount_st, ostore_st, arr, ostoreWriteNone) !fs_st
                 and fs_st = fs_st {ostore_st}
                 and (arr, opto) = array_remove[Obj] (arr, 1)
                 and (ex, symname) = get_data_back (ex, dummy_data, opto)
                 in r
                 | Error err ->
                   let vdir = vfs_inode_set_size(vdir, v_size')
                   and vdir = vfs_inode_set_mtime(vdir, v_mtime')
                   and vdir = vfs_inode_set_ctime(vdir, v_ctime')
                   and ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
                   in (#{ex, fs_st, vdir, symname, vnode}, Error err)
                 | Success () ->
                   let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
                   in (#{ex, fs_st, vdir, symname, vnode}, Success ())

type FsopLinkP = #{ex:ExState, fs_st: FsState, vdir: VfsInode, name: (WordArray U8)!, vnode: VfsInode}
fsop_link : FsopLinkP -> RR FsopRR () ErrCode
fsop_link #{ex, fs_st = fs_st {ostore_st}, vdir, name, vnode} =
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error eRoFs)
  else
     let vtype = vfs_inode_get_mode vnode !vnode
     and dtype = vtype_to_dtype vtype
     and ((ex, ostore_st), r) = dentarr_read_and_add (ex, fs_st.mount_st, ostore_st, vdir, name, vnode, dtype) !fs_st !vdir !vnode
     in r
     | Error err ->
       (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
     | Success (new_v_size, dentarr_obj) ->
       let vnode = vfs_inode_inc_nlink vnode
       and (ex, time) = os_get_current_time(ex)
       and vnode = vfs_inode_set_mtime(vnode, time)
       and vnode = vfs_inode_set_ctime(vnode, time)
       and (ex, r) = obj_inode_new(ex, vnode) !vnode
       in r
       | Error err ->
         let ex = deep_freeObj(ex, dentarr_obj)
         and vnode = vfs_inode_dec_nlink vnode
         in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
       | Success inode ->
         let v_size' = vfs_inode_get_size vdir !vdir
         and v_mtime' = vfs_inode_get_mtime vdir !vdir
         and v_ctime' = vfs_inode_get_ctime vdir !vdir
         and vdir = vfs_inode_set_size(vdir, new_v_size)
         and vdir = vfs_inode_set_mtime(vdir, time)
         and vdir = vfs_inode_set_ctime(vdir, time)
         and (ex, r) = obj_inode_new(ex, vdir) !vdir
         in r
         | Error err ->
            let ex = deep_freeObj(ex, dentarr_obj)
            and ex = deep_freeObj(ex, inode)
            and vdir = vfs_inode_set_size(vdir, v_size')
            and vdir = vfs_inode_set_mtime(vdir, v_mtime')
            and vdir = vfs_inode_set_ctime(vdir, v_ctime')
            and vnode = vfs_inode_dec_nlink vnode
            in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
         | Success dir ->
           arrayobj_create3(ex, dentarr_obj, inode, dir)
           | Error ex ->
             let vdir = vfs_inode_set_size(vdir, v_size')
             and vdir = vfs_inode_set_mtime(vdir, v_mtime')
             and vdir = vfs_inode_set_ctime(vdir, v_ctime')
             and vnode = vfs_inode_dec_nlink vnode
             in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error eNoMem)
           | Success (ex, arr) ->
             let ((ex, ostore_st, arr), r) = ostore_write(ex, fs_st.mount_st, ostore_st, arr, ostoreWriteNone) !fs_st
             in r
             | Error err ->
               let vdir = vfs_inode_set_size(vdir, v_size')
               and vdir = vfs_inode_set_mtime(vdir, v_mtime')
               and vdir = vfs_inode_set_ctime(vdir, v_ctime')
               and vnode = vfs_inode_dec_nlink vnode
               and ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
               in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Error err)
             | Success () ->
               let ex = array_free[Obj] #{arr=arr, f=deep_freeObj, ex}
               in (#{ex, fs_st = fs_st {ostore_st}, vdir, vnode}, Success ())

fsop_format_default: FsopVfsInodeP -> RR FsopVfsInodeP () ErrCode
fsop_format_default #{ex, fs_st, vnode=root} =
  _bilbyfs_error "Empty flash memory detected, we format it with BilbyFs\n"  ;
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st, vnode=root}, Error eRoFs)
  else
    let fs_st {mount_st, ostore_st} = fs_st
    and ostore_st = ostore_st {next_inum = bilbyFsRootIno + 1}
    and root = vfs_inode_set_ino(root, bilbyFsRootIno)
    and root = vfs_inode_set_nlink(root, 2)
    and (ex, time) = os_get_current_time(ex)
    and root = vfs_inode_set_mtime(root, time)
    and root = vfs_inode_set_ctime(root, time)
    and root = vfs_inode_set_uid(root, os_get_current_fsuid(ex)) !ex
    and root = vfs_inode_set_mode(root, s_IFDIR .|. s_IRUGO .|. s_IWUSR .|. s_IXUGO)
    and root = vfs_inode_set_gid(root, os_get_current_fsgid(ex)) !ex
    and ((ex, mount_st, ostore_st), r) = ostore_write_super(ex, mount_st, ostore_st)
    in r
    | Error err ->
      let ostore_st = ostore_st {used = 0}
      in (#{ex, fs_st = fs_st {ostore_st, mount_st}, vnode=root}, Error err)
    | Success () ->
      let (ostore_st, r) = ostore_new_wbuf(mount_st, ostore_st, ostoreWriteNone) !mount_st
      in r
      | Error err ->
        (#{ex, fs_st = fs_st {ostore_st, mount_st}, vnode=root}, Error err)
      | Success () ->
        -- Initialise OstoreState when no ObjSuper is read from flash:
        let ostore_st = ostore_st {used = 0}
        and fs_st = fs_st {ostore_st, mount_st}
        and (#{ex, fs_st, vnode}, r) = fsop_write_inode #{ex, fs_st, vnode = root}
        in r
        | Error err ->
          (#{ex, fs_st, vnode}, Error err)
        | Success () ->
          (#{ex, fs_st, vnode}, Success ())

fsop_test_is_mount: (FsState!, FsState!) -> Bool
-- Return true if the two states indicate that they correspond to the same device.
fsop_test_is_mount(fs_st1, fs_st2) =
  wubi_vol_cdev fs_st1.mount_st.vol == wubi_vol_cdev fs_st2.mount_st.vol

-- fsop_init opens the UBI device and sets up default values for
-- mount_st fields that are not specific to the hardware.
-- We will then double check that these value are consistent with
-- the ones stored in the super-block of BilbyFs.
-- The information stored in mount_st by fsop_init should be enough
-- to be able to detect if the device is already mounted by another
-- instance of BilbyFs.
type FsState'Taken = FsState' take (..)
type FsopInitP = #{ex:ExState, fs_st: FsState'Taken, name: CString!}
type FsopFs'P = #{ex:ExState, fs_st: FsState'}
type FsopFs'E = #{err:ErrCode, ex:ExState, fs_st: FsState'Taken}
fsop_init: FsopInitP -> R FsopFs'P FsopFs'E
fsop_init #{ex,fs_st,name} =
  newMountState ex
  | Error ex ->
    Error #{err=eNoMem, ex, fs_st}
  | Success (ex, mount_st) ->
    newFsopState ex
    | Error ex ->
      let ex = freeMountState(ex, mount_st)
      in Error #{err=eNoMem, ex, fs_st}
    | Success (ex, fsop_st) ->
      newOstoreState ex
      | Error ex ->
        let ex = freeMountState(ex, mount_st)
        and ex = freeFsopState(ex, fsop_st)
        in Error #{err=eNoMem, ex, fs_st}
      | Success (ex, ostore_st) ->
        newUbiVolInfo ex
        | Error ex ->
          let ex = freeMountState(ex, mount_st)
          and ex = freeFsopState(ex, fsop_st)
          and ex = freeOstoreState(ex, ostore_st)
          in Error #{err=eInval, ex, fs_st}
        | Success (ex, vol) ->
          newUbiDevInfo ex
          | Error ex ->
            let ex = freeMountState(ex, mount_st)
            and ex = freeFsopState(ex, fsop_st)
            and ex = freeOstoreState(ex, ostore_st)
            and ex = freeUbiVolInfo(ex, vol)
            in Error #{err=eInval, ex, fs_st}
          | Success (ex, dev) ->
            newObj ex
            | Error ex ->
              let ex = freeMountState(ex, mount_st)
              and ex = freeFsopState(ex, fsop_st)
              and ex = freeOstoreState(ex, ostore_st)
              and ex = freeUbiVolInfo(ex, vol)
              and ex = freeUbiDevInfo(ex, dev)
              in Error #{err=eInval, ex, fs_st}
            | Success (ex, obj_sup) ->
              wubi_open #{ex,name,mode=ubiReadOnly}
              | Error ex ->
                let ex = freeMountState(ex, mount_st)
                and ex = freeFsopState(ex, fsop_st)
                and ex = freeOstoreState(ex, ostore_st)
                and ex = freeUbiVolInfo(ex, vol)
                and ex = freeUbiDevInfo(ex, dev)
                and ex = freeObj(ex, obj_sup)
                in Error #{err=eInval, ex, fs_st}
              | Success (ex, ubivol) ->
                let vol = wubi_get_vol_info(ubivol, vol) !ubivol
                and ubi_num = wubi_vol_ubi_num vol !vol
                in wubi_get_dev_info(ubi_num, dev)
                | Error (err, dev) ->
                  let ex = freeMountState(ex, mount_st)
                  and ex = freeFsopState(ex, fsop_st)
                  and ex = freeOstoreState(ex, ostore_st)
                  and ex = freeUbiVolInfo(ex, vol)
                  and ex = freeUbiDevInfo(ex, dev)
                  and ex = freeObj(ex, obj_sup)
                  and ex = wubi_close (ex, ubivol)
                  in Error #{err=eInval, ex, fs_st}
                | Success dev ->
                  newObjSuper ex
                  | Error ex ->
                    let ex = freeMountState(ex, mount_st)
                    and ex = freeFsopState(ex, fsop_st)
                    and ex = freeOstoreState(ex, ostore_st)
                    and ex = freeUbiVolInfo(ex, vol)
                    and ex = freeUbiDevInfo(ex, dev)
                    and ex = freeObj(ex, obj_sup)
                    and ex = wubi_close (ex, ubivol)
                    in Error #{err=eNoMem, ex, fs_st}
                  | Success (ex, super) ->
                    let super = mkObjSuper(super, vol, dev) !vol !dev
                    and obj_sup = obj_init_default(obj_sup, bilbyFsObjTypeSuper)
                    and mount_st = mount_st {vol, dev, eb_recovery=0,
                      eb_recovery_offs=0, super,
                      obj_sup, super_offs = 0, no_summary = False}
                    and fsop_st = fsop_st {is_ro=True}
                    and ex = wubi_close (ex, ubivol)
                    in ostore_init(ex, mount_st, ostore_st) !mount_st
                    | Error (err, ex, ostore_st) ->
                      let mount_st {obj_sup,vol,dev,super} = mount_st
                      and ex = deep_freeObjSuper(ex, super)
                      and ex = freeObj(ex, obj_sup)
                      and ex = freeMountState(ex, mount_st)
                      and ex = freeFsopState(ex, fsop_st)
                      and ex = freeOstoreState(ex, ostore_st)
                      and ex = freeUbiVolInfo(ex, vol)
                      and ex = freeUbiDevInfo(ex, dev)
                      in Error #{err, ex, fs_st}
                    | Success (ex, ostore_st) ->
                      let fs_st = fs_st {mount_st, ostore_st, fsop_st}
                      in Success #{ex, fs_st}

fsop_unmount: FsopFsP -> RR FsopFsP () ErrCode
fsop_unmount #{ex,fs_st} =
  let is_ro = fs_st.fsop_st.is_ro !fs_st
  in if is_ro then
    (#{ex, fs_st}, Success ())
  else
   let fs_st {ostore_st, mount_st} = fs_st
   and ((ex, mount_st, ostore_st), r) = ostore_umount (ex, mount_st, ostore_st)
   in r
   | Error err ->
     (#{ex,fs_st = fs_st {mount_st,ostore_st}}, Error err)
   | Success () ->
     (#{ex,fs_st = fs_st {mount_st,ostore_st}}, Success ())

fsop_clean: FsopFsP -> ExState
fsop_clean #{ex,fs_st} =
  let fs_st {fsop_st, mount_st, ostore_st} = fs_st
  and mount_st {vol,dev,obj_sup,super} = mount_st
  and ex = deep_freeObjSuper(ex, super)
  and ex = freeObj(ex, obj_sup)
  and ex = freeUbiVolInfo(ex, vol)
  and ex = freeUbiDevInfo(ex, dev)
  and ex = freeMountState(ex, mount_st)
  and ex = ostore_clean(ex, ostore_st)
  and ex = freeFsopState(ex, fsop_st)
  and ex = freeFsState(ex, fs_st)
  in ex
