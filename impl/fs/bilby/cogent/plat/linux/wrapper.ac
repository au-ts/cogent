/*
 * Copyright 2016, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(NICTA_GPL)
 */

$esc:(#include <adt.h>)
$esc:(#include <wrapper.h>)
#include <abstract.h>
#include <c/linux/abstract-defns.h> /* In lib gum */
#include <bilbyfs.c>
#include <gum/anti/common.ac>
#include <gum/anti/log.ac>
#include <gum/anti/seq.ac>
#include <gum/anti/crc32.ac>
#include <gum/anti/wordarray.ac>
#include <gum/anti/array.ac>
#include <gum/anti/list.ac>
#include <gum/anti/rbt.ac>
#include <gum/anti/os.ac>
#include <plat/linux/alloc.ac>
#include <plat/linux/ubi.ac>
#include <plat/linux/vfs.ac>
#include <plat/linux/allocpool.ac>
#include <plat/linux/inode.ac>
#include <plat/linux/stat.ac>
#include <plat/linux/iattr.ac>
#include <plat/linux/arrayobj.ac>
#include <linux/version.h>

typedef $ty:(#VfsInode) BilbyFsVfsInode;
typedef $ty:(#RbtIndexNode) BilbyFsRbtIndexNode;
typedef $ty:(#RbtGimNode) BilbyFsRbtGimNode;
const struct inode_operations bilbyfs_dir_inode_operations;
const struct inode_operations bilbyfs_file_inode_operations;
const struct inode_operations bilbyfs_symlink_inode_operations;
const struct file_operations bilbyfs_file_operations;
const struct file_operations bilbyfs_dir_operations;
const struct address_space_operations bilbyfs_file_address_operations;

$esc:(#if LINUX_VERSION_CODE > KERNEL_VERSION(4,4,0))
#define PAGE_CACHE_SIZE  PAGE_SIZE
#define PAGE_CACHE_SHIFT PAGE_SHIFT
$esc:(#endif)

struct wrapper_data {
        struct semaphore lock;
        struct backing_dev_info bdi;
        struct super_block *vfs_sb;
        $ty:(FsState) fs_st;
        $ty:(Buffer) buf;
        $ty:(WordArray U8) wa;
        $ty:(WordArray U8) wa2;
        $ty:(VfsDirContext) vfsdirctx;
        $ty:(#VfsMountInfo) vfsmountinfo;
};

static inline void wrapper_clean(struct wrapper_data *wd)
{
        kfree(wd->wa);
        kfree(wd->wa2);
        kfree(wd->buf);
        kfree(wd->vfsdirctx);
        kfree(wd);
}

static inline struct wrapper_data *wrapper_init(void)
{
        struct wrapper_data *wd = kzalloc(sizeof(*wd));

        if (!wd)
            return NULL;
        sema_init(&wd->lock, 1);
        wd->vfs_sb = NULL;
        wd->fs_st = NULL;
        wd->wa = kzalloc(sizeof(*wd->wa));
        wd->wa2 = kzalloc(sizeof(*wd->wa2));
        wd->buf = kzalloc(sizeof(*wd->buf));
        wd->vfsdirctx = kzalloc(sizeof(*wd->vfsdirctx));
        if (!wd->wa || !wd->wa2 || !wd->buf || !wd->vfsdirctx) {
            wrapper_clean(wd);
            return NULL;
        }
        return wd;
}

static int init_inode_by_type(struct backing_dev_info *bdi, struct inode *inode)
{
        int err = 0;

        /* Disable read-ahead */
$escstm:(#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
        inode->i_mapping->backing_dev_info = bdi;
$escstm:(#endif)
        switch (inode->i_mode & S_IFMT) {
        case S_IFREG:
                inode->i_mapping->a_ops = &bilbyfs_file_address_operations;
                inode->i_op = &bilbyfs_file_inode_operations;
                inode->i_fop = &bilbyfs_file_operations;
                break;
        case S_IFDIR:
                inode->i_op  = &bilbyfs_dir_inode_operations;
                inode->i_fop = &bilbyfs_dir_operations;
                inode->i_size = $exp:bilbyFsObjInode;
                break;
        case S_IFLNK:
                inode->i_op = &bilbyfs_symlink_inode_operations;
                break;
        case S_IFBLK:
        case S_IFCHR:
        case S_IFSOCK:
        case S_IFIFO:
                bilbyfs_err("Inode type not yet supported (%x)",
                        (unsigned int)(inode->i_mode & S_IFMT));
                err = -EINVAL;
                break;
        default:
                bilbyfs_err("Unknown inode type. This should not happen!");
                err = -EINVAL;
                break;
        }
        return err;
}

static inline void inode_init_perm(struct inode *inode, const struct inode *dir,
                                   umode_t mode)
{
        inode->i_uid = current_fsuid();
        if (dir && dir->i_mode & S_ISGID) {
                inode->i_gid = dir->i_gid;
                if (S_ISDIR(mode))
                        mode |= S_ISGID;
        } else
                inode->i_gid = current_fsgid();
        inode->i_mode = mode;
}

static struct inode *bilbyfs_new_inode(struct super_block *sb,
                                       struct inode *dir, umode_t mode)
{
        struct inode *inode;
        int err;

        bilbyfs_debug("bilbyfs_new_inode(mode = 0x%x)\n", mode);
        inode = new_inode(sb);
        if (!inode) {
                bilbyfs_err("BilbyFsError: new_inode() = -ENOMEM");
                return ERR_PTR(-ENOMEM);
        }
        /* FIXME: UBIFS has the following line that doesn't seem
         * required, needs to be double checked
         */
        inode->i_mapping->nrpages = 0;
        inode_init_perm(inode, dir, mode);
        err = init_inode_by_type(sb->s_bdi, inode);
        if (!err)
                return inode;
        make_bad_inode(inode);
        iput(inode);
        bilbyfs_err("BilbyFsError: bilbyfs_new_inode(mode = 0x%x) = %d\n", mode, err);
        return ERR_PTR(err);
}

static inline int wfsop_link(struct wrapper_data *wd, struct inode *dir, const char *name, struct inode *inode)
{
    $ty:(FsopLinkP) fargs;
    $ty:(RR FsopRR () ErrCode) fret;

    fargs.ex = NULL;
    fargs.fs_st = wd->fs_st;
    fargs.vdir = ($ty:(VfsInode)) dir;
    fargs.name = wd->wa;
    fargs.name->values = (u8 *)name;
    fargs.name->len = strlen(name) + 1;
    fargs.vnode = ($ty:(VfsInode)) inode;
    fret = $exp:fsop_link(fargs);
    if (fret.p2.tag == TAG_ENUM_Error)
        return -fret.p2.Error;
    return 0;
}

static int bilbyfs_link(struct dentry *old_dentry, struct inode *dir,
                 struct dentry *dentry)
{
        struct wrapper_data *wd = dir->i_sb->s_fs_info;
        int err;

        bilbyfs_debug("bilbyfs_link (dir.ino = %lu, oldname=%.*s, name=%.*s)\n", dir->i_ino, old_dentry->d_name.len, old_dentry->d_name.name, dentry->d_name.len, dentry->d_name.name);
        down(&wd->lock);
        err = wfsop_link(wd, dir, dentry->d_name.name, old_dentry->d_inode);
        up(&wd->lock);
        if (!err) {
                ihold(old_dentry->d_inode);
                d_instantiate(dentry, old_dentry->d_inode);
        } else
          bilbyfs_err("BilbyFsError: bilbyfs_link() = %d\n", err);
        return err;
}

/* fsop_rmdir : FsopUnlinkP -> RR FsopRR () ErrCode */
static int bilbyfs_rmdir(struct inode *dir, struct dentry *dentry)
{
        struct wrapper_data *wd = dir->i_sb->s_fs_info;
        $ty:(FsopUnlinkP) fargs;
        $ty:(RR FsopRR () ErrCode) fret;

        bilbyfs_debug("bilbyfs_rmdir (dir.ino = %lu, name=%.*s)\n", dir->i_ino, dentry->d_name.len, dentry->d_name.name);
        down(&wd->lock);
        fargs.ex = NULL;
        fargs.fs_st = wd->fs_st;
        fargs.vdir = ($ty:(VfsInode)) dir;
        fargs.name = wd->wa;
        fargs.name->values = (u8 *)dentry->d_name.name;
        fargs.name->len = strlen(dentry->d_name.name) + 1;
        fargs.vnode = ($ty:(VfsInode)) dentry->d_inode;
        fret = $exp:fsop_rmdir(fargs);
        up(&wd->lock);
        if (fret.p2.tag == TAG_ENUM_Error) {
                bilbyfs_err("BilbyFsError: fsop_rmdir() = %d\n", fret.p2.Error);
                return -fret.p2.Error;
        }
        return 0;
}

static inline int wfsop_mkdir(struct wrapper_data *wd, struct inode *dir, const char *name, umode_t mode, struct inode *inode)
{
    $ty:(FsopCreateP) fargs;
    $ty:(RR FsopRR () ErrCode) fret;

    fargs.ex = NULL;
    fargs.fs_st = wd->fs_st;
    fargs.vdir = ($ty:(VfsInode)) dir;
    fargs.name = wd->wa;
    fargs.name->values = (u8 *)name;
    fargs.name->len = strlen(name) + 1;
    fargs.mode = mode;
    fargs.vnode = ($ty:(VfsInode)) inode;
    fret = $exp:fsop_mkdir(fargs);
    if (fret.p2.tag == TAG_ENUM_Error)
        return -fret.p2.Error;
    return 0;
}

static int bilbyfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
{
        struct wrapper_data *wd = dir->i_sb->s_fs_info;
        struct inode *inode;
        int err;

        bilbyfs_debug("bilbyfs_mkdir (dir.ino = %lu, name=%.*s, mode=%x)\n", dir->i_ino, dentry->d_name.len, dentry->d_name.name, mode);
        inode = bilbyfs_new_inode(dir->i_sb, dir, S_IFDIR | mode);
        if (IS_ERR(inode))
                return PTR_ERR(inode);
        down(&wd->lock);
        err = wfsop_mkdir(wd, dir, dentry->d_name.name, mode, inode);
        up(&wd->lock);
        if (!err) {
                insert_inode_hash(inode);
                d_instantiate(dentry, inode);
                return 0;
        }
        bilbyfs_err("BilbyFsError: bilbyfs_mkdir() = %d\n", err);
        make_bad_inode(inode);
        iput(inode);
        return err;
}

static inline int wfsop_symlink(struct wrapper_data *wd, struct inode *dir, const char *name, const char *symname, struct inode *inode)
{
    $ty:(FsopSymlinkP) fargs;
    $ty:(RR FsopSymlinkRR () ErrCode) fret;

    fargs.ex = NULL;
    fargs.fs_st = wd->fs_st;
    fargs.vdir = ($ty:(VfsInode)) dir;
    fargs.name = wd->wa;
    fargs.name->values = (u8 *)name;
    fargs.name->len = strlen(name) + 1;
    fargs.symname = wd->wa2;
    fargs.symname->values = (u8 *)symname;
    fargs.symname->len = strlen(symname) + 1;
    fargs.vnode = ($ty:(VfsInode)) inode;
    fret = $exp:fsop_symlink(fargs);
    if (fret.p2.tag == TAG_ENUM_Error)
        return -fret.p2.Error;
    return 0;
}

static int bilbyfs_symlink(struct inode *dir, struct dentry *dentry,
                    const char *symname)
{
        struct wrapper_data *wd = dir->i_sb->s_fs_info;
        struct inode *inode;
        int err;

        bilbyfs_debug("bilbyfs_symlink (dir.ino = %lu, name=%.*s, symname=%s)\n", dir->i_ino, dentry->d_name.len, dentry->d_name.name, symname);
        inode = bilbyfs_new_inode(dir->i_sb, dir, S_IFLNK | S_IRWXUGO);
        if (IS_ERR(inode))
                return PTR_ERR(inode);
        down(&wd->lock);
        err = wfsop_symlink(wd, dir, dentry->d_name.name, symname, inode);
        up(&wd->lock);
        if (!err) {
                insert_inode_hash(inode);
                d_instantiate(dentry, inode);
                return 0;
        } else
          bilbyfs_err("BilbyFsError: bilbyfs_symlink() = %d\n", err);
        make_bad_inode(inode);
        iput(inode);
        return err;
}

static int bilbyfs_setattr(struct dentry *dentry, struct iattr *attr)
{
        struct inode *inode = dentry->d_inode;
        struct wrapper_data *wd = inode->i_sb->s_fs_info;
        int err;
        $ty:(FsopSetattrP) fargs;
        $ty:(RR FsopSetattrRR () ErrCode) fret;

        bilbyfs_debug("bilbyfs_setattr(ino %lu, mode %#x, ia_valid %#x)\n",
                inode->i_ino, inode->i_mode, attr->ia_valid);
$escstm:(#if LINUX_VERSION_CODE > KERNEL_VERSION(4,9,0))
        err = setattr_prepare(dentry, attr);
$escstm:(#else)
        err = inode_change_ok(inode, attr);
$escstm:(#endif)

        if (err)
                return err;

        if (attr->ia_valid & ATTR_MODE) {
                if (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))
                        attr->ia_mode &= ~S_ISGID;
        }

        down(&wd->lock);
        fargs.ex = NULL;
        fargs.fs_st = wd->fs_st;
        fargs.iattr = ($ty:(VfsIattr))attr;
        fargs.vnode = ($ty:(VfsInode))inode;
        fret = $exp:fsop_setattr(fargs);
        up(&wd->lock);
        if (fret.p2.tag == TAG_ENUM_Error) {
                err = -fret.p2.Error;
                bilbyfs_err("BilbyFsError: fsop_setattr() = %d\n", err);
                return err;
        }
        /* truncate_setsize calls i_size_write and frees pages in the
         * page cache */
        if (attr->ia_valid & ATTR_SIZE)
                truncate_setsize(inode, inode->i_size);
        if (attr->ia_valid & ATTR_ATIME) {
$escstm:(#if LINUX_VERSION_CODE > KERNEL_VERSION(4,19,0))
                inode->i_atime = timespec64_trunc(inode->i_atime,
                                                  inode->i_sb->s_time_gran);
$escstm:(#else)
                inode->i_atime = timespec_trunc(inode->i_atime,
                                                inode->i_sb->s_time_gran);
$escstm:(#endif)
        }

        if (attr->ia_valid & ATTR_MTIME)
$escstm:(#if LINUX_VERSION_CODE > KERNEL_VERSION(4,19,0))
                inode->i_mtime = timespec64_trunc(inode->i_mtime,
                                                  inode->i_sb->s_time_gran);
$escstm:(#else)
                inode->i_mtime = timespec_trunc(inode->i_mtime,
                                                inode->i_sb->s_time_gran);
$escstm:(#endif)
        if (attr->ia_valid & ATTR_CTIME)
$escstm:(#if LINUX_VERSION_CODE > KERNEL_VERSION(4,19,0))
                inode->i_ctime = timespec64_trunc(inode->i_ctime,
                                                  inode->i_sb->s_time_gran);
$escstm:(#else)
                inode->i_ctime = timespec_trunc(inode->i_ctime,
                                                inode->i_sb->s_time_gran);
$escstm:(#endif)
        return 0;
}

/*
type FsopGetattrP = #{ex:SysState, fs_st: FsState, stat: VfsStat, vnode: VfsInode!}
type FsopGetattrR = #{ex:SysState, fs_st: FsState, stat: VfsStat}
fsop_getattr: FsopGetattrP -> FsopGetattrR
*/
$esc:(#if LINUX_VERSION_CODE < KERNEL_VERSION(4,4,0))
static int bilbyfs_getattr(struct vfsmount *mnt, struct dentry *dentry,
                           struct kstat *stat)
{
       struct inode *inode = dentry->d_inode;
       struct wrapper_data *wd = inode->i_sb->s_fs_info;
       int err; 
       $ty:(FsopGetattrP) fargs;

       down(&wd->lock);
       fargs.ex = NULL;
       fargs.fs_st = wd->fs_st;
       fargs.stat = ($ty:(VfsStat))stat;
       fargs.vnode = ($ty:(VfsInode)) inode;
       $exp:fsop_getattr(fargs);
       bilbyfs_debug("bilbyfs_getattr: {mode=0%o}\n", stat->mode);
       stat->dev = dentry->d_sb->s_dev;
       stat->rdev = inode->i_rdev;
       up(&wd->lock);
       return 0;
}
$esc:(#else)
int bilbyfs_getattr(const struct path *path, struct kstat *stat,
                    u32 mask, unsigned int flags)
{
        struct dentry *dentry = path->dentry;
        struct inode *inode = d_inode(dentry);
        struct wrapper_data *wd = inode->i_sb->s_fs_info;
        $ty:(FsopGetattrP) fargs;

        down(&wd->lock);
        fargs.ex = NULL;
        fargs.fs_st = wd->fs_st;
        fargs.stat = ($ty:(VfsStat))stat;
        fargs.vnode = ($ty:(VfsInode)) inode;
        $exp:fsop_getattr(fargs);
        bilbyfs_debug("bilbyfs_getattr: {mode=0%o}\n", stat->mode);
        stat->dev = dentry->d_sb->s_dev;
        stat->rdev = inode->i_rdev;
        up(&wd->lock);

        return 0;
}
$esc:(#endif)



/*
type FsopCreateP = #{ex:SysState, fs_st: FsState, vdir: VfsInode, name: (WordArray U8)!, mode: VfsMode, vnode: VfsInode take fs}
fsop_create : FsopCreateP -> RR FsopRR () ErrCode
*/
static inline int wfsop_create(struct wrapper_data *wd, struct inode *dir, const char *name, umode_t mode, bool excl, struct inode *inode)
{
    $ty:(FsopCreateP) fargs;
    $ty:(RR FsopRR () ErrCode) fret;

    fargs.ex = NULL;
    fargs.fs_st = wd->fs_st;
    fargs.vdir = ($ty:(VfsInode)) dir;
    fargs.name = wd->wa;
    fargs.name->values = (u8 *)name;
    fargs.name->len = strlen(name) + 1;
    fargs.mode = mode;
    fargs.vnode = ($ty:(VfsInode)) inode;
    fret = $exp:fsop_create(fargs);
    if (fret.p2.tag == TAG_ENUM_Error)
        return -fret.p2.Error;
    return 0;
}

static int bilbyfs_create(struct inode *dir, struct dentry *dentry,
                          umode_t mode, bool excl)
{
        struct wrapper_data *wd = dir->i_sb->s_fs_info;
        struct inode *inode;
        int err;

        bilbyfs_debug("bilbyfs_create (dir.ino = %lu, name=%.*s, mode=%x)\n", dir->i_ino, dentry->d_name.len, dentry->d_name.name, mode);
        inode = bilbyfs_new_inode(dir->i_sb, dir, S_IFREG | mode);
        if (IS_ERR(inode))
                return PTR_ERR(inode);
        down(&wd->lock);
        err = wfsop_create(wd, dir, dentry->d_name.name, mode, excl, inode);
        up(&wd->lock);
        if (!err) {
                insert_inode_hash(inode);
                d_instantiate(dentry, inode);
                return 0;
        } else
          bilbyfs_err("BilbyFsError: fsop_create() = %d\n", err);
        make_bad_inode(inode);
        iput(inode);
        return err;
}

/*
type FsopUnlinkP = #{ex:SysState, fs_st:FsState, vdir:VfsInode, name:(WordArray U8)!, vnode:VfsInode}
type FsopE' = #{err:ErrCode, ex:SysState, fs_st:FsState, vdir:VfsInode, vnode:VfsInode}
fsop_unlink : FsopUnlinkP -> R FsopR FsopE'
*/

static int bilbyfs_unlink(struct inode *dir, struct dentry *dentry)
{
        struct wrapper_data *wd = dir->i_sb->s_fs_info;
        $ty:(FsopUnlinkP) fargs;
        $ty:(RR FsopRR () ErrCode) fret;

        bilbyfs_debug("bilbyfs_unlink(%s)\n", dentry->d_name.name);
        down(&wd->lock);
        fargs.ex = NULL;
        fargs.fs_st = wd->fs_st;
        fargs.vdir = ($ty:(VfsInode)) dir;
        fargs.name = wd->wa;
        fargs.name->values = (u8 *)dentry->d_name.name;
        fargs.name->len = strlen(dentry->d_name.name) + 1;
        fargs.vnode = ($ty:(VfsInode)) dentry->d_inode;
        fret = $exp:fsop_unlink(fargs);
        up(&wd->lock);
        if (fret.p2.tag == TAG_ENUM_Error) {
                bilbyfs_err("BilbyFsError: fsop_unlink() = %d\n", fret.p2.Error);
                return -fret.p2.Error;
        }
        return 0;
}

/*
type FsopRenameP = #{ex:SysState, fs_st:FsState, vdir:VfsInode, old_name:(WordArray U8)!, old_vnode:VfsInode, new_name: (WordArray U8)!, opt_new_vnode: Option VfsInode}
type FsopRenameR = #{ex:SysState, fs_st:FsState, vdir:VfsInode, old_vnode:VfsInode, opt_new_vnode: Option VfsInode}
type FsopRenameE = #{err:ErrCode, ex: SysState, fs_st:FsState, vdir:VfsInode, old_vnode:VfsInode, opt_new_vnode: Option VfsInode}
fsop_rename: FsopRenameP -> R FsopRenameR FsopRenameE

RR FsopRenameRR () ErrCode
*/
static int wfsop_rename(struct wrapper_data *wd, struct inode *dir,
                        const char *old_name, struct inode *old_inode,
                        const char *new_name, struct inode *new_inode)
{
    $ty:(FsopRenameP) fargs;
    $ty:(RR FsopRenameRR () ErrCode) fret;

    bilbyfs_debug("wfsop_rename(%s, %s)\n", old_name, new_name);
    fargs.ex = NULL;
    fargs.fs_st = wd->fs_st;
    fargs.vdir = ($ty:(VfsInode)) dir;
    fargs.old_name = wd->wa;
    fargs.old_name->values = (u8 *)old_name;
    fargs.old_name->len = strlen(old_name) + 1;
    fargs.old_vnode = ($ty:(VfsInode)) old_inode;

    fargs.new_name = wd->wa2;
    fargs.new_name->values = (u8 *)new_name;
    fargs.new_name->len = strlen(new_name) + 1;
    if (new_inode) {
        fargs.opt_new_vnode.tag = TAG_ENUM_Some;
        fargs.opt_new_vnode.Some = ($ty:(VfsInode)) new_inode;
    } else {
        fargs.opt_new_vnode.tag = TAG_ENUM_None;
    }
    fret = $exp:fsop_rename(fargs);
    if (fret.p2.tag == TAG_ENUM_Error)
        return -fret.p2.Error;
    return 0;
}

static int wfsop_move(struct wrapper_data *wd, struct inode *old_dir,
                      const char *old_name, struct inode *old_inode,
                      struct inode *new_dir, const char *new_name,
                      struct inode *new_inode)
{
    $ty:(FsopMoveP) fargs;
    $ty:(RR FsopMoveRR () ErrCode) fret;

    bilbyfs_debug("wfsop_move(%s, %s)\n", old_name, new_name);
    fargs.ex = NULL;
    fargs.fs_st = wd->fs_st;
    fargs.old_vdir = ($ty:(VfsInode)) old_dir;
    fargs.old_name = wd->wa;
    fargs.old_name->values = (u8 *)old_name;
    fargs.old_name->len = strlen(old_name) + 1;
    fargs.old_vnode = ($ty:(VfsInode)) old_inode;

    fargs.new_vdir = ($ty:(VfsInode)) new_dir;
    fargs.new_name = wd->wa2;
    fargs.new_name->values = (u8 *)new_name;
    fargs.new_name->len = strlen(new_name) + 1;
    if (new_inode) {
        fargs.opt_new_vnode.tag = TAG_ENUM_Some;
        fargs.opt_new_vnode.Some = ($ty:(VfsInode)) new_inode;
    } else {
        fargs.opt_new_vnode.tag = TAG_ENUM_None;
    }
    fret = $exp:fsop_move(fargs);
    if (fret.p2.tag == TAG_ENUM_Error)
        return -fret.p2.Error;
    return 0;
}


$esc:(#if LINUX_VERSION_CODE < KERNEL_VERSION(4,4,0))
static int bilbyfs_rename(struct inode *old_dir, struct dentry *old_dentry,
                          struct inode *new_dir, struct dentry *new_dentry)
{
        struct wrapper_data *wd = old_dir->i_sb->s_fs_info;
        int err;

        down(&wd->lock);
        if (old_dir == new_dir)
            err = wfsop_rename(wd, old_dir, old_dentry->d_name.name,
                               old_dentry->d_inode, new_dentry->d_name.name,
                               new_dentry->d_inode);
        else
            err = wfsop_move(wd, old_dir, old_dentry->d_name.name,
                             old_dentry->d_inode, new_dir, new_dentry->d_name.name,
                             new_dentry->d_inode);
        up(&wd->lock);
        if (err)
          bilbyfs_err("BilbyFsError: bilbyfs_rename() = %d\n", err);
        return err;
}
$esc:(#else)
static int bilbyfs_rename(struct inode *old_dir, struct dentry *old_dentry,
                          struct inode *new_dir, struct dentry *new_dentry,
                          unsigned int flags)
{
        struct wrapper_data *wd = old_dir->i_sb->s_fs_info;
        int err;

        down(&wd->lock);
        if (old_dir == new_dir)
            err = wfsop_rename(wd, old_dir, old_dentry->d_name.name,
                               old_dentry->d_inode, new_dentry->d_name.name,
                               new_dentry->d_inode);
        else
            err = wfsop_move(wd, old_dir, old_dentry->d_name.name,
                             old_dentry->d_inode, new_dir, new_dentry->d_name.name,
                             new_dentry->d_inode);
        up(&wd->lock);
        if (err)
          bilbyfs_err("BilbyFsError: bilbyfs_rename() = %d\n", err);
        return err;
}
$esc:(#endif)

/*
type FsopReadPageP = #{ex:SysState, fs_st: FsState, vnode: VfsInode, block: OSPageOffset, addr: Buffer}
type FsopReadPageR = #{ex:SysState, fs_st: FsState, vnode: VfsInode, addr: Buffer}
type FsopReadPageE = #{err:ErrCode, ex:SysState, fs_st: FsState, vnode: VfsInode, addr: Buffer}

fsop_readpage: FsopReadPageP -> RR FsopReadPageRR () ErrCode 
*/
static int wfsop_readpage(struct wrapper_data *wd, struct inode *inode, $ty:(OSPageOffset) index, void *addr)
{
    $ty:(FsopReadPageP) fargs;
    $ty:(RR FsopReadPageRR () ErrCode) fret;

    bilbyfs_debug("bilbyfs_readpage(index=%llu, ino=%lu)\n", index, inode->i_ino);
    fargs.ex = NULL;
    fargs.fs_st = wd->fs_st;
    fargs.vnode = ($ty:(VfsInode)) inode;
    fargs.block = index;
    fargs.addr = wd->buf;
    fargs.addr->data = wd->wa;
    fargs.addr->bound = PAGE_CACHE_SIZE;
    fargs.addr->data->values = addr;
    fargs.addr->data->len = PAGE_CACHE_SIZE;

    fret = $exp:fsop_readpage(fargs);
    if (fret.p2.tag == TAG_ENUM_Error)
        return -fret.p2.Error;
    return 0;
}

static int bilbyfs_readpage(struct file *filp, struct page *page)
{
        struct inode *inode = page->mapping->host;
        struct wrapper_data *wd = inode->i_sb->s_fs_info;
        void *addr;
        int err;

        bilbyfs_debug("[0] bilbyfs_readpage(page = %p)\n", page);
        addr = kmap(page);
        down(&wd->lock);
        err = wfsop_readpage(wd, inode, page->index, addr);
        up(&wd->lock);
        if (err == -ENOENT) {
                 SetPageChecked(page);
                 err = 0;
        }
        if (err) {
                ClearPageUptodate(page);
                SetPageError(page);
                flush_dcache_page(page);
                kunmap(page);
                unlock_page(page);
                bilbyfs_err("BilbyFsError: bilbyfs_readpage() = %d\n", err);
                return err;
        }
        SetPageUptodate(page);
        ClearPageError(page);
        flush_dcache_page(page);
        kunmap(page);
        unlock_page(page);
        bilbyfs_debug("[2] bilbyfs_readpage() = %d\n", 0);
        return 0;
}

/*
type FsopWriteP = #{ex:SysState, fs_st: FsState, vnode: VfsInode, pos: OSPageOffset, len:U32, addr: Buffer}
type FsopWriteR = #{ex:SysState, fs_st: FsState, vnode: VfsInode, addr: Buffer}
type FsopWriteE = #{err:ErrCode, ex:SysState, fs_st: FsState, vnode: VfsInode, addr: Buffer}
fsop_write_begin: FsopWriteP -> RR FsopWriteRR () ErrCode
*/
static inline int wfsop_write_begin(struct wrapper_data *wd, struct inode *inode, loff_t pos, unsigned len, void *addr)
{
        $ty:(FsopWriteP) fargs;
        $ty:(RR FsopWriteRR () ErrCode) fret;

        fargs.ex = NULL;
        fargs.fs_st = wd->fs_st;
        fargs.vnode = ($ty:(VfsInode))inode;
        fargs.pos = pos;
        fargs.len = len;
        fargs.addr = wd->buf;
        fargs.addr->data = wd->wa;
        fargs.addr->bound = PAGE_CACHE_SIZE;
        fargs.addr->data->values = addr;
        fargs.addr->data->len = PAGE_CACHE_SIZE;

        fret = $exp:(fsop_write_begin)(fargs);
        if (fret.p2.tag == TAG_ENUM_Error)
            return -fret.p2.Error;
        return 0;
}

static int bilbyfs_write_begin(struct file *filp, struct address_space *mapping,
                               loff_t pos, unsigned len, unsigned flags,
                               struct page **pagep, void **fsdata)
{
        struct page *page;
        struct inode *inode = mapping->host;
        struct wrapper_data *wd = inode->i_sb->s_fs_info;
        pgoff_t block = pos >> $exp:(bilbyFsBlockShift);
        void *addr;
        int err = 0;

        bilbyfs_debug("[0] bilbyfs_write_begin()\n");
        page = grab_cache_page_write_begin(mapping, block, flags);
        if (!page)
                return -ENOMEM;

        addr = kmap(page);

        if (!PageUptodate(page)) { /* overwriting data */
                /* FIXME: optimisation, check whether the entire page is gonna be
                 * overwritten and set PageChecked accordingly
                 */
                down(&wd->lock);
                err = wfsop_write_begin(wd, inode, pos, len, addr);
                up(&wd->lock);
                if (err) {
                        ClearPageUptodate(page);
                        SetPageError(page);
                        kunmap(page);
                        unlock_page(page);
$escstm:(#if LINUX_VERSION_CODE < KERNEL_VERSION(4,4,0))
                        page_cache_release(page);
$escstm:(#else)
                        put_page(page);
$escstm:(#endif)
                        bilbyfs_err("BilbyFsError: bilbyfs_write_begin() = %d\n", err);
                        return err;
                }
        }
        SetPageUptodate(page);
        ClearPageError(page);
        kunmap(page);
        *pagep = page;
        bilbyfs_debug("[2] bilbyfs_write_begin() = 0\n");
        return 0;
}

static int bilbyfs_write_end_writeback(struct file *filp, struct address_space *mapping,
                                       loff_t pos, unsigned len, unsigned copied,
                                       struct page *page, void *fsdata)
{
        struct inode *inode = mapping->host;
        loff_t end_pos = pos + len;
        int appending = !!(end_pos > inode->i_size);

        bilbyfs_assert(PAGE_CACHE_SIZE == $exp:(bilbyFsBlockSize));
        bilbyfs_debug("[S] bilbyfs_write_end_writeback(pos = %llu, len =%u, copied = %u)\n",pos, len, copied);
        BUG_ON(!PageUptodate(page));
        bilbyfs_assert(len <= PAGE_CACHE_SIZE);
        if (copied < len) {
                /* 23/10/2013: This can safely be ignored because BilbyFs
                 * always read a PAGE_CACHE_SIZE data block in write_begin
                 * which means that as long as @len is < PAGE_CACHE_SIZE
                 * we have read enough data.
                 * FIXME: Can this ever happen without concurrency?
                 */
                bilbyfs_debug("copied < len : %u < %u. But it's safe to ignore as write_begin read %lu bytes.\n",
                              copied, len, PAGE_CACHE_SIZE);
        }
        __set_page_dirty_nobuffers(page);
        if (appending) {
                i_size_write(inode, end_pos);
                /*
                 * Note, we do not set @I_DIRTY_PAGES (which means that the
                 * inode has dirty pages), this has been done in
                 * '__set_page_dirty_nobuffers()'.
                 */
                __mark_inode_dirty(inode, I_DIRTY_DATASYNC);
        }
        unlock_page(page);
$escstm:(#if LINUX_VERSION_CODE < KERNEL_VERSION(4,4,0))
        page_cache_release(page);
$escstm:(#else)
        put_page(page);
$escstm:(#endif)
        bilbyfs_debug("[1] bilbyfs_write_end_writeback() = %d (nb bytes copied)\n", copied);
        return copied;
}

/*
type FsopWriteP = #{ex:SysState, fs_st: FsState, vnode: VfsInode, pos: OSPageOffset, len:U32, addr: Buffer}
type FsopWriteR = #{ex:SysState, fs_st: FsState, vnode: VfsInode, addr: Buffer}
type FsopWriteE = #{err:ErrCode, ex:SysState, fs_st: FsState, vnode: VfsInode, addr: Buffer}
fsop_write_end: FsopWriteP -> RR FsopWriteRR () ErrCode
fsop_write_end #{ex, fs_st, vnode, pos, len, addr} =
*/
static int wfsop_write_end(struct wrapper_data *wd, struct inode *inode, loff_t pos, int len, void *kaddr)
{
        $ty:(FsopWriteP) fargs;      
        $ty:(RR FsopWriteRR () ErrCode) fret;

        bilbyfs_debug("bilbyfs_write_end(pos=%llu, len=%d)\n", pos, len);
        fargs.ex = NULL;
        fargs.fs_st = wd->fs_st;
        fargs.vnode = ($ty:(VfsInode))inode;
        fargs.pos = pos;
        fargs.len = len;
        fargs.addr = wd->buf;
        fargs.addr->data = wd->wa;
        fargs.addr->bound = PAGE_CACHE_SIZE;
        fargs.addr->data->values = kaddr;
        fargs.addr->data->len = PAGE_CACHE_SIZE;

        fret = $exp:(fsop_write_end)(fargs);
        if (fret.p2.tag == TAG_ENUM_Error)
            return -fret.p2.Error;
        return 0;
}

static int bilbyfs_writepage(struct page *page, struct writeback_control *wbc)
{
        struct inode *inode = page->mapping->host;
        struct wrapper_data *wd = inode->i_sb->s_fs_info;
        loff_t i_size =  i_size_read(inode);
        pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;
        loff_t pos = page->index << PAGE_CACHE_SHIFT;
        int err, len = i_size & (PAGE_CACHE_SIZE - 1);
        void *kaddr;

        bilbyfs_debug("bilbyfs_writepage()\n");

        /* Is the page fully outside @i_size? (truncate in progress) */
        if (page->index > end_index || (page->index == end_index && !len)) {
                unlock_page(page);
                return 0;
        }
        bilbyfs_debug("write-to-disk\n");
        if (page->index != end_index)
                len = PAGE_CACHE_SIZE;
        set_page_writeback(page);
        kaddr = kmap_atomic(page);
        memset(kaddr + len, 0, PAGE_CACHE_SIZE - len);
        flush_dcache_page(page);
        kunmap_atomic(kaddr);

        kaddr = kmap(page);
        down(&wd->lock);
        err = wfsop_write_end(wd, inode, pos, len, kaddr);
        up(&wd->lock);
        kunmap(page);
        unlock_page(page);
        end_page_writeback(page);

        if (err)
                bilbyfs_err("BilbyFsError: bilbyfs_writepage() = %d\n", err);
        return err;
}

/*
type FsopFollowLinkP = #{ex:SysState, fs_st: FsState, vnode: VfsInode, path: Buffer}
type FsopFollowLinkE = #{err:ErrCode, ex:SysState, fs_st: FsState, vnode: VfsInode, path: Buffer}
fsop_follow_link: FsopFollowLinkP -> RR FsopFollowLinkP () ErrCode
*/
$esc:(#if LINUX_VERSION_CODE > KERNEL_VERSION(4,5,0))
const char *bilbyfs_get_link(struct dentry *dentry, struct inode *inode,
                             struct delayed_call *done)
{
        struct wrapper_data *wd = dentry->d_inode->i_sb->s_fs_info;
        int err;
        const char *link = page_get_link(dentry, inode, done);
        /* XXX: Need to implement this in Cogent */
        bilbyfs_debug("bilbyfs_get_link() \n");
        if (!IS_ERR(link) && !*link) {
                do_delayed_call(done);
                clear_delayed_call(done);
                link = ERR_PTR(-ENOENT);
        }

        return link;
}
$esc:(#else)
static int wfsop_follow_link(struct wrapper_data *wd, struct inode *inode, void *page)
{
        $ty:(FsopFollowLinkP) fargs;
        $ty:(RR FsopFollowLinkP () ErrCode) fret;

        fargs.ex = NULL;
        fargs.fs_st = wd->fs_st;
        fargs.vnode = ($ty:(VfsInode)) inode;
        fargs.path = wd->buf;
        fargs.path->data = wd->wa;
        fargs.path->data->values = page;
        fargs.path->data->len = PATH_MAX;
        fret = $exp:fsop_follow_link(fargs);
        if (fret.p2.tag == TAG_ENUM_Error)
            return -fret.p2.Error;
        return 0;
}

static void *bilbyfs_follow_link(struct dentry *dentry, struct nameidata *nd)
{
        struct wrapper_data *wd = dentry->d_inode->i_sb->s_fs_info;
        struct inode *inode = dentry->d_inode;
        int err;

        bilbyfs_debug("bilbyfs_follow_link() \n");
        if (!inode->i_private) {
                inode->i_private = kmalloc(PATH_MAX);
                if (!inode->i_private)
                        return ERR_PTR(-ENOMEM);

                down(&wd->lock);
                err = wfsop_follow_link(wd, dentry->d_inode, inode->i_private);
                up(&wd->lock);
                if (err) {
                        bilbyfs_err("BilbyFsError: bilbyfs_follow_link() = %d\n", err);
                        kfree(inode->i_private);
                        return ERR_PTR(err);
                }
        }
$escstm:(#if LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0))
        nd_set_link(nd, inode->i_private);
$escstm:(#endif)
        return NULL;
}
$esc:(#endif)

/*
type ReadDirParams = #{ex:SysState, fs_st:FsState, vctx:VfsDirContext, opt_rdctx: Option BilbyFsReaddirContext}
fsop_readdir: (ReadDirParams, VfsInode!) -> RR ReadDirParams () ErrCode
*/
static int wfsop_readdir(struct wrapper_data *wd, struct inode *dir, struct dir_context *ctx,
                        $ty:(BilbyFsReaddirContext)* pctx)
{
        $ty:((ReadDirParams, VfsInode!)) fargs;
        $ty:(RR ReadDirParams () ErrCode) fret;

        fargs.p1.ex = NULL;
        fargs.p1.fs_st = wd->fs_st;
        fargs.p1.vctx = wd->vfsdirctx;
        fargs.p1.vctx->os = ctx;
        fargs.p1.vctx->pos = ctx->pos;
        if (*pctx) {
            fargs.p1.opt_rdctx.tag = TAG_ENUM_Some;
            fargs.p1.opt_rdctx.Some = *pctx;
        } else {
            fargs.p1.opt_rdctx.tag = TAG_ENUM_None;
        }
        fargs.p2 = ($ty:(VfsInode))dir;
        
        fret = $exp:fsop_readdir(fargs);
        *pctx = fret.p1.opt_rdctx.tag == TAG_ENUM_None ? NULL : fret.p1.opt_rdctx.Some;
        if (fret.p2.tag == TAG_ENUM_Error)
            return -fret.p2.Error;
        return 0;
}

static int bilbyfs_readdir(struct file *file, struct dir_context *ctx)
{
        struct dentry *dentry = file->f_path.dentry;
        struct inode *dir = dentry->d_inode;
        struct wrapper_data *wd = dir->i_sb->s_fs_info;
        int err;

        bilbyfs_debug("bilbyfs_readdir (dir.ino = %lu, name=%.*s, pos=%lld)\n",
                        dir->i_ino, dentry->d_name.len, dentry->d_name.name, ctx->pos);
        if (ctx->pos == 2) /* pos == 2 means an error occured */
                return 0;
        if (ctx->pos < 2) {
                if (!dir_emit_dots(file, ctx))
                        return 0;
                ctx->pos = 3;
        }
        down(&wd->lock);
        err = wfsop_readdir(wd, dir, ctx, ($ty:(BilbyFsReaddirContext)*) &file->private_data);
        up(&wd->lock);
        if (err) {
                bilbyfs_err("BilbyFsError: bilbyfs_readdir() = %d\n", err);
                ctx->pos = 2;
                return err;
        }
        return 0;
}

static int bilbyfs_dir_release(struct inode *dir, struct file *file)
{
        struct wrapper_data *wd = dir->i_sb->s_fs_info;
        $ty:((SysState, Option BilbyFsReaddirContext)) fargs;

        fargs.p1 = NULL;
        if (file->private_data) {
            fargs.p2.tag = TAG_ENUM_Some;
            fargs.p2.Some = ($ty:(BilbyFsReaddirContext))file->private_data;
        } else {
            fargs.p2.tag = TAG_ENUM_None;
        }
        bilbyfs_debug("bilbyfs_dir_release()\n");
        down(&wd->lock);
        $exp:fsop_dir_release(fargs);
        up(&wd->lock);
        file->private_data = NULL;
        return 0;
}

static loff_t bilbyfs_dir_llseek(struct file *file, loff_t offset, int origin)
{
        struct inode *inode = file->f_path.dentry->d_inode;
        struct wrapper_data *wd = inode->i_sb->s_fs_info;
        int err;
        /* When a directory is seeked 2 thing:
         * - The current bri becomes useless
         * - Seeking a directory is moronic, we do not support
         * FIXME: Check whether not supporting is acceptable
         * The alternative is to ignore, worst case hack something
         * around to emulate.
         */
        bilbyfs_err("Warning: bilbyfs_dir_llseek(), this function is deprecated!");
        down(&wd->lock);
        err = bilbyfs_dir_release(inode, file);
        up(&wd->lock);
        return err;
}

int bilbyfs_statfs(struct dentry *dentry, struct kstatfs *kstat)
{
        struct wrapper_data *wd = dentry->d_inode->i_sb->s_fs_info;
        unsigned long long free;
        unsigned long long avail;
        u32 eb_size = wd->fs_st->mount_st->super->eb_size;
        int err;

        bilbyfs_debug("bilbyfs_statfs(NOT) = NotImpl\n");
        down(&wd->lock);
        free = wd->fs_st->ostore_st->fsm_st->nb_free_eb * eb_size;
        avail = (wd->fs_st->mount_st->super->nb_eb - wd->fs_st->ostore_st->fsm_st->nb_free_eb) * eb_size;
        bilbyfs_err("fsop_statfs(): free space %llu bytes (%llu blocks), available space %llu bytes (%llu blocks)",
                free, free >> $exp:bilbyFsBlockShift, avail, avail >> $exp:bilbyFsBlockShift);

        kstat->f_type = $exp:bilbyFsMagic;
        kstat->f_bsize = $exp:bilbyFsBlockSize;
        kstat->f_blocks = wd->fs_st->mount_st->super->nb_eb * eb_size;
        kstat->f_blocks /= $exp:bilbyFsBlockSize;
        kstat->f_bfree = free >> $exp:bilbyFsBlockShift;
        kstat->f_bavail = avail >> $exp:bilbyFsBlockShift;
        bilbyfs_debug("freeblocks = %llu, availblocks = %llu\n", (u64) kstat->f_bfree, (u64) kstat->f_bavail);
        kstat->f_files = 0;
        kstat->f_ffree = 0;
        kstat->f_namelen = $exp:bilbyFsMaxNameLen;
        kstat->f_fsid.val[0] = 54;
        kstat->f_fsid.val[1] = 42;
        bilbyfs_assert(kstat->f_bfree <= kstat->f_blocks);
        bilbyfs_assert(kstat->f_bavail <= kstat->f_bfree);

        /*FIXME: implement in COGENT*/ 
        up(&wd->lock);
        return err;
}

/*
type FsopFsP = #{ex:SysState, fs_st: FsState}
type FsopFsE = #{err:ErrCode, ex:SysState, fs_st: FsState}
fsop_sync_fs: FsopFsP -> R FsopFsP FsopFsE
*/
static int wfsop_sync_fs(struct wrapper_data *wd, struct super_block *sb, int wait)
{
        $ty:(FsopFsP) fargs;
        $ty:(RR FsopFsP () ErrCode) fret;

        fargs.ex = NULL;
        fargs.fs_st = wd->fs_st;
        fret = $exp:fsop_sync_fs(fargs);
        if (fret.p2.tag == TAG_ENUM_Error)
            return -fret.p2.Error;
        return 0;
}

static int bilbyfs_sync_fs(struct super_block *sb, int wait)
{
        struct wrapper_data *wd = sb->s_fs_info;
        int err;

        down(&wd->lock);
        bilbyfs_debug("bilbyfs_sync_fs() \n");
        err = wfsop_sync_fs(wd, sb, wait);
        up(&wd->lock);
        if (err)
          bilbyfs_err("BilbyFsError: bilbyfs_sync_fs() = %d\n", err);

        /*
        err = ubi_sync(wd->fs_st->ostore_st->ubi_vol->ubi_num);
        if (err)
          bilbyfs_err("BilbyFsError: ubi_sync() = %d\n", err);
        */
        return err;
}

/*
fsop_iget: FsopIgetP -> RR FsopIgetRR () ErrCode
*/

static int wfsop_iget(struct wrapper_data *wd, unsigned long inum, struct inode *inode)
{
    $ty:(FsopIgetP) fargs;
    $ty:(RR FsopIgetRR () ErrCode) fret;
    
    bilbyfs_debug("wfsop_iget(%lu)\n", inum);
    fargs.ex = NULL;
    fargs.fs_st = wd->fs_st;
    fargs.inum = inum;
    fargs.vnode = ($ty:(VfsInode))inode;
    fret = $exp:fsop_iget(fargs);
    return (fret.p2.tag == TAG_ENUM_Error ? -fret.p2.Error : 0);
}

static struct inode *bilbyfs_iget(struct wrapper_data *wd, unsigned long inum)
{
        struct inode *inode;
        int err = 0;

        bilbyfs_assert(wd->vfs_sb);
        inode = iget_locked(wd->vfs_sb, inum);
        if (!inode)
                return ERR_PTR(-ENOMEM);
        if (!(inode->i_state & I_NEW))
                return inode;
        down(&wd->lock);
        err = wfsop_iget(wd, inum, inode);
        up(&wd->lock);
        if (!err) {
                init_inode_by_type(wd->vfs_sb->s_bdi, inode);
                unlock_new_inode(inode);
                return inode;
        }
        bilbyfs_err("BilbyFsError: fsop_iget(ino=%lu) = %d\n", inum, err);
        iget_failed(inode);
        return ERR_PTR(err);
}

/*

type FsopLookupP = #{ex:SysState, fs_st:FsState, vdir:VfsInode, name:CString!}
type FsopLookupRR = #{ex:SysState, fs_st:FsState, vdir:VfsInode}
fsop_lookup: FsopLookupP -> RR FsopLookupRR VfsIno ErrCode
*/
static inline int wfsop_lookup(struct wrapper_data *wd, struct inode *dir, const char*name, ino_t *inum)
{
        $ty:(FsopLookupP) fargs;
        $ty:(RR FsopLookupRR VfsIno ErrCode) fret;

        fargs.ex = NULL;
        fargs.fs_st = wd->fs_st;
        fargs.vdir = ($ty:(VfsInode))dir;
        fargs.name = wd->wa;
        fargs.name->values = (u8 *)name;
        fargs.name->len = strlen(name) + 1;
        fret = $exp:fsop_lookup(fargs);
        bilbyfs_debug("bilbyfs_lookup(dir.ino = %lu, name=%.*s) = %d\n", dir->i_ino, (int)strlen(name), name,
					  fret.p2.tag == TAG_ENUM_Error ? -fret.p2.Error : 0);
        if (fret.p2.tag == TAG_ENUM_Error)
                return -fret.p2.Error;
        *inum = fret.p2.Success;
        return 0;
}

static struct dentry *bilbyfs_lookup(struct inode *dir, struct dentry *dentry,
                                     unsigned int flags)
{
        struct wrapper_data *wd = dir->i_sb->s_fs_info;
        struct inode *inode;
        ino_t inum;
        int err;

        down(&wd->lock);
        err = wfsop_lookup(wd, dir, dentry->d_name.name, &inum);
        up(&wd->lock);
        if (err == -ENOENT) {
                return NULL;
        }
        if (!err) {
                inode = bilbyfs_iget(wd, inum);
                if (!IS_ERR(inode)) {
                        d_add(dentry, inode);
                        return NULL;
                }
                err = PTR_ERR(inode);
        }
        bilbyfs_err("BilbyError: bilbyfs_lookup(dir.ino = %lu, name=%.*s, flags=%x)=%d\n", dir->i_ino, dentry->d_name.len, dentry->d_name.name, flags, err);
        return ERR_PTR(err);
}


/**
 * bilbyfs_unmount - unmount BilbyFs
 * @bi: global fs info
 *
fsop_unmount: FsopFsP -> R FsopFsP FsopFsE
 */
static void bilbyfs_unmount(struct wrapper_data *wd)
{
        $ty:(FsopFsP) fargs;

        down(&wd->lock);
        fargs.ex = NULL;
        fargs.fs_st = wd->fs_st;
        bilbyfs_debug("bilbyfs_unmount()\n");
        $exp:fsop_unmount(fargs);
        up(&wd->lock);
}

static void bilbyfs_put_super(struct super_block *sb)
{
        struct wrapper_data *wd = sb->s_fs_info;

        bilbyfs_debug("bilbyfs_put_super()\n");
        bilbyfs_unmount(wd);
$escstm:(#if LINUX_VERSION_CODE < KERNEL_VERSION(4,4,0))
        bdi_destroy(sb->s_bdi);
$escstm:(#endif)
}


enum {
        BilbyFs_Opt_no_summary,
        BilbyFs_Opt_compr,
        BilbyFs_Opt_end,
};

static const match_table_t bilbyfs_options = {
        {BilbyFs_Opt_no_summary, "no_summary"},
        {BilbyFs_Opt_compr, "compr=%s"},
        {BilbyFs_Opt_end, NULL},
};

static int bilbyfs_parse_options(struct wrapper_data *wd, char *options)
{
        char *s;
        substring_t args[MAX_OPT_ARGS];

        if (!options)
                return 0;

        wd->fs_st->mount_st->no_summary.boolean = 0;
        while ((s = strsep(&options, ",")) && *s) {
                int opt;

                opt = match_token(s, bilbyfs_options, args);
                switch (opt) {
                case BilbyFs_Opt_no_summary:
                        wd->fs_st->mount_st->no_summary.boolean = 1;
                        bilbyfs_err("BilbyFs option: no_summary\n");
                        break;
                case BilbyFs_Opt_compr:
                        bilbyfs_err("BilbyFs option: compr=%%s ignored (No compression)\n");
                        break;
                default:
                {
                        bilbyfs_err("unreconized mount option \"%s\"\n", s);
                        return -EINVAL;
                }
                }
        }
        return 0;
}

/*
type FsopVfsInodeP = #{ex: SysState, fs_st: FsState, vnode: VfsInode}
type FsopVfsInodeE = #{err: ErrCode, ex: SysState, fs_st: FsState, vnode: VfsInode}
*/
static void bilbyfs_evict_inode(struct inode *inode)
{
        struct wrapper_data *wd = inode->i_sb->s_fs_info;
        $ty:(FsopVfsInodeP) fargs;

        bilbyfs_debug("bilbyfs_evict_inode(ino = %lu)\n", inode->i_ino);
        bilbyfs_assert(!atomic_read(&inode->i_count));

        truncate_inode_pages(&inode->i_data, 0);
        if (!is_bad_inode(inode)) {
                down(&wd->lock);
                fargs.ex = NULL;
                fargs.fs_st = wd->fs_st;
                fargs.vnode = ($ty:(VfsInode))inode;
                $exp:fsop_evict_inode(fargs);
                up(&wd->lock);
        }
        clear_inode(inode);
}

/*
type FsopFsP = #{ex:SysState, fs_st: FsState}
type FsopFsE = #{err:ErrCode, ex:SysState, fs_st: FsState}
fsop_sync_fs: FsopFsP -> R FsopFsP FsopFsE
*/
static int bilbyfs_fsync(struct file *filp, loff_t start, loff_t end, int datasync)
{
        struct inode *inode = filp->f_mapping->host;
        struct wrapper_data *wd = inode->i_sb->s_fs_info;
        int err;
        $ty:(FsopFsP) fargs;
        $ty:(RR FsopFsP () ErrCode) fret;

        bilbyfs_debug("wfsop_init()\n");
        err = filemap_write_and_wait_range(inode->i_mapping, start, end);
        if (!err) {
                down(&wd->lock);
                fargs.ex = NULL;
                fargs.fs_st = wd->fs_st;
                fret = $exp:fsop_sync_fs(fargs);
                up(&wd->lock);
                if (fret.p2.tag == TAG_ENUM_Error) {
                     err = -fret.p2.Error;
                     bilbyfs_err("BilbyFsError: bilbyfs_fsync() = %d\n", err);
                }
        } else {
                bilbyfs_err("BilbyFsError: filemap_and_wait_range() = %d\n", err);
        }
        return err;
}

static int sb_test(struct super_block *sb, void *data)
{
        struct wrapper_data *wd1 = sb->s_fs_info;
        struct wrapper_data *wd2 = data;
        bool_t res;
        $ty:((FsState!, FsState!)) fargs;

        down(&wd1->lock);
        fargs.p1 = wd1->fs_st;
        fargs.p2 = wd2->fs_st;
        res = $exp:fsop_test_is_mount(fargs);
        up(&wd1->lock);
        return res.boolean;
}

static int sb_set(struct super_block *sb, void *data)
{
        sb->s_fs_info = data;
        return set_anon_super(sb, NULL);
}

static const struct super_operations bilbyfs_super_operations;
#define BILBYFS_BD_MAX_NLEN 16

/*
type FsopInitP = #{ex:SysState, fs_st: FsState'Taken, name: CString!}
type FsopFs'P = #{ex:SysState, fs_st: FsState'}
type FsopFs'E = #{err:ErrCode, ex:SysState, fs_st: FsState'Taken}
*/
static inline int wfsop_init($ty:(FsState) fs_st, const char *name, char *bd_name)
{
        $ty:(FsopInitP) fargs;
        $ty:(R FsopFs'P FsopFs'E) fret;
        $ty:(#(WordArray U8)) wa;

        bilbyfs_debug("wfsop_init()\n");
        wa.values = (u8 *)name;
        wa.len = strlen(name) + 1;

        fargs.ex = NULL;
        fargs.fs_st = fs_st;
        fargs.name = &wa;
        fret = $exp:fsop_init(fargs);
        if (fret.tag == TAG_ENUM_Error)
                return -fret.Error.err;
        /* FIXME value works as long as there is only 1 BilbyFs instance running. */
        snprintf(bd_name, BILBYFS_BD_MAX_NLEN, "bilbyfs_%d_%d", 42, 42);
        return 0;
}

static inline void VfsMountInfo_to_super_block($ty:(VfsMountInfo) vmi, struct super_block *sb)
{
        sb->s_magic = vmi->s_magic;
        sb->s_flags = vmi->s_flags;
        sb->s_max_links = vmi->s_max_links;
        sb->s_maxbytes = vmi->s_maxbytes;
        sb->s_blocksize = vmi->s_blocksize;
        sb->s_blocksize_bits = vmi->s_blocksize_bits;
}

static inline void super_block_to_VfsMountInfo(struct super_block *sb, $ty:(VfsMountInfo) vmi)
{
      vmi->s_magic          = sb->s_magic         ;
      vmi->s_flags          = sb->s_flags         ;
      vmi->s_max_links      = sb->s_max_links     ;
      vmi->s_maxbytes       = sb->s_maxbytes      ;
      vmi->s_blocksize      = sb->s_blocksize     ;
      vmi->s_blocksize_bits = sb->s_blocksize_bits;
}
/*
type FsopFillSuperP = #{ex:SysState, fs_st:FsState', vsup:VfsMountInfo, is_silent:Bool, root:VfsInode}
type FsopFillSuperRR = #{ex:SysState, vsup:VfsMountInfo, root:VfsInode}
type FsopFillSuperE = #{err:ErrCode, fs_st:FsState'}
fsop_fill_super: FsopFillSuperP -> RR FsopFillSuperRR FsState FsopFillSuperE
*/
static int wfsop_fill_super(struct wrapper_data *wd, struct super_block *sb, int silent, struct inode *inode)
{
    $ty:(FsopFillSuperP) fargs;
    $ty:(RR FsopFillSuperRR FsState FsopFillSuperE) fret;

    down(&wd->lock);
    fargs.ex = NULL;
    fargs.fs_st = wd->fs_st;
    fargs.vsup = &wd->vfsmountinfo;
    super_block_to_VfsMountInfo(sb, fargs.vsup);
    fargs.is_silent.boolean = !!silent;
    fargs.root = ($ty:(VfsInode)) inode;
    fret = $exp:fsop_fill_super(fargs);
    up(&wd->lock);
    VfsMountInfo_to_super_block(fret.p1.vsup, sb);
    if (fret.p2.tag == TAG_ENUM_Error) {
            /* when fsop_fill_super returns an error, ubi_vol remains taken.
             * We set it to NULL, it's a hack to be able to call fsop_clean
             * which calls ubi_close which is aware that ubi_vol could be NULL.
             * Note that fsop_clean is usually called from kill_super.
             */
            wd->fs_st->ostore_st->ubi_vol = NULL;
            return -fret.p2.Error.err;
    } else {
            /* fsop_fill_super reallocates fs_st when successful because
             * of take/put type system limitations
             */
            wd->fs_st = fret.p2.Success;
    }
    return 0;
}

static int bilbyfs_fill_super(struct super_block *sb, void *options, int silent, char *bd_name)
{
        struct wrapper_data *wd = sb->s_fs_info;
        struct inode *root;
        ino_t rootino;
        int err;

        err = bilbyfs_parse_options(wd, options);
        if (err)
                return err;
        /*
         * Disabling VFS's read-ahead feature.
         * Read-ahead will be disabled because bdi->ra_pages is 0.
         */
$escstm:(#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
        sb->s_bdi = &wd->bdi;
        sb->s_bdi->name = "bilbyfs";
        sb->s_bdi->capabilities = BDI_CAP_MAP_COPY;
        err = bdi_init(sb->s_bdi);

        if (!err) {
                err = bdi_register(sb->s_bdi, NULL, bd_name);
                if (!err) {
                        sb->s_fs_info = wd;
                        root = bilbyfs_new_inode(sb, NULL, S_IFDIR | S_IRUGO | S_IWUSR | S_IXUGO);
                        if (root) {
                                set_nlink(root, 2);
                                err = wfsop_fill_super(wd, sb, silent, root);
                                iput(root);
                        } else {
                                err = PTR_ERR(root);
                        }

                        if (!err) {
                                /* Reads the root inode */
                                root = bilbyfs_iget(wd, root->i_ino);
                                if (!IS_ERR(root)) {
                                        sb->s_root = d_make_root(root);
                                        if (sb->s_root)
                                                return 0;
                                        err = -EINVAL;
                                } else {
                                        err = PTR_ERR(root);
                                }
                                bilbyfs_unmount(wd);
                        }
                        bdi_destroy(sb->s_bdi);
                }
        }
$escstm:(#endif)

$escstm:(#if LINUX_VERSION_CODE > KERNEL_VERSION(4,11,0))
        super_setup_bdi(sb);
$escstm:(#endif)
        sb->s_fs_info = wd;
        root = bilbyfs_new_inode(sb, NULL, S_IFDIR | S_IRUGO | S_IWUSR | S_IXUGO);
        if (root) {
                set_nlink(root, 2);
                err = wfsop_fill_super(wd, sb, silent, root);
                iput(root);
        } else {
                err = PTR_ERR(root);
        }

        if (!err) {
                /* Reads the root inode */
                root = bilbyfs_iget(wd, root->i_ino);
                if (!IS_ERR(root)) {
                        sb->s_root = d_make_root(root);
                        if (sb->s_root)
                                return 0;
                        err = -EINVAL;
                } else {
                        err = PTR_ERR(root);
                }
                bilbyfs_unmount(wd);
        }

        bilbyfs_err("bilbyfs_fill_super error = %d\n", err);
        sb->s_bdi = NULL;
        return err;
}

struct dentry *bilbyfs_mount(struct file_system_type *fs_type, int flags,
                             const char *name, void *data)
{
        struct wrapper_data *wd;
        struct super_block *sb;
        char bd_name[BILBYFS_BD_MAX_NLEN];
        int err;

        bilbyfs_err("Mounting BilbyFs (COGENT) %s, flags %#x\n", name, flags);
        wd = wrapper_init();
        if (wd) {
                wd->fs_st = kzalloc(sizeof(*(wd->fs_st)));
                if (wd->fs_st) {
                        down(&wd->lock);
                        err = wfsop_init(wd->fs_st, name, bd_name);
                        up(&wd->lock);
                        if (!err) {
                                /* Set readonly flag, FIXME should probably be done in COGENT */
                                wd->fs_st->fsop_st->is_ro.boolean = !!(flags & MS_RDONLY);
                                sb = sget(fs_type, sb_test, sb_set, flags, wd);
                                if (!IS_ERR(sb)) {
                                        wd->vfs_sb = sb;
                                        /* 'fill_super()' opens ubi again so we must close it here */
                                        if (sb->s_root) {
                                                kfree(wd);
                                                /* A new mount point for already mounted BilbyFs */
                                                return dget(sb->s_root);
                                        } else {
                                                sb->s_flags = flags;
                                                sb->s_op = &bilbyfs_super_operations;
                                                err = bilbyfs_fill_super(sb, data, !!(flags & MS_SILENT), bd_name);
                                                if (!err) {
                                                        /* We do not support atime */
                                                        sb->s_flags |= MS_ACTIVE | MS_NOATIME;
                                                        bilbyfs_debug("bilbyfs_mount() = %d\n", err);
                                                        return dget(sb->s_root);
                                                }
                                                deactivate_locked_super(sb);
                                        }
                                } else {
                                        err = PTR_ERR(sb);
                                }
                        }
                    kfree(wd->fs_st);
                }
                kfree(wd);
        } else {
                err = -ENOMEM;
        }
        bilbyfs_debug("bilbyfs_mount() = %d\n", err);
        return ERR_PTR(err);
}

static inline void wfsop_clean(struct wrapper_data *wd)
{
        $ty:(FsopFsP) fargs;

        fargs.ex = NULL;
        fargs.fs_st = wd->fs_st;
        fsop_clean(fargs);
        /* fsop_clean frees fs_st */
        wd->fs_st = NULL;
}

/**
 * bilbyfs_kill_super: free linux super block instance.
 * @sb: Linux super block reference
 */
void bilbyfs_kill_super(struct super_block *sb)
{
        struct wrapper_data *wd = sb->s_fs_info;

        bilbyfs_debug("bilbyfs_kill_super()\n");
        kill_anon_super(sb);
        down(&wd->lock);
        wfsop_clean(wd);
        up(&wd->lock);
        wrapper_clean(wd);
}

$ty:(()) $id:bilbyfs_error(char *str)
{
    $ty:(()) unit;

    bilbyfs_err("%s", str);
    return unit;
}

$ty:(()) $id:bilbyfs_error_u32(u32 a)
{
    $ty:(()) unit;

    bilbyfs_err("%u", a);
    return unit;
}

$esc:(#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
const struct file_operations bilbyfs_file_operations =
{
        .llseek =       generic_file_llseek,
        .open =         generic_file_open,
        .read =         new_sync_read,
        .write =        new_sync_write,
        .read_iter =    generic_file_read_iter,
        .write_iter =   generic_file_write_iter,
        .mmap =         generic_file_readonly_mmap,
        .fsync =        bilbyfs_fsync,
        .splice_read =  generic_file_splice_read,
};
$esc:(#else)
const struct file_operations bilbyfs_file_operations =
{
        .llseek =       generic_file_llseek,
        .open =         generic_file_open,
        .read_iter =    generic_file_read_iter,
        .write_iter =   generic_file_write_iter,
        .mmap =         generic_file_readonly_mmap,
        .fsync =        bilbyfs_fsync,
        .splice_read =  generic_file_splice_read,
};
$esc:(#endif)


const struct inode_operations bilby_file_inode_operations =
{
        .setattr =      bilbyfs_setattr,
};

$esc:(#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0))
const struct inode_operations bilbyfs_symlink_inode_operations = {
        .readlink    = generic_readlink,
        .follow_link = bilbyfs_follow_link,
        .setattr     = bilbyfs_setattr,
        .getattr     = bilbyfs_getattr,
};
$esc:(#else)
const struct inode_operations bilbyfs_symlink_inode_operations = {
        .get_link    = bilbyfs_get_link,
        .setattr     = bilbyfs_setattr,
        .getattr     = bilbyfs_getattr,
};
$esc:(#endif)

const struct inode_operations bilbyfs_file_inode_operations = {
        .setattr     = bilbyfs_setattr,
        .getattr     = bilbyfs_getattr,
};

const struct inode_operations bilbyfs_dir_inode_operations = {
        .lookup      = bilbyfs_lookup,
        .create      = bilbyfs_create,
        .link        = bilbyfs_link,
        .symlink     = bilbyfs_symlink,
        .unlink      = bilbyfs_unlink,
        .mkdir       = bilbyfs_mkdir,
        .rmdir       = bilbyfs_rmdir,
        .rename      = bilbyfs_rename,
        .setattr     = bilbyfs_setattr,
/*
        .mknod       = bilbyfs_mknod,
*/
        .getattr     = bilbyfs_getattr,
};

const struct file_operations bilbyfs_dir_operations = {
        .llseek         = bilbyfs_dir_llseek,
        .release        = bilbyfs_dir_release,
        .fsync          = bilbyfs_fsync,
        .read           = generic_read_dir,
        .iterate        = bilbyfs_readdir,
};

const struct address_space_operations bilbyfs_file_address_operations =
{
        .readpage =     bilbyfs_readpage,
        .write_begin =  bilbyfs_write_begin,
#ifdef NOWRITEBACK
        .write_end =    bilbyfs_write_end,
#else
        .writepage  =   bilbyfs_writepage,
        .write_end  =   bilbyfs_write_end_writeback,
#endif
};
