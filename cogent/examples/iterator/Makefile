# This is the bare minimum needed to build a functioning program with
# Cogent.

# The cogent compiler knows where stdgum lives but needs some help in
# setting up arguments for the C preprocessor.
#
# Code generated by cogent relies on definitions from stdgum for
# primitive items.
LIBGUM=$(shell cogent --libgum-dir)

# We are going to rely on the stdgum libraries on the C preprocessor
# when used by cogent and also in our C compiler.
CFLAGS+=-I${LIBGUM} -I${LIBGUM}gum/anti -O2

# We need to tell cogent, which uses the C preprocessor for anti-quoted
# C, how to invoke the C preprocessor so that it knows where all of the
# necessary libraries are.
COGENTFLAGS= \
	--cpp-args="\$$CPPIN -o \$$CPPOUT -P $(CFLAGS)" --cpp="$(CPP)"

# Our final program will be compiled into main.
all: main

# Cogent creates a number of intermediary files.
clean:
	rm -rf generated.{h,c} main_pp.ac main_pp_inferred.c main

# Cogent will currently output to a file with a name based on the name
# of the anti-quoted C file. We can simply compile this output to get
# our final program.
main: main_pp_inferred.c
	$(CC) $(CFLAGS) -o $@ $^

# This is how we get cogent to generate a C file based on our
# anti-quoted C and cogent source.
#
# --infer-c-funcs tells cogent where the anti-quoted C comes from.
# -ogenerated tells cogent to output the C generated from the cogent
#     source into a pair of files called generated.c and generated.h
# -g telss cogent to generate C code from the cogent source
main_pp_inferred.c: main.ac Iter.cogent
	cogent \
		${COGENTFLAGS} \
		--infer-c-funcs=main.ac \
		-ogenerated \
		-g Iter.cogent
