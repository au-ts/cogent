(*
This file is generated by Cogent

*)

theory Generated_Shallow_Normal
imports "Generated_ShallowShared"
begin

definition
  snd :: "('a, 'b) RR \<Rightarrow> 'b"
where
  "snd ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>3). Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>4. b)))"

definition
  second :: "('b \<Rightarrow> 'b', ('a, 'b) RR) RR \<Rightarrow> ('a, 'b') RR"
where
  "second ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(f,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 RR.p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>5). HOL.Let (f b) (\<lambda>an\<^sub>7. RR.make a an\<^sub>7)))))"

definition
  min_u64 :: "(64 word, 64 word) RR \<Rightarrow> 64 word"
where
  "min_u64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((<) a b) (\<lambda>an\<^sub>1\<^sub>2. HOL.If an\<^sub>1\<^sub>2 a b)))"

definition
  min_u32 :: "(32 word, 32 word) RR \<Rightarrow> 32 word"
where
  "min_u32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((<) a b) (\<lambda>an\<^sub>1\<^sub>7. HOL.If an\<^sub>1\<^sub>7 a b)))"

definition
  max_u64 :: "(64 word, 64 word) RR \<Rightarrow> 64 word"
where
  "max_u64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((<) a b) (\<lambda>an\<^sub>2\<^sub>2. HOL.If an\<^sub>2\<^sub>2 b a)))"

definition
  max_u32 :: "(32 word, 32 word) RR \<Rightarrow> 32 word"
where
  "max_u32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((<) a b) (\<lambda>an\<^sub>2\<^sub>7. HOL.If an\<^sub>2\<^sub>7 b a)))"

definition
  in_range_u32 :: "(32 word, 32 word, 32 word) WordArrayFindSubP \<Rightarrow> bool"
where
  "in_range_u32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 WordArrayFindSubP.p1\<^sub>f) (\<lambda>(needle,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 WordArrayFindSubP.p2\<^sub>f) (\<lambda>(from\<^sub>r,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 WordArrayFindSubP.p3\<^sub>f) (\<lambda>(to,ds\<^sub>3). HOL.Let ((>=) needle from\<^sub>r) (\<lambda>an\<^sub>3\<^sub>4. HOL.Let ((<) needle to) (\<lambda>an\<^sub>3\<^sub>7. HOL.Let (an\<^sub>3\<^sub>4 \<and> an\<^sub>3\<^sub>7) (\<lambda>an\<^sub>3\<^sub>3. HOL.If an\<^sub>3\<^sub>3 True False))))))"

definition
  fst :: "('a, 'b) RR \<Rightarrow> 'a"
where
  "fst ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 RR.p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>4. a)))"

definition
  first :: "('a \<Rightarrow> 'a', ('a, 'b) RR) RR \<Rightarrow> ('a', 'b) RR"
where
  "first ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(f,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 RR.p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>5). HOL.Let (f a) (\<lambda>an\<^sub>4\<^sub>6. RR.make an\<^sub>4\<^sub>6 b)))))"

definition
  drop :: "'a \<Rightarrow> unit"
where
  "drop ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. ())"

definition
  cogent_low_16_bits :: "32 word \<Rightarrow> 16 word"
where
  "cogent_low_16_bits ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. HOL.Let (65535 :: 32 word) (\<lambda>an\<^sub>5\<^sub>2. HOL.Let ((AND) x an\<^sub>5\<^sub>2) (\<lambda>an\<^sub>5\<^sub>0. u32_to_u16 an\<^sub>5\<^sub>0)))"

definition
  cogent_high_16_bits :: "32 word \<Rightarrow> 16 word"
where
  "cogent_high_16_bits ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. HOL.Let (4294901760 :: 32 word) (\<lambda>an\<^sub>5\<^sub>6. HOL.Let ((AND) x an\<^sub>5\<^sub>6) (\<lambda>an\<^sub>5\<^sub>4. HOL.Let (16 :: 32 word) (\<lambda>an\<^sub>5\<^sub>7. HOL.Let (checked_shift shiftr an\<^sub>5\<^sub>4 an\<^sub>5\<^sub>7) (\<lambda>an\<^sub>5\<^sub>3. u32_to_u16 an\<^sub>5\<^sub>3)))))"

definition
  align64 :: "(64 word, 64 word) RR \<Rightarrow> 64 word"
where
  "align64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(x,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(powof2,ds\<^sub>2). HOL.Let (1 :: 64 word) (\<lambda>an\<^sub>6\<^sub>4. HOL.Let ((-) powof2 an\<^sub>6\<^sub>4) (\<lambda>an\<^sub>6\<^sub>2. HOL.Let ((+) x an\<^sub>6\<^sub>2) (\<lambda>an\<^sub>6\<^sub>0. HOL.Let (1 :: 64 word) (\<lambda>an\<^sub>6\<^sub>8. HOL.Let ((-) powof2 an\<^sub>6\<^sub>8) (\<lambda>an\<^sub>6\<^sub>6. HOL.Let (NOT an\<^sub>6\<^sub>6) (\<lambda>an\<^sub>6\<^sub>5. (AND) an\<^sub>6\<^sub>0 an\<^sub>6\<^sub>5))))))))"

definition
  align32 :: "(32 word, 32 word) RR \<Rightarrow> 32 word"
where
  "align32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(x,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(powof2,ds\<^sub>2). HOL.Let (1 :: 32 word) (\<lambda>an\<^sub>7\<^sub>5. HOL.Let ((-) powof2 an\<^sub>7\<^sub>5) (\<lambda>an\<^sub>7\<^sub>3. HOL.Let ((+) x an\<^sub>7\<^sub>3) (\<lambda>an\<^sub>7\<^sub>1. HOL.Let (1 :: 32 word) (\<lambda>an\<^sub>7\<^sub>9. HOL.Let ((-) powof2 an\<^sub>7\<^sub>9) (\<lambda>an\<^sub>7\<^sub>7. HOL.Let (NOT an\<^sub>7\<^sub>7) (\<lambda>an\<^sub>7\<^sub>6. (AND) an\<^sub>7\<^sub>1 an\<^sub>7\<^sub>6))))))))"

definition
  wordarray_get_u32 :: "(32 word WordArray, 32 word) RR \<Rightarrow> 32 word"
where
  "wordarray_get_u32 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. wordarray_get x)"

definition
  wordarray_length_u32 :: "32 word WordArray \<Rightarrow> 32 word"
where
  "wordarray_length_u32 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. wordarray_length x)"

definition
  wordarray_put2_u32 :: "(32 word WordArray, 32 word, 32 word) WordArrayPutP \<Rightarrow> 32 word WordArray"
where
  "wordarray_put2_u32 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. wordarray_put2 x)"

definition
  wordarray_free' :: "( SysState, 'a WordArray) T0 \<Rightarrow>  SysState"
where
  "wordarray_free' ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 T0.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 T0.obj\<^sub>f) (\<lambda>(obj,ds\<^sub>1). HOL.Let (RR.make ex obj) (\<lambda>an\<^sub>8\<^sub>5. wordarray_free an\<^sub>8\<^sub>5)))"

definition
  error :: "'b \<Rightarrow> ('b, 'a) R"
where
  "error ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>b. HOL.Let (R.Error b :: ('b, 'a) R) (\<lambda>an\<^sub>8\<^sub>8. an\<^sub>8\<^sub>8))"

definition
  safe_add32 :: "(32 word, 32 word) RR \<Rightarrow> (unit, 32 word) R"
where
  "safe_add32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((+) a b) (\<lambda>r. HOL.Let ((<) r a) (\<lambda>an\<^sub>9\<^sub>5. HOL.Let ((<) r b) (\<lambda>an\<^sub>9\<^sub>8. HOL.Let (an\<^sub>9\<^sub>5 \<or> an\<^sub>9\<^sub>8) (\<lambda>an\<^sub>9\<^sub>4. HOL.If an\<^sub>9\<^sub>4 (HOL.Let () (\<lambda>an\<^sub>1\<^sub>0\<^sub>2. HOL.Let (R.Error an\<^sub>1\<^sub>0\<^sub>2 :: (unit, 32 word) R) (\<lambda>an\<^sub>1\<^sub>0\<^sub>1. an\<^sub>1\<^sub>0\<^sub>1))) (HOL.Let (R.Success r :: (unit, 32 word) R) (\<lambda>an\<^sub>1\<^sub>0\<^sub>3. an\<^sub>1\<^sub>0\<^sub>3))))))))"

definition
  safe_add64 :: "(64 word, 64 word) RR \<Rightarrow> (unit, 64 word) R"
where
  "safe_add64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((+) a b) (\<lambda>r. HOL.Let ((<) r a) (\<lambda>an\<^sub>1\<^sub>1\<^sub>0. HOL.Let ((<) r b) (\<lambda>an\<^sub>1\<^sub>1\<^sub>3. HOL.Let (an\<^sub>1\<^sub>1\<^sub>0 \<or> an\<^sub>1\<^sub>1\<^sub>3) (\<lambda>an\<^sub>1\<^sub>0\<^sub>9. HOL.If an\<^sub>1\<^sub>0\<^sub>9 (HOL.Let () (\<lambda>an\<^sub>1\<^sub>1\<^sub>7. HOL.Let (R.Error an\<^sub>1\<^sub>1\<^sub>7 :: (unit, 64 word) R) (\<lambda>an\<^sub>1\<^sub>1\<^sub>6. an\<^sub>1\<^sub>1\<^sub>6))) (HOL.Let (R.Success r :: (unit, 64 word) R) (\<lambda>an\<^sub>1\<^sub>1\<^sub>8. an\<^sub>1\<^sub>1\<^sub>8))))))))"

definition
  safe_sub32 :: "(32 word, 32 word) RR \<Rightarrow> (unit, 32 word) R"
where
  "safe_sub32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((-) a b) (\<lambda>r. HOL.Let ((>) r a) (\<lambda>an\<^sub>1\<^sub>2\<^sub>4. HOL.If an\<^sub>1\<^sub>2\<^sub>4 (HOL.Let () (\<lambda>an\<^sub>1\<^sub>2\<^sub>8. HOL.Let (R.Error an\<^sub>1\<^sub>2\<^sub>8 :: (unit, 32 word) R) (\<lambda>an\<^sub>1\<^sub>2\<^sub>7. an\<^sub>1\<^sub>2\<^sub>7))) (HOL.Let (R.Success r :: (unit, 32 word) R) (\<lambda>an\<^sub>1\<^sub>2\<^sub>9. an\<^sub>1\<^sub>2\<^sub>9))))))"

definition
  safe_sub64 :: "(64 word, 64 word) RR \<Rightarrow> (unit, 64 word) R"
where
  "safe_sub64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((-) a b) (\<lambda>r. HOL.Let ((>) r a) (\<lambda>an\<^sub>1\<^sub>3\<^sub>5. HOL.If an\<^sub>1\<^sub>3\<^sub>5 (HOL.Let () (\<lambda>an\<^sub>1\<^sub>3\<^sub>9. HOL.Let (R.Error an\<^sub>1\<^sub>3\<^sub>9 :: (unit, 64 word) R) (\<lambda>an\<^sub>1\<^sub>3\<^sub>8. an\<^sub>1\<^sub>3\<^sub>8))) (HOL.Let (R.Success r :: (unit, 64 word) R) (\<lambda>an\<^sub>1\<^sub>4\<^sub>0. an\<^sub>1\<^sub>4\<^sub>0))))))"

definition
  success :: "'a \<Rightarrow> ('b, 'a) R"
where
  "success ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>a. HOL.Let (R.Success a :: ('b, 'a) R) (\<lambda>an\<^sub>1\<^sub>4\<^sub>2. an\<^sub>1\<^sub>4\<^sub>2))"

definition
  wordarray_clone :: "( SysState, 'a WordArray) RR \<Rightarrow> ( SysState, ( SysState, 'a WordArray) RR) R"
where
  "wordarray_clone ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(src,ds\<^sub>2). HOL.Let (wordarray_length src) (\<lambda>size. HOL.Let (RR.make ex size) (\<lambda>an\<^sub>1\<^sub>4\<^sub>7. Let\<^sub>d\<^sub>s (wordarray_create an\<^sub>1\<^sub>4\<^sub>7) (\<lambda>ds\<^sub>3. case_R (\<lambda>ex. HOL.Let (R.Error ex :: ( SysState, ( SysState, 'a WordArray) RR) R) (\<lambda>an\<^sub>1\<^sub>5\<^sub>1. an\<^sub>1\<^sub>5\<^sub>1)) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 RR.p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 RR.p2\<^sub>f) (\<lambda>(dest,ds\<^sub>7). HOL.Let (0 :: 32 word) (\<lambda>an\<^sub>1\<^sub>6\<^sub>3. HOL.Let (0 :: 32 word) (\<lambda>an\<^sub>1\<^sub>6\<^sub>4. HOL.Let (WordArrayCopyP.make dest src an\<^sub>1\<^sub>6\<^sub>3 an\<^sub>1\<^sub>6\<^sub>4 size) (\<lambda>an\<^sub>1\<^sub>6\<^sub>0. HOL.Let (wordarray_copy an\<^sub>1\<^sub>6\<^sub>0) (\<lambda>an\<^sub>1\<^sub>5\<^sub>9. HOL.Let (RR.make ex an\<^sub>1\<^sub>5\<^sub>9) (\<lambda>an\<^sub>1\<^sub>5\<^sub>7. HOL.Let (R.Success an\<^sub>1\<^sub>5\<^sub>7 :: ( SysState, ( SysState, 'a WordArray) RR) R) (\<lambda>an\<^sub>1\<^sub>5\<^sub>4. an\<^sub>1\<^sub>5\<^sub>4))))))))) ds\<^sub>3)))))"

definition
  wordarray_get_bounded :: "('a WordArray, 32 word) RR \<Rightarrow> (unit, 'a) R"
where
  "wordarray_get_bounded ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 RR.p1\<^sub>f) (\<lambda>(arr,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 RR.p2\<^sub>f) (\<lambda>(idx,ds\<^sub>2). HOL.Let (wordarray_length arr) (\<lambda>an\<^sub>1\<^sub>7\<^sub>0. HOL.Let ((<) idx an\<^sub>1\<^sub>7\<^sub>0) (\<lambda>an\<^sub>1\<^sub>6\<^sub>8. HOL.If an\<^sub>1\<^sub>6\<^sub>8 (HOL.Let (RR.make arr idx) (\<lambda>an\<^sub>1\<^sub>7\<^sub>4. HOL.Let (wordarray_get an\<^sub>1\<^sub>7\<^sub>4) (\<lambda>an\<^sub>1\<^sub>7\<^sub>3. HOL.Let (R.Success an\<^sub>1\<^sub>7\<^sub>3 :: (unit, 'a) R) (\<lambda>an\<^sub>1\<^sub>7\<^sub>2. an\<^sub>1\<^sub>7\<^sub>2)))) (HOL.Let () (\<lambda>an\<^sub>1\<^sub>7\<^sub>8. HOL.Let (R.Error an\<^sub>1\<^sub>7\<^sub>8 :: (unit, 'a) R) (\<lambda>an\<^sub>1\<^sub>7\<^sub>7. an\<^sub>1\<^sub>7\<^sub>7)))))))"

definition
  optionToResult :: "(unit, 'a) Option \<Rightarrow> (unit, 'a) R"
where
  "optionToResult ds\<^sub>0 \<equiv> case_Option (\<lambda>ds\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>3. HOL.Let () (\<lambda>an\<^sub>1\<^sub>8\<^sub>1. HOL.Let (R.Error an\<^sub>1\<^sub>8\<^sub>1 :: (unit, 'a) R) (\<lambda>an\<^sub>1\<^sub>8\<^sub>0. an\<^sub>1\<^sub>8\<^sub>0)))) (\<lambda>a. HOL.Let (R.Success a :: (unit, 'a) R) (\<lambda>an\<^sub>1\<^sub>8\<^sub>3. an\<^sub>1\<^sub>8\<^sub>3)) ds\<^sub>0"

definition
  resultToOption :: "('e, 'a) R \<Rightarrow> (unit, 'a) Option"
where
  "resultToOption ds\<^sub>0 \<equiv> case_R (\<lambda>ds\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>3. HOL.Let () (\<lambda>an\<^sub>1\<^sub>8\<^sub>7. HOL.Let (Option.None an\<^sub>1\<^sub>8\<^sub>7 :: (unit, 'a) Option) (\<lambda>an\<^sub>1\<^sub>8\<^sub>6. an\<^sub>1\<^sub>8\<^sub>6)))) (\<lambda>a. HOL.Let (Option.Some a :: (unit, 'a) Option) (\<lambda>an\<^sub>1\<^sub>8\<^sub>9. an\<^sub>1\<^sub>8\<^sub>9)) ds\<^sub>0"

definition
  copy_n :: "('a, 32 word, 'a WordArray) ElemAO \<Rightarrow> ('a, 32 word) RR"
where
  "copy_n ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(elem,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(idx,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(afrm,ds\<^sub>1). HOL.Let (RR.make afrm idx) (\<lambda>an\<^sub>1\<^sub>9\<^sub>5. HOL.Let (wordarray_get an\<^sub>1\<^sub>9\<^sub>5) (\<lambda>an\<^sub>1\<^sub>9\<^sub>4. HOL.Let (1 :: 32 word) (\<lambda>an\<^sub>2\<^sub>0\<^sub>0. HOL.Let ((+) idx an\<^sub>2\<^sub>0\<^sub>0) (\<lambda>an\<^sub>1\<^sub>9\<^sub>8. RR.make an\<^sub>1\<^sub>9\<^sub>4 an\<^sub>1\<^sub>9\<^sub>8)))))))"

definition
  dec :: "(32 word, unit, unit) ElemAO \<Rightarrow> (32 word, unit) RR"
where
  "dec ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(elem,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). HOL.Let (1 :: 32 word) (\<lambda>an\<^sub>2\<^sub>0\<^sub>6. HOL.Let ((-) elem an\<^sub>2\<^sub>0\<^sub>6) (\<lambda>an\<^sub>2\<^sub>0\<^sub>4. RR.make an\<^sub>2\<^sub>0\<^sub>4 acc)))))"

definition
  dec_arr :: "32 word WordArray \<Rightarrow> (32 word WordArray, unit) RR"
where
  "dec_arr ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>wa. HOL.Let (wordarray_length wa) (\<lambda>end. HOL.Let (0 :: 32 word) (\<lambda>an\<^sub>2\<^sub>1\<^sub>0. HOL.Let dec (\<lambda>an\<^sub>2\<^sub>1\<^sub>2. HOL.Let () (\<lambda>an\<^sub>2\<^sub>1\<^sub>3. HOL.Let () (\<lambda>an\<^sub>2\<^sub>1\<^sub>4. HOL.Let (WordArrayMapP.make wa an\<^sub>2\<^sub>1\<^sub>0 end an\<^sub>2\<^sub>1\<^sub>2 an\<^sub>2\<^sub>1\<^sub>3 an\<^sub>2\<^sub>1\<^sub>4) (\<lambda>arg. wordarray_map_no_break arg)))))))"

definition
  inc :: "(32 word, unit, unit) ElemAO \<Rightarrow> (32 word, unit) RR"
where
  "inc ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(elem,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). HOL.Let (1 :: 32 word) (\<lambda>an\<^sub>2\<^sub>2\<^sub>1. HOL.Let ((+) elem an\<^sub>2\<^sub>2\<^sub>1) (\<lambda>an\<^sub>2\<^sub>1\<^sub>9. RR.make an\<^sub>2\<^sub>1\<^sub>9 acc)))))"

definition
  inc_arr :: "32 word WordArray \<Rightarrow> (32 word WordArray, unit) RR"
where
  "inc_arr ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>wa. HOL.Let (wordarray_length wa) (\<lambda>end. HOL.Let (0 :: 32 word) (\<lambda>an\<^sub>2\<^sub>2\<^sub>5. HOL.Let inc (\<lambda>an\<^sub>2\<^sub>2\<^sub>7. HOL.Let () (\<lambda>an\<^sub>2\<^sub>2\<^sub>8. HOL.Let () (\<lambda>an\<^sub>2\<^sub>2\<^sub>9. HOL.Let (WordArrayMapP.make wa an\<^sub>2\<^sub>2\<^sub>5 end an\<^sub>2\<^sub>2\<^sub>7 an\<^sub>2\<^sub>2\<^sub>8 an\<^sub>2\<^sub>2\<^sub>9) (\<lambda>arg. wordarray_map_no_break arg)))))))"

definition
  mul :: "(32 word, 32 word, unit) ElemAO \<Rightarrow> 32 word"
where
  "mul ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(elem,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). (*) elem acc)))"

definition
  mul_arr :: "32 word WordArray \<Rightarrow> 32 word"
where
  "mul_arr ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>wa. HOL.Let (wordarray_length wa) (\<lambda>e. HOL.Let (0 :: 32 word) (\<lambda>an\<^sub>2\<^sub>3\<^sub>8. HOL.Let mul (\<lambda>an\<^sub>2\<^sub>4\<^sub>0. HOL.Let (0 :: 32 word) (\<lambda>an\<^sub>2\<^sub>4\<^sub>1. HOL.Let () (\<lambda>an\<^sub>2\<^sub>4\<^sub>2. HOL.Let (WordArrayMapP.make wa an\<^sub>2\<^sub>3\<^sub>8 e an\<^sub>2\<^sub>4\<^sub>0 an\<^sub>2\<^sub>4\<^sub>1 an\<^sub>2\<^sub>4\<^sub>2) (\<lambda>arg. wordarray_fold_no_break arg)))))))"

definition
  sum :: "(32 word, 32 word, unit) ElemAO \<Rightarrow> 32 word"
where
  "sum ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(elem,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). (+) elem acc)))"

definition
  sum_arr :: "32 word WordArray \<Rightarrow> 32 word"
where
  "sum_arr ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>wa. HOL.Let (wordarray_length wa) (\<lambda>e. HOL.Let (0 :: 32 word) (\<lambda>an\<^sub>2\<^sub>5\<^sub>1. HOL.Let sum (\<lambda>an\<^sub>2\<^sub>5\<^sub>3. HOL.Let (0 :: 32 word) (\<lambda>an\<^sub>2\<^sub>5\<^sub>4. HOL.Let () (\<lambda>an\<^sub>2\<^sub>5\<^sub>5. HOL.Let (WordArrayMapP.make wa an\<^sub>2\<^sub>5\<^sub>1 e an\<^sub>2\<^sub>5\<^sub>3 an\<^sub>2\<^sub>5\<^sub>4 an\<^sub>2\<^sub>5\<^sub>5) (\<lambda>arg. wordarray_fold_no_break arg)))))))"

end
