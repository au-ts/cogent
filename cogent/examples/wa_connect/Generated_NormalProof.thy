(*
This file is generated by Cogent

*)

theory Generated_NormalProof
imports "CogentShallow.Shallow_Normalisation_Tac"
"Generated_Shallow_Desugar"
"Generated_Shallow_Normal"
begin

lemma shallow_anormal_case_distribs :
  "\<And>x y f1 f2. ((((case_Option $ f1) $ f2) $ x) $ y) \<equiv> (((case_Option $ (\<lambda>v. f1 v $ y)) $ (\<lambda>v. f2 v $ y)) $ x)"
  "\<And>x g f1 f2. g $ (((case_Option $ f1) $ f2) $ x) \<equiv> (((case_Option $ (\<lambda>v. g $ f1 v)) $ (\<lambda>v. g $ f2 v)) $ x)"
  "\<And>x y f1 f2. ((((case_R $ f1) $ f2) $ x) $ y) \<equiv> (((case_R $ (\<lambda>v. f1 v $ y)) $ (\<lambda>v. f2 v $ y)) $ x)"
  "\<And>x g f1 f2. g $ (((case_R $ f1) $ f2) $ x) \<equiv> (((case_R $ (\<lambda>v. g $ f1 v)) $ (\<lambda>v. g $ f2 v)) $ x)"
  apply (auto intro!: eq_reflection split: Option.splits R.splits)
  done

ML \<open>
val Cogent_functions = ["snd","second","min_u64","min_u32","max_u64","max_u32","in_range_u32","fst","first","drop","cogent_low_16_bits","cogent_high_16_bits","align64","align32","wordarray_get_u32","wordarray_length_u32","wordarray_put2_u32","wordarray_free'","error","safe_add32","safe_add64","safe_sub32","safe_sub64","success","wordarray_clone","wordarray_get_bounded","optionToResult","resultToOption","copy_n","mul","mul_arr","sum","sum_arr"]
\<close>

ML \<open>
val normalisation_thms = normalisation_tac_all @{context} "Generated_Shallow_Desugar" "Generated_Shallow_Normal" [] @{thms shallow_anormal_case_distribs} Cogent_functions
\<close>


end
