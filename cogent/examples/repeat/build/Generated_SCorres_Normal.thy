(*
This file is generated by Cogent

*)

theory Generated_SCorres_Normal
imports "Generated_Shallow_Normal"
"Generated_Deep_Normal"
"CogentShallow.Shallow_Tac"
begin

overloading
  valRel_T0 \<equiv> valRel
begin
  definition valRel_T0: "\<And>\<xi> x v. valRel_T0 \<xi> (x :: ('t_p1, 't_p2, 't_p3) T0) v \<equiv> \<exists>f_p1 f_p2 f_p3. v = VRecord [f_p1, f_p2, f_p3] \<and> valRel \<xi> (T0.p1\<^sub>f x) f_p1 \<and> valRel \<xi> (T0.p2\<^sub>f x) f_p2 \<and> valRel \<xi> (T0.p3\<^sub>f x) f_p3"
end

overloading
  valRel_T1 \<equiv> valRel
begin
  definition valRel_T1: "\<And>\<xi> x v. valRel_T1 \<xi> (x :: ('t_p1, 't_p2) T1) v \<equiv> \<exists>f_p1 f_p2. v = VRecord [f_p1, f_p2] \<and> valRel \<xi> (T1.p1\<^sub>f x) f_p1 \<and> valRel \<xi> (T1.p2\<^sub>f x) f_p2"
end

overloading
  valRel_Opt \<equiv> valRel
begin
  definition valRel_Opt: "valRel_Opt \<xi> (v :: ('a, 'b) Opt) v' \<equiv> case_Opt (\<lambda>x. \<exists>x'. v' = VSum ''Nothing'' x' \<and> valRel \<xi> x x') (\<lambda>x. \<exists>x'. v' = VSum ''Something'' x' \<and> valRel \<xi> x x') v"
end

overloading
  valRel_RepParam \<equiv> valRel
begin
  definition valRel_RepParam: "\<And>\<xi> x v. valRel_RepParam \<xi> (x :: ('t_n, 't_stop, 't_step, 't_acc, 't_obsv) RepParam) v \<equiv> \<exists>f_n f_stop f_step f_acc f_obsv. v = VRecord [f_n, f_stop, f_step, f_acc, f_obsv] \<and> valRel \<xi> (RepParam.n\<^sub>f x) f_n \<and> valRel \<xi> (RepParam.stop\<^sub>f x) f_stop \<and> valRel \<xi> (RepParam.step\<^sub>f x) f_step \<and> valRel \<xi> (RepParam.acc\<^sub>f x) f_acc \<and> valRel \<xi> (RepParam.obsv\<^sub>f x) f_obsv"
end

overloading
  valRel_StepParam \<equiv> valRel
begin
  definition valRel_StepParam: "\<And>\<xi> x v. valRel_StepParam \<xi> (x :: ('t_acc, 't_obsv) StepParam) v \<equiv> \<exists>f_acc f_obsv. v = VRecord [f_acc, f_obsv] \<and> valRel \<xi> (StepParam.acc\<^sub>f x) f_acc \<and> valRel \<xi> (StepParam.obsv\<^sub>f x) f_obsv"
end

overloading
  valRel_WordArrayGetP \<equiv> valRel
begin
  definition valRel_WordArrayGetP: "\<And>\<xi> x v. valRel_WordArrayGetP \<xi> (x :: ('t_arr, 't_idx, 't_val) WordArrayGetP) v \<equiv> \<exists>f_arr f_idx f_val. v = VRecord [f_arr, f_idx, f_val] \<and> valRel \<xi> (WordArrayGetP.arr\<^sub>f x) f_arr \<and> valRel \<xi> (WordArrayGetP.idx\<^sub>f x) f_idx \<and> valRel \<xi> (WordArrayGetP.val\<^sub>f x) f_val"
end

overloading
  valRel_WordArrayGetOP \<equiv> valRel
begin
  definition valRel_WordArrayGetOP: "\<And>\<xi> x v. valRel_WordArrayGetOP \<xi> (x :: ('t_arr, 't_idx) WordArrayGetOP) v \<equiv> \<exists>f_arr f_idx. v = VRecord [f_arr, f_idx] \<and> valRel \<xi> (WordArrayGetOP.arr\<^sub>f x) f_arr \<and> valRel \<xi> (WordArrayGetOP.idx\<^sub>f x) f_idx"
end

lemma valRel_Opt_Nothing[simp] :
  "valRel \<xi> (Opt.Nothing x) (VSum ''Nothing'' x') = valRel \<xi> x x'"
  apply (simp add: valRel_Opt)
  done

lemma valRel_Opt_Something[simp] :
  "valRel \<xi> (Opt.Something x) (VSum ''Something'' x') = valRel \<xi> x x'"
  apply (simp add: valRel_Opt)
  done

lemmas valRel_records =
  valRel_T0
  T0.defs
  valRel_T1
  T1.defs
  valRel_RepParam
  RepParam.defs
  valRel_StepParam
  StepParam.defs
  valRel_WordArrayGetP
  WordArrayGetP.defs
  valRel_WordArrayGetOP
  WordArrayGetOP.defs

lemmas valRel_variants =
  valRel_Opt

context shallow begin

lemma scorres_struct_T0 :
  "\<And>\<gamma> \<xi> s_p1 s_p2 s_p3 d_p1 d_p2 d_p3.
  scorres s_p1 d_p1 \<gamma> \<xi> \<Longrightarrow>
  scorres s_p2 d_p2 \<gamma> \<xi> \<Longrightarrow>
  scorres s_p3 d_p3 \<gamma> \<xi> \<Longrightarrow>
  scorres (T0.make s_p1 s_p2 s_p3) (Struct ts [d_p1, d_p2, d_p3]) \<gamma> \<xi>"
  apply (clarsimp simp: scorres_def valRel_T0 T0.defs elim!: v_sem_elims)
  done

lemma scorres_struct_T1 :
  "\<And>\<gamma> \<xi> s_p1 s_p2 d_p1 d_p2.
  scorres s_p1 d_p1 \<gamma> \<xi> \<Longrightarrow>
  scorres s_p2 d_p2 \<gamma> \<xi> \<Longrightarrow>
  scorres (T1.make s_p1 s_p2) (Struct ts [d_p1, d_p2]) \<gamma> \<xi>"
  apply (clarsimp simp: scorres_def valRel_T1 T1.defs elim!: v_sem_elims)
  done

lemma scorres_struct_RepParam :
  "\<And>\<gamma> \<xi> s_n s_stop s_step s_acc s_obsv d_n d_stop d_step d_acc d_obsv.
  scorres s_n d_n \<gamma> \<xi> \<Longrightarrow>
  scorres s_stop d_stop \<gamma> \<xi> \<Longrightarrow>
  scorres s_step d_step \<gamma> \<xi> \<Longrightarrow>
  scorres s_acc d_acc \<gamma> \<xi> \<Longrightarrow>
  scorres s_obsv d_obsv \<gamma> \<xi> \<Longrightarrow>
  scorres (RepParam.make s_n s_stop s_step s_acc s_obsv) (Struct ts [d_n, d_stop, d_step, d_acc, d_obsv]) \<gamma> \<xi>"
  apply (clarsimp simp: scorres_def valRel_RepParam RepParam.defs elim!: v_sem_elims)
  done

lemma scorres_struct_StepParam :
  "\<And>\<gamma> \<xi> s_acc s_obsv d_acc d_obsv.
  scorres s_acc d_acc \<gamma> \<xi> \<Longrightarrow>
  scorres s_obsv d_obsv \<gamma> \<xi> \<Longrightarrow>
  scorres (StepParam.make s_acc s_obsv) (Struct ts [d_acc, d_obsv]) \<gamma> \<xi>"
  apply (clarsimp simp: scorres_def valRel_StepParam StepParam.defs elim!: v_sem_elims)
  done

lemma scorres_struct_WordArrayGetP :
  "\<And>\<gamma> \<xi> s_arr s_idx s_val d_arr d_idx d_val.
  scorres s_arr d_arr \<gamma> \<xi> \<Longrightarrow>
  scorres s_idx d_idx \<gamma> \<xi> \<Longrightarrow>
  scorres s_val d_val \<gamma> \<xi> \<Longrightarrow>
  scorres (WordArrayGetP.make s_arr s_idx s_val) (Struct ts [d_arr, d_idx, d_val]) \<gamma> \<xi>"
  apply (clarsimp simp: scorres_def valRel_WordArrayGetP WordArrayGetP.defs elim!: v_sem_elims)
  done

lemma scorres_struct_WordArrayGetOP :
  "\<And>\<gamma> \<xi> s_arr s_idx d_arr d_idx.
  scorres s_arr d_arr \<gamma> \<xi> \<Longrightarrow>
  scorres s_idx d_idx \<gamma> \<xi> \<Longrightarrow>
  scorres (WordArrayGetOP.make s_arr s_idx) (Struct ts [d_arr, d_idx]) \<gamma> \<xi>"
  apply (clarsimp simp: scorres_def valRel_WordArrayGetOP WordArrayGetOP.defs elim!: v_sem_elims)
  done

lemmas scorres_structs =
  scorres_struct_T0
  scorres_struct_T1
  scorres_struct_RepParam
  scorres_struct_StepParam
  scorres_struct_WordArrayGetP
  scorres_struct_WordArrayGetOP

lemma shallow_tac_rec_field_T0__p1 :
  "shallow_tac_rec_field \<xi> (T0.p1\<^sub>f :: ('t_p1, 't_p2, 't_p3) T0 \<Rightarrow> 't_p1) T0.p1\<^sub>f_update 0"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_T0)
  done

lemma shallow_tac_rec_field_T0__p2 :
  "shallow_tac_rec_field \<xi> (T0.p2\<^sub>f :: ('t_p1, 't_p2, 't_p3) T0 \<Rightarrow> 't_p2) T0.p2\<^sub>f_update 1"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_T0)
  done

lemma shallow_tac_rec_field_T0__p3 :
  "shallow_tac_rec_field \<xi> (T0.p3\<^sub>f :: ('t_p1, 't_p2, 't_p3) T0 \<Rightarrow> 't_p3) T0.p3\<^sub>f_update 2"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_T0)
  done

lemma shallow_tac_rec_field_T1__p1 :
  "shallow_tac_rec_field \<xi> (T1.p1\<^sub>f :: ('t_p1, 't_p2) T1 \<Rightarrow> 't_p1) T1.p1\<^sub>f_update 0"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_T1)
  done

lemma shallow_tac_rec_field_T1__p2 :
  "shallow_tac_rec_field \<xi> (T1.p2\<^sub>f :: ('t_p1, 't_p2) T1 \<Rightarrow> 't_p2) T1.p2\<^sub>f_update 1"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_T1)
  done

lemma shallow_tac_rec_field_RepParam__n :
  "shallow_tac_rec_field \<xi> (RepParam.n\<^sub>f :: ('t_n, 't_stop, 't_step, 't_acc, 't_obsv) RepParam \<Rightarrow> 't_n) RepParam.n\<^sub>f_update 0"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_RepParam)
  done

lemma shallow_tac_rec_field_RepParam__stop :
  "shallow_tac_rec_field \<xi> (RepParam.stop\<^sub>f :: ('t_n, 't_stop, 't_step, 't_acc, 't_obsv) RepParam \<Rightarrow> 't_stop) RepParam.stop\<^sub>f_update 1"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_RepParam)
  done

lemma shallow_tac_rec_field_RepParam__step :
  "shallow_tac_rec_field \<xi> (RepParam.step\<^sub>f :: ('t_n, 't_stop, 't_step, 't_acc, 't_obsv) RepParam \<Rightarrow> 't_step) RepParam.step\<^sub>f_update 2"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_RepParam)
  done

lemma shallow_tac_rec_field_RepParam__acc :
  "shallow_tac_rec_field \<xi> (RepParam.acc\<^sub>f :: ('t_n, 't_stop, 't_step, 't_acc, 't_obsv) RepParam \<Rightarrow> 't_acc) RepParam.acc\<^sub>f_update 3"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_RepParam)
  done

lemma shallow_tac_rec_field_RepParam__obsv :
  "shallow_tac_rec_field \<xi> (RepParam.obsv\<^sub>f :: ('t_n, 't_stop, 't_step, 't_acc, 't_obsv) RepParam \<Rightarrow> 't_obsv) RepParam.obsv\<^sub>f_update 4"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_RepParam)
  done

lemma shallow_tac_rec_field_StepParam__acc :
  "shallow_tac_rec_field \<xi> (StepParam.acc\<^sub>f :: ('t_acc, 't_obsv) StepParam \<Rightarrow> 't_acc) StepParam.acc\<^sub>f_update 0"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_StepParam)
  done

lemma shallow_tac_rec_field_StepParam__obsv :
  "shallow_tac_rec_field \<xi> (StepParam.obsv\<^sub>f :: ('t_acc, 't_obsv) StepParam \<Rightarrow> 't_obsv) StepParam.obsv\<^sub>f_update 1"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_StepParam)
  done

lemma shallow_tac_rec_field_WordArrayGetP__arr :
  "shallow_tac_rec_field \<xi> (WordArrayGetP.arr\<^sub>f :: ('t_arr, 't_idx, 't_val) WordArrayGetP \<Rightarrow> 't_arr) WordArrayGetP.arr\<^sub>f_update 0"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_WordArrayGetP)
  done

lemma shallow_tac_rec_field_WordArrayGetP__idx :
  "shallow_tac_rec_field \<xi> (WordArrayGetP.idx\<^sub>f :: ('t_arr, 't_idx, 't_val) WordArrayGetP \<Rightarrow> 't_idx) WordArrayGetP.idx\<^sub>f_update 1"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_WordArrayGetP)
  done

lemma shallow_tac_rec_field_WordArrayGetP__val :
  "shallow_tac_rec_field \<xi> (WordArrayGetP.val\<^sub>f :: ('t_arr, 't_idx, 't_val) WordArrayGetP \<Rightarrow> 't_val) WordArrayGetP.val\<^sub>f_update 2"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_WordArrayGetP)
  done

lemma shallow_tac_rec_field_WordArrayGetOP__arr :
  "shallow_tac_rec_field \<xi> (WordArrayGetOP.arr\<^sub>f :: ('t_arr, 't_idx) WordArrayGetOP \<Rightarrow> 't_arr) WordArrayGetOP.arr\<^sub>f_update 0"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_WordArrayGetOP)
  done

lemma shallow_tac_rec_field_WordArrayGetOP__idx :
  "shallow_tac_rec_field \<xi> (WordArrayGetOP.idx\<^sub>f :: ('t_arr, 't_idx) WordArrayGetOP \<Rightarrow> 't_idx) WordArrayGetOP.idx\<^sub>f_update 1"
  apply (fastforce intro!: shallow_tac_rec_fieldI simp: valRel_WordArrayGetOP)
  done

lemmas scorres_rec_fields =
  shallow_tac_rec_field_T0__p1
  shallow_tac_rec_field_T0__p2
  shallow_tac_rec_field_T0__p3
  shallow_tac_rec_field_T1__p1
  shallow_tac_rec_field_T1__p2
  shallow_tac_rec_field_RepParam__n
  shallow_tac_rec_field_RepParam__stop
  shallow_tac_rec_field_RepParam__step
  shallow_tac_rec_field_RepParam__acc
  shallow_tac_rec_field_RepParam__obsv
  shallow_tac_rec_field_StepParam__acc
  shallow_tac_rec_field_StepParam__obsv
  shallow_tac_rec_field_WordArrayGetP__arr
  shallow_tac_rec_field_WordArrayGetP__idx
  shallow_tac_rec_field_WordArrayGetP__val
  shallow_tac_rec_field_WordArrayGetOP__arr
  shallow_tac_rec_field_WordArrayGetOP__idx

local_setup \<open>
gen_scorres_lemmas "Generated_ShallowShared" "Generated_Shallow_Normal" "Generated_Deep_Normal" Cogent_abstract_functions Cogent_functions
\<close>


end

end
