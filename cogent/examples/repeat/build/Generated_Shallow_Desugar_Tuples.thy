(*
This file is generated by Cogent

*)

theory Generated_Shallow_Desugar_Tuples
imports "Generated_ShallowShared_Tuples"
begin

definition
  wordarray_put32 :: "(32 word WordArray, 32 word, 32 word) WordArrayGetP \<Rightarrow> 32 word WordArray"
where
  "wordarray_put32 ds\<^sub>0 \<equiv>
    (wordarray_put :: (32 word WordArray, 32 word, 32 word) WordArrayGetP \<Rightarrow> 32 word WordArray) ds\<^sub>0"

definition
  expstop :: "(32 word, 32 word) StepParam \<Rightarrow> bool"
where
  "expstop ds\<^sub>0 \<equiv>
    False"

definition
  log2stop :: "(64 word \<times> 64 word, 64 word) StepParam \<Rightarrow> bool"
where
  "log2stop ds\<^sub>0 \<equiv>
    let acc = StepParam.acc\<^sub>f ds\<^sub>0;
      obsv = StepParam.obsv\<^sub>f ds\<^sub>0;
      (a,_) = acc
    in (>=) a obsv"

definition
  searchStop :: "(32 word \<times> 32 word \<times> bool, 32 word WordArray \<times> 32 word) StepParam \<Rightarrow> bool"
where
  "searchStop ds\<^sub>0 \<equiv>
    let acc = StepParam.acc\<^sub>f ds\<^sub>0;
      (l,r,b) = acc
    in if b
      then True
      else if (>=) l r
        then True
        else False"

definition
  expstep :: "(32 word, 32 word) StepParam \<Rightarrow> 32 word"
where
  "expstep ds\<^sub>0 \<equiv>
    let acc = StepParam.acc\<^sub>f ds\<^sub>0;
      obsv = StepParam.obsv\<^sub>f ds\<^sub>0
    in (*) acc obsv"

definition
  log2step :: "(64 word \<times> 64 word, 64 word) StepParam \<Rightarrow> 64 word \<times> 64 word"
where
  "log2step ds\<^sub>0 \<equiv>
    let acc = StepParam.acc\<^sub>f ds\<^sub>0;
      (a,b) = acc
    in ( (*) a (2 :: 64 word),
        (+) b (1 :: 64 word) )"

definition
  searchNext :: "(32 word \<times> 32 word \<times> bool, 32 word WordArray \<times> 32 word) StepParam \<Rightarrow> 32 word \<times> 32 word \<times> bool"
where
  "searchNext ds\<^sub>0 \<equiv>
    let acc = StepParam.acc\<^sub>f ds\<^sub>0;
      obsv = StepParam.obsv\<^sub>f ds\<^sub>0;
      (l,r,b) = acc;
      (arr,v) = obsv;
      m = (+) l (checked_div ((-) r l) (2 :: 32 word));
      args = \<lparr>
          WordArrayGetP.arr\<^sub>f = arr,
          idx\<^sub>f = m,
          val\<^sub>f = (0 :: 32 word)
        \<rparr>;
      x = (wordarray_get :: (32 word WordArray, 32 word, 32 word) WordArrayGetP \<Rightarrow> 32 word) args
    in if (<) x v
      then ( (+) m (1 :: 32 word), r,
          b )
      else if (>) x v
        then ( l, m, b )
        else ( m, r, True )"

definition
  binarySearch :: "32 word WordArray \<times> 32 word \<Rightarrow> 32 word"
where
  "binarySearch ds\<^sub>0 \<equiv>
    let (arr,v) = ds\<^sub>0;
      len = (wordarray_length :: 32 word WordArray \<Rightarrow> 32 word) arr;
      args = \<lparr>
          RepParam.n\<^sub>f = (ucast len :: 64 word),
          stop\<^sub>f = searchStop,
          step\<^sub>f = searchNext,
          acc\<^sub>f = ( (0 :: 32 word),
            len, False ), obsv\<^sub>f = (
            arr, v ) \<rparr>;
      ds\<^sub>3 = (repeat :: (64 word, (32 word \<times> 32 word \<times> bool, 32 word WordArray \<times> 32 word) StepParam \<Rightarrow> bool, (32 word \<times> 32 word \<times> bool, 32 word WordArray \<times> 32 word) StepParam \<Rightarrow> 32 word \<times> 32 word \<times> bool, 32 word \<times> 32 word \<times> bool, 32 word WordArray \<times> 32 word) RepParam \<Rightarrow> 32 word \<times> 32 word \<times> bool) args;
      (l,_,b) = ds\<^sub>3
    in if b then l else len"

definition
  myexp :: "32 word \<times> 32 word \<Rightarrow> 32 word"
where
  "myexp ds\<^sub>0 \<equiv>
    let (a,b) = ds\<^sub>0;
      args = \<lparr>
          RepParam.n\<^sub>f = (ucast b :: 64 word),
          stop\<^sub>f = expstop,
          step\<^sub>f = expstep,
          acc\<^sub>f = (1 :: 32 word),
          obsv\<^sub>f = a \<rparr>
    in (repeat :: (64 word, (32 word, 32 word) StepParam \<Rightarrow> bool, (32 word, 32 word) StepParam \<Rightarrow> 32 word, 32 word, 32 word) RepParam \<Rightarrow> 32 word) args"

definition
  mylog2 :: "64 word \<Rightarrow> 64 word"
where
  "mylog2 ds\<^sub>0 \<equiv>
    let args = \<lparr>
          RepParam.n\<^sub>f = ds\<^sub>0,
          stop\<^sub>f = log2stop,
          step\<^sub>f = log2step,
          acc\<^sub>f = ( (1 :: 64 word),
            (0 :: 64 word) ),
          obsv\<^sub>f = ds\<^sub>0
        \<rparr>;
      ds\<^sub>1 = (repeat :: (64 word, (64 word \<times> 64 word, 64 word) StepParam \<Rightarrow> bool, (64 word \<times> 64 word, 64 word) StepParam \<Rightarrow> 64 word \<times> 64 word, 64 word \<times> 64 word, 64 word) RepParam \<Rightarrow> 64 word \<times> 64 word) args;
      (_,b) = ds\<^sub>1
    in b"

definition
  wordarray_get_opt32 :: "(32 word WordArray, 32 word) WordArrayGetOP \<Rightarrow> (unit, 32 word) Opt"
where
  "wordarray_get_opt32 ds\<^sub>0 \<equiv>
    (wordarray_get_opt :: (32 word WordArray, 32 word) WordArrayGetOP \<Rightarrow> (unit, 32 word) Opt) ds\<^sub>0"

end
