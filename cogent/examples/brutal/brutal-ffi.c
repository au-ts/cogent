/* A "brutally minimal" example?
 *
 * 1. It searches a (disk) block that contains entries of varying
 * length.
 * 2. It returns a structure from a function.
 * 3. It points to a structure within a structure.
 * 4. It does pointer arithmetic.
 *
 * If this functionality had been generated by Cogent,
 *
 * (A) Would each Entry in block have to be copied somewhere before its
 * name could be accessed to see whether it’s "wombat"? (Here, there is
 * no copy.)
 *
 * (B) Would the thisEntry->stuff struct in a successful search have to
 * be copied onto the stack, to reach the caller? (Here, a pointer is
 * returned.)
 *
 * (C) Can thisEntry->stuff be pointed-to at all?
 *
 * (D) Would there be further difficulties if theStuff->b were to be
 * -updated- by the caller, rather than simply read? (In that case, the
 * overlap of block theStuff might cause problems with linear
 * reasoning.)
 *
 * Created by Craig McLaughlin from Carroll Morgan's "brutally minimal"
 * example.
 * Modified Aug 24 2021 by Craig McLaughlin:
 *      * Re-write example through the lens of the FFI for
 *        Buffer/DRecord/DArray.
 */
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>

#define CAP 4096

typedef struct stuff { // The data sought, item b in particular.
  int a,b,c;
} stuff_t;

typedef struct entry { // ... of varying length.
  int len; // Length in bytes of the whole entry.
  stuff_t stuff; // What the caller wants.
  char name[]; // The name of this particular "stuff";
              // a flexible array member.
} entry_t;

static unsigned long size = 2048;
char block[CAP]; // Contains Entry’s jammed together; terminated by
                  // len==0.

typedef char *buffer_t;
typedef buffer_t EntryBlock; // EntryBlock is size-constrained buffer
                             // type.

typedef entry_t *bitem_t;
typedef entry_t *btail_t;

enum tag_t {
    TAG_ENUM_Next,
    TAG_ENUM_None,
    TAG_ENUM_Return,
    TAG_ENUM_Some,
    TAG_ENUM_Stop,
    TAG_ENUM_Yield,
};
typedef enum tag_t tag_t;

typedef struct unit_t {
        int dummy;
} unit_t;

typedef struct gen_result {
  tag_t tag;
  bitem_t acc;
  stuff_t *ret;
  unit_t stop;
  unit_t yield;
} gen_result_t;

typedef struct cons_result {
  tag_t tag;
  bitem_t acc;
  stuff_t *ret;
  unit_t stop;
} cons_result_t;

typedef struct iter_result {
  tag_t tag;
  bitem_t acc;
  stuff_t *stuff;
  unit_t stop;
} iter_result_t;

typedef struct ret {
  unsigned long a;
  bitem_t item;
  btail_t tail;
} ret_t;

typedef struct option {
  tag_t tag;
  bitem_t item;
} option_t;

typedef struct arg {
  bitem_t item;
  btail_t tail;
  char *obsv;
} arg_t;

typedef struct pair {
  bitem_t acc;
  char *obsv;
} pair_t;

typedef struct focus_ret {
  unsigned long result;
  buffer_t b;
} focus_ret_t;

typedef ret_t (*view_func_t)(arg_t);
typedef gen_result_t (*generator_t)(pair_t);
typedef cons_result_t (*consumer_t)(pair_t);

typedef struct iter_arg {
  generator_t gen;
  consumer_t cons;
  bitem_t acc;
  char *obsv;
} iter_arg_t;

/** Look for entry with a specified name using the item & tail ptrs. */
ret_t sum_stuff(arg_t h);

static view_func_t views[] = {sum_stuff};

/** Access to an EntryBlock is provided by the following abstract
 *  function where the index points to a view_func_t */
focus_ret_t focus_buffer(buffer_t b, char *needle, unsigned int idx);

option_t next(bitem_t b);

entry_t *read(bitem_t b);

iter_result_t iterate_do(iter_arg_t arg);

gen_result_t gen_next_item(pair_t p) {
  gen_result_t ret = {0};
  option_t opt;
  opt = next(p.acc);
  if (opt.tag == TAG_ENUM_None) {
    ret.tag = TAG_ENUM_Stop;
    ret.acc = p.acc;
  } else {
    ret.tag = TAG_ENUM_Yield;
    ret.acc = opt.item;
  }
  return ret;
}

cons_result_t cons_next_item(pair_t p) {
  cons_result_t ret = {0};
  entry_t *e;
  bitem_t item = p.acc;
  char *needle = p.obsv;

  ret.acc = item;
  e = read(item);

  if (strcmp(needle, e->name) == 0) {
    ret.tag = TAG_ENUM_Return;
    ret.ret = &e->stuff;
  } else {
    ret.tag = TAG_ENUM_Next;
  }
  return ret;
}

ret_t sum_stuff(arg_t x) {
  ret_t p = {0};
  iter_arg_t arg = { gen_next_item, cons_next_item, x.item, x.obsv };
  iter_result_t ret = iterate_do(arg);

  if (ret.tag == TAG_ENUM_Stop) {
    p.a = -1;
    p.item = ret.acc;
    p.tail = x.tail;
  } else if (ret.tag == TAG_ENUM_Return) {
    p.a = ret.stuff->b;
    p.item = ret.acc;
    p.tail = x.tail;
  }
  return p;
}

iter_result_t iterate_do(iter_arg_t arg) {
  pair_t p = { arg.acc , arg.obsv };
  cons_result_t cr;
  gen_result_t gr;
  iter_result_t ret;
  while (1) {
    // consume
    cr = (arg.cons)(p);
    ret.acc = cr.acc;

    // test result of calling consumer
    // early exit
    if (cr.tag == TAG_ENUM_Stop) {
      ret.tag = TAG_ENUM_Stop;
      ret.stop = cr.stop;
      break;
    } else if (cr.tag == TAG_ENUM_Return) {
      ret.tag = TAG_ENUM_Return;
      ret.stuff = cr.ret;
      break;
    }

    p.acc = cr.acc;
    // generate next value
    gr = (arg.gen)(p);
    ret.acc = gr.acc;

    if (gr.tag == TAG_ENUM_Stop) {
      ret.tag = TAG_ENUM_Stop;
      ret.stop = gr.stop;
      break;
    } else if (gr.tag == TAG_ENUM_Return) {
      ret.tag = TAG_ENUM_Return;
      ret.stuff = gr.ret;
      break;
    }
    p.acc = gr.acc;
  }
  return ret;
}


focus_ret_t focus_buffer(buffer_t b, char *needle, unsigned int idx) {
  focus_ret_t ret = {0};
  arg_t arg = { (bitem_t)b , (btail_t)(b + size), needle };
  ret_t result;

  view_func_t f = views[idx];

  result = f(arg);

  ret.result = result.a;
  ret.b = b;
  return ret;
}

option_t next(bitem_t item) {
  option_t opt = {0};
  bitem_t b = (bitem_t)((char *)item + item->len);
  if (b->len == 0 || ((uintptr_t)b - (uintptr_t)block) >= size) {
    opt.tag = TAG_ENUM_None;
    opt.item = item;
  } else {
    opt.tag = TAG_ENUM_Some;
    opt.item = b;
  }
  return opt;
}

entry_t *read(bitem_t b) {
  return b;
}

/* Look for Entry with the specified name. */
stuff_t *find_stuff(char name[]) {
  entry_t *e = (entry_t *)&block;
  for (;;) {
    if (e->len == 0 || ((uintptr_t)e - (uintptr_t)block) >= size)
      break;
    if (strcmp(name, e->name) == 0)
      return &e->stuff;
    e = (entry_t *) ((char *)e + e->len);
  }
  return NULL;
}

int in_range(entry_t *e, unsigned long nlen) {
  unsigned long p = (uintptr_t)e + offsetof(entry_t,name) + nlen;
  return (p - (uintptr_t)block) < size;
}

/* Initialise our block of entries. */
/* Not translated into Cogent. */
void init(void) {
  FILE *fp;
  entry_t *e, *d;
  int a, b, c, len;
  char buf[80];

  memset(block, 0, CAP);

  if ((fp = fopen("entries.txt", "r")) != NULL) {
    e = (entry_t *)block;
    while (fscanf(fp, "%s%d%d%d\n", buf, &a, &b, &c) == 4) {
      len = strlen(buf)+1;
      if (!in_range(e, len)) {
        break;
      }
      strcpy(e->name, buf);
      e->stuff.a = a;
      e->stuff.b = b;
      e->stuff.c = c;
      e->len = ((uintptr_t)e->name + len) - (uintptr_t)e;
      e = (entry_t *) ((char *)e + e->len);
    }
    fclose(fp);
  }
}

int main() { // Print "b" attribute of Entry "wombat", if it’s there.
  focus_ret_t r;
  init();
  r = focus_buffer(block, "wombat", 0);
  if (r.result > 0)
    printf("Wombat’s b is %lu.\n", r.result);
  else
    printf("Wombat was not found.\n");
  return 0;
}
