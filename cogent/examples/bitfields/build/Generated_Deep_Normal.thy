(*
This file is generated by Cogent

*)

theory Generated_Deep_Normal
imports "Cogent.Cogent"
begin

definition
  abbreviatedType1 :: " Cogent.type"
where
  "abbreviatedType1 \<equiv> TRecord [(''f1'', (TPrim Bool, Present)), (''f2'', (TCon ''U2'' [] Unboxed, Present)), (''f3'', (TCon ''U4'' [] Unboxed, Present))] (Boxed Writable (Some (LayRecord [(''f1'', LayBitRange (Suc 0, 0)), (''f2'', LayBitRange (2, Suc 0)), (''f3'', LayBitRange (4, 4))])))"

lemmas abbreviated_type_defs =
  abbreviatedType1_def

definition
  u4_to_u8_type :: " poly_type"
where
  "u4_to_u8_type \<equiv> (0, [], {}, TCon ''U4'' [] Unboxed, TPrim (Num U8))"

definition
  u8_to_u4_type :: " poly_type"
where
  "u8_to_u4_type \<equiv> (0, [], {}, TPrim (Num U8), TCon ''U4'' [] Unboxed)"

definition
  u2_to_u8_type :: " poly_type"
where
  "u2_to_u8_type \<equiv> (0, [], {}, TCon ''U2'' [] Unboxed, TPrim (Num U8))"

definition
  u8_to_u2_type :: " poly_type"
where
  "u8_to_u2_type \<equiv> (0, [], {}, TPrim (Num U8), TCon ''U2'' [] Unboxed)"

definition
  id4_type :: " poly_type"
where
  "id4_type \<equiv> (0, [], {}, TCon ''U4'' [] (Boxed Writable None), TCon ''U4'' [] (Boxed Writable None))"

definition
  id4 :: "string Cogent.expr"
where
  "id4 \<equiv> Let (Var 0) (Var 0)"

definition
  id2_type :: " poly_type"
where
  "id2_type \<equiv> (0, [], {}, TCon ''U2'' [] (Boxed Writable None), TCon ''U2'' [] (Boxed Writable None))"

definition
  id2 :: "string Cogent.expr"
where
  "id2 \<equiv> Let (Var 0) (Var 0)"

definition
  foo_type :: " poly_type"
where
  "foo_type \<equiv> (0, [], {}, abbreviatedType1, abbreviatedType1)"

definition
  foo :: "string Cogent.expr"
where
  "foo \<equiv> Let (Var 0) (LetBang (set [0]) (Member (Var 0) 0) (If (Var 0) (LetBang (set [1]) (Let (Member (Var 1) 2) (Let (App (AFun ''u4_to_u8'' [] []) (Var 0)) (Let (Lit (LU8 12)) (Let (Prim (BitAnd U8) [Var 1, Var 0]) (App (AFun ''u8_to_u4'' [] []) (Var 0)))))) (Put (Var 2) 2 (Var 0))) (LetBang (set [1]) (Let (Member (Var 1) 1) (Let (App (AFun ''u2_to_u8'' [] []) (Var 0)) (Let (Lit (LU8 1)) (Let (Prim (Plus U8) [Var 1, Var 0]) (App (AFun ''u8_to_u2'' [] []) (Var 0)))))) (Put (Var 2) 1 (Var 0)))))"

ML \<open>
val Cogent_functions = ["id4", "id2", "foo"]
val Cogent_abstract_functions = ["u4_to_u8", "u8_to_u4", "u2_to_u8", "u8_to_u2"]
\<close>

end
