(*
This file is generated by Cogent

*)

theory Generated_Deep_Normal
imports "Cogent.Cogent"
begin

definition
  abbreviatedType1 :: " Cogent.type"
where
  "abbreviatedType1 \<equiv> TSum [(''Nothing'', (TUnit, Unchecked)), (''Something'', (TPrim (Num U32), Unchecked))]"

definition
  abbreviatedType2 :: " Cogent.type"
where
  "abbreviatedType2 \<equiv> TRecord [(''arr'', (TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly None), Present)), (''idx'', (TPrim (Num U32), Present))] Unboxed"

definition
  abbreviatedType3 :: " Cogent.type"
where
  "abbreviatedType3 \<equiv> TRecord [(''p1'', (TPrim (Num U32), Present)), (''p2'', (TPrim (Num U32), Present))] Unboxed"

definition
  abbreviatedType4 :: " Cogent.type"
where
  "abbreviatedType4 \<equiv> TRecord [(''p1'', (TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly None), Present)), (''p2'', (TPrim (Num U32), Present))] Unboxed"

definition
  abbreviatedType5 :: " Cogent.type"
where
  "abbreviatedType5 \<equiv> TRecord [(''p1'', (TPrim (Num U32), Present)), (''p2'', (TPrim (Num U32), Present)), (''p3'', (TPrim Bool, Present))] Unboxed"

definition
  abbreviatedType6 :: " Cogent.type"
where
  "abbreviatedType6 \<equiv> TRecord [(''acc'', (abbreviatedType5, Present)), (''obsv'', (abbreviatedType4, Present))] Unboxed"

definition
  abbreviatedType7 :: " Cogent.type"
where
  "abbreviatedType7 \<equiv> TRecord [(''p1'', (TPrim (Num U64), Present)), (''p2'', (TPrim (Num U64), Present))] Unboxed"

definition
  abbreviatedType8 :: " Cogent.type"
where
  "abbreviatedType8 \<equiv> TRecord [(''acc'', (abbreviatedType7, Present)), (''obsv'', (TPrim (Num U64), Present))] Unboxed"

definition
  abbreviatedType9 :: " Cogent.type"
where
  "abbreviatedType9 \<equiv> TRecord [(''acc'', (TPrim (Num U32), Present)), (''obsv'', (TPrim (Num U32), Present))] Unboxed"

definition
  abbreviatedType10 :: " Cogent.type"
where
  "abbreviatedType10 \<equiv> TRecord [(''arr'', (TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable None), Present)), (''idx'', (TPrim (Num U32), Present)), (''val'', (TPrim (Num U32), Present))] Unboxed"

lemmas abbreviated_type_defs =
  abbreviatedType1_def
  abbreviatedType6_def
  abbreviatedType8_def
  abbreviatedType9_def
  abbreviatedType2_def
  abbreviatedType10_def
  abbreviatedType3_def
  abbreviatedType5_def
  abbreviatedType7_def
  abbreviatedType4_def

definition
  wordarray_get_type :: " poly_type"
where
  "wordarray_get_type \<equiv> (0, [{E, S, D}], {}, TRecord [(''arr'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly None), Present)), (''idx'', (TPrim (Num U32), Present)), (''val'', (TVar 0, Present))] Unboxed, TVar 0)"

definition
  wordarray_length_type :: " poly_type"
where
  "wordarray_length_type \<equiv> (0, [{E, S, D}], {}, TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly None), TPrim (Num U32))"

definition
  wordarray_put_type :: " poly_type"
where
  "wordarray_put_type \<equiv> (0, [{E, S, D}], {}, TRecord [(''arr'', (TCon ''WordArray'' [TVar 0] (Boxed Writable None), Present)), (''idx'', (TPrim (Num U32), Present)), (''val'', (TVar 0, Present))] Unboxed, TCon ''WordArray'' [TVar 0] (Boxed Writable None))"

definition
  repeat_type :: " poly_type"
where
  "repeat_type \<equiv> (0, [{}, {}], {}, TRecord [(''n'', (TPrim (Num U64), Present)), (''stop'', (TFun (TRecord [(''acc'', (TVarBang 0, Present)), (''obsv'', (TVarBang 1, Present))] Unboxed) (TPrim Bool), Present)), (''step'', (TFun (TRecord [(''acc'', (TVar 0, Present)), (''obsv'', (TVarBang 1, Present))] Unboxed) (TVar 0), Present)), (''acc'', (TVar 0, Present)), (''obsv'', (TVarBang 1, Present))] Unboxed, TVar 0)"

definition
  wordarray_get_opt_type :: " poly_type"
where
  "wordarray_get_opt_type \<equiv> (0, [{E, S, D}], {}, TRecord [(''arr'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly None), Present)), (''idx'', (TPrim (Num U32), Present))] Unboxed, TSum [(''Nothing'', (TUnit, Unchecked)), (''Something'', (TVar 0, Unchecked))])"

definition
  wordarray_put32_type :: " poly_type"
where
  "wordarray_put32_type \<equiv> (0, [], {}, abbreviatedType10, TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable None))"

definition
  wordarray_put32 :: "string Cogent.expr"
where
  "wordarray_put32 \<equiv> Let (Var 0) (App (AFun ''wordarray_put'' [TPrim (Num U32)] []) (Var 0))"

definition
  expstop_type :: " poly_type"
where
  "expstop_type \<equiv> (0, [], {}, abbreviatedType9, TPrim Bool)"

definition
  expstop :: "string Cogent.expr"
where
  "expstop \<equiv> Let (Var 0) (Lit (LBool False))"

definition
  log2stop_type :: " poly_type"
where
  "log2stop_type \<equiv> (0, [], {}, abbreviatedType8, TPrim Bool)"

definition
  log2stop :: "string Cogent.expr"
where
  "log2stop \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 2) 0 (Take (Var 1) 1 (Prim (Ge U64) [Var 2, Var 4]))))"

definition
  searchStop_type :: " poly_type"
where
  "searchStop_type \<equiv> (0, [], {}, abbreviatedType6, TPrim Bool)"

definition
  searchStop :: "string Cogent.expr"
where
  "searchStop \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 2) 0 (Take (Var 1) 1 (Take (Var 1) 2 (If (Var 0) (Lit (LBool True)) (Let (Prim (Ge U32) [Var 4, Var 2]) (If (Var 0) (Lit (LBool True)) (Lit (LBool False)))))))))"

definition
  expstep_type :: " poly_type"
where
  "expstep_type \<equiv> (0, [], {}, abbreviatedType9, TPrim (Num U32))"

definition
  expstep :: "string Cogent.expr"
where
  "expstep \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Prim (Times U32) [Var 2, Var 0]))"

definition
  log2step_type :: " poly_type"
where
  "log2step_type \<equiv> (0, [], {}, abbreviatedType8, abbreviatedType7)"

definition
  log2step :: "string Cogent.expr"
where
  "log2step \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 2) 0 (Take (Var 1) 1 (Let (Lit (LU64 2)) (Let (Prim (Times U64) [Var 3, Var 0]) (Let (Lit (LU64 1)) (Let (Prim (Plus U64) [Var 3, Var 0]) (Struct [TPrim (Num U64), TPrim (Num U64)] [Var 2, Var 0]))))))))"

definition
  searchNext_type :: " poly_type"
where
  "searchNext_type \<equiv> (0, [], {}, abbreviatedType6, abbreviatedType5)"

definition
  searchNext :: "string Cogent.expr"
where
  "searchNext \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 2) 0 (Take (Var 1) 1 (Take (Var 1) 2 (Take (Var 6) 0 (Take (Var 1) 1 (Let (Prim (Minus U32) [Var 6, Var 8]) (Let (Lit (LU32 2)) (Let (Prim (Divide U32) [Var 1, Var 0]) (Let (Prim (Plus U32) [Var 11, Var 0]) (Let (Lit (LU32 0)) (Let (Struct [TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly None), TPrim (Num U32), TPrim (Num U32)] [Var 7, Var 1, Var 0]) (Let (App (AFun ''wordarray_get'' [TPrim (Num U32)] []) (Var 0)) (Let (Prim (Lt U32) [Var 0, Var 7]) (If (Var 0) (Let (Lit (LU32 1)) (Let (Prim (Plus U32) [Var 5, Var 0]) (Struct [TPrim (Num U32), TPrim (Num U32), TPrim Bool] [Var 0, Var 16, Var 14]))) (Let (Prim (Gt U32) [Var 1, Var 8]) (If (Var 0) (Struct [TPrim (Num U32), TPrim (Num U32), TPrim Bool] [Var 17, Var 5, Var 13]) (Let (Lit (LBool True)) (Struct [TPrim (Num U32), TPrim (Num U32), TPrim Bool] [Var 6, Var 16, Var 0])))))))))))))))))))"

definition
  binarySearch_type :: " poly_type"
where
  "binarySearch_type \<equiv> (0, [], {}, abbreviatedType4, TPrim (Num U32))"

definition
  binarySearch :: "string Cogent.expr"
where
  "binarySearch \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (App (AFun ''wordarray_length'' [TPrim (Num U32)] []) (Var 2)) (Let (Cast U64 (Var 0)) (Let (Fun searchStop [] []) (Let (Fun searchNext [] []) (Let (Lit (LU32 0)) (Let (Lit (LBool False)) (Let (Struct [TPrim (Num U32), TPrim (Num U32), TPrim Bool] [Var 1, Var 5, Var 0]) (Let (Struct [TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly None), TPrim (Num U32)] [Var 9, Var 7]) (Let (Struct [TPrim (Num U64), TFun abbreviatedType6 (TPrim Bool), TFun abbreviatedType6 abbreviatedType5, abbreviatedType5, abbreviatedType4] [Var 6, Var 5, Var 4, Var 1, Var 0]) (Let (App (AFun ''repeat'' [abbreviatedType5, abbreviatedType4] []) (Var 0)) (Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 1) 2 (If (Var 0) (Var 4) (Var 15))))))))))))))))"

definition
  myexp_type :: " poly_type"
where
  "myexp_type \<equiv> (0, [], {}, abbreviatedType3, TPrim (Num U32))"

definition
  myexp :: "string Cogent.expr"
where
  "myexp \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Let (Cast U64 (Var 0)) (Let (Fun expstop [] []) (Let (Fun expstep [] []) (Let (Lit (LU32 1)) (Let (Struct [TPrim (Num U64), TFun abbreviatedType9 (TPrim Bool), TFun abbreviatedType9 (TPrim (Num U32)), TPrim (Num U32), TPrim (Num U32)] [Var 3, Var 2, Var 1, Var 0, Var 6]) (App (AFun ''repeat'' [TPrim (Num U32), TPrim (Num U32)] []) (Var 0))))))))"

definition
  mylog2_type :: " poly_type"
where
  "mylog2_type \<equiv> (0, [], {}, TPrim (Num U64), TPrim (Num U64))"

definition
  mylog2 :: "string Cogent.expr"
where
  "mylog2 \<equiv> Let (Var 0) (Let (Fun log2stop [] []) (Let (Fun log2step [] []) (Let (Lit (LU64 1)) (Let (Lit (LU64 0)) (Let (Struct [TPrim (Num U64), TPrim (Num U64)] [Var 1, Var 0]) (Let (Struct [TPrim (Num U64), TFun abbreviatedType8 (TPrim Bool), TFun abbreviatedType8 abbreviatedType7, abbreviatedType7, TPrim (Num U64)] [Var 5, Var 4, Var 3, Var 0, Var 5]) (Let (App (AFun ''repeat'' [abbreviatedType7, TPrim (Num U64)] []) (Var 0)) (Take (Var 0) 0 (Take (Var 1) 1 (Var 0))))))))))"

definition
  wordarray_get_opt32_type :: " poly_type"
where
  "wordarray_get_opt32_type \<equiv> (0, [], {}, abbreviatedType2, abbreviatedType1)"

definition
  wordarray_get_opt32 :: "string Cogent.expr"
where
  "wordarray_get_opt32 \<equiv> Let (Var 0) (App (AFun ''wordarray_get_opt'' [TPrim (Num U32)] []) (Var 0))"

ML \<open>
val Cogent_functions = ["wordarray_put32", "expstop", "log2stop", "searchStop", "expstep", "log2step", "searchNext", "binarySearch", "myexp", "mylog2", "wordarray_get_opt32"]
val Cogent_abstract_functions = ["wordarray_get", "wordarray_length", "wordarray_put", "repeat", "wordarray_get_opt"]
\<close>

end
