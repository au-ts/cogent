(*
This file is generated by Cogent

*)

theory Generated_Shallow_Desugar
imports "Generated_ShallowShared"
begin

definition
  wordarray_put32 :: "32 word WordArrayPutP\<^sub>T \<Rightarrow> 32 word WordArray"
where
  "wordarray_put32 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>args. (wordarray_put :: 32 word WordArrayPutP\<^sub>T \<Rightarrow> 32 word WordArray) args)"

definition
  expstop :: "(32 word, 32 word) StepParam\<^sub>T \<Rightarrow> bool"
where
  "expstop ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. False)"

definition
  log2stop :: "((64 word, 64 word) T1, 64 word) StepParam\<^sub>T \<Rightarrow> bool"
where
  "log2stop ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 StepParam.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 StepParam.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t acc T1.p1\<^sub>f) (\<lambda>(a,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 T1.p2\<^sub>f) (\<lambda>(b,ds\<^sub>4). (>=) a obsv))))"

definition
  searchStop :: "((32 word, 32 word, bool) T0, (32 word WordArray, 32 word) T1) StepParam\<^sub>T \<Rightarrow> bool"
where
  "searchStop ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 StepParam.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 StepParam.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t acc T0.p1\<^sub>f) (\<lambda>(l,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 T0.p2\<^sub>f) (\<lambda>(r,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 T0.p3\<^sub>f) (\<lambda>(b,ds\<^sub>5). HOL.If b True (HOL.If ((>=) l r) True False))))))"

definition
  expstep :: "(32 word, 32 word) StepParam\<^sub>T \<Rightarrow> 32 word"
where
  "expstep ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 StepParam.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 StepParam.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). (*) acc obsv))"

definition
  log2step :: "((64 word, 64 word) T1, 64 word) StepParam\<^sub>T \<Rightarrow> (64 word, 64 word) T1"
where
  "log2step ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 StepParam.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 StepParam.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t acc T1.p1\<^sub>f) (\<lambda>(a,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 T1.p2\<^sub>f) (\<lambda>(b,ds\<^sub>4). T1.make ((*) a (2 :: 64 word)) ((+) b (1 :: 64 word))))))"

definition
  searchNext :: "((32 word, 32 word, bool) T0, (32 word WordArray, 32 word) T1) StepParam\<^sub>T \<Rightarrow> (32 word, 32 word, bool) T0"
where
  "searchNext ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 StepParam.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 StepParam.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t acc T0.p1\<^sub>f) (\<lambda>(l,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 T0.p2\<^sub>f) (\<lambda>(r,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 T0.p3\<^sub>f) (\<lambda>(b,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obsv T1.p1\<^sub>f) (\<lambda>(arr,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 T1.p2\<^sub>f) (\<lambda>(v,ds\<^sub>7). HOL.Let ((+) l (checked_div ((-) r l) (2 :: 32 word))) (\<lambda>m. HOL.Let (WordArrayGetP.make arr m (0 :: 32 word)) (\<lambda>args. HOL.Let ((wordarray_get :: 32 word WordArrayGetP\<^sub>T \<Rightarrow> 32 word) args) (\<lambda>x. HOL.If ((<) x v) (T0.make ((+) m (1 :: 32 word)) r b) (HOL.If ((>) x v) (T0.make l m b) (T0.make m r True))))))))))))"

definition
  binarySearch :: "(32 word WordArray, 32 word) T1 \<Rightarrow> 32 word"
where
  "binarySearch ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 T1.p1\<^sub>f) (\<lambda>(arr,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 T1.p2\<^sub>f) (\<lambda>(v,ds\<^sub>2). HOL.Let ((wordarray_length :: 32 word WordArray \<Rightarrow> 32 word) arr) (\<lambda>len. HOL.Let (RepParam.make (ucast len :: 64 word) searchStop searchNext (T0.make (0 :: 32 word) len False) (T1.make arr v)) (\<lambda>args. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ((repeat :: ((32 word, 32 word, bool) T0, (32 word WordArray, 32 word) T1) RepParam\<^sub>T \<Rightarrow> (32 word, 32 word, bool) T0) args) T0.p1\<^sub>f) (\<lambda>(l,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 T0.p2\<^sub>f) (\<lambda>(r,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 T0.p3\<^sub>f) (\<lambda>(b,ds\<^sub>5). HOL.If b l len)))))))"

definition
  myexp :: "(32 word, 32 word) T1 \<Rightarrow> 32 word"
where
  "myexp ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 T1.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 T1.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let (RepParam.make (ucast b :: 64 word) expstop expstep (1 :: 32 word) a) (\<lambda>args. (repeat :: (32 word, 32 word) RepParam\<^sub>T \<Rightarrow> 32 word) args)))"

definition
  mylog2 :: "64 word \<Rightarrow> 64 word"
where
  "mylog2 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>n. HOL.Let (RepParam.make n log2stop log2step (T1.make (1 :: 64 word) (0 :: 64 word)) n) (\<lambda>args. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ((repeat :: ((64 word, 64 word) T1, 64 word) RepParam\<^sub>T \<Rightarrow> (64 word, 64 word) T1) args) T1.p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 T1.p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). b))))"

definition
  wordarray_get_opt32 :: "32 word WordArrayGetOP\<^sub>T \<Rightarrow> 32 word Opt\<^sub>T"
where
  "wordarray_get_opt32 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>args. (wordarray_get_opt :: 32 word WordArrayGetOP\<^sub>T \<Rightarrow> 32 word Opt\<^sub>T) args)"

end
