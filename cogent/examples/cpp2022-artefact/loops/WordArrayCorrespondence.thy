(*
  This file contains the locale WordArray which includes the locale generated by AutoCorres from
  the C file containing the word array functions.
  
  This file also includes the proof that the WordArray locale is a subset of the top level 
  correspondence locale.
  This file also contains the various abstractions for the word array functions.
*)

theory WordArrayCorrespondence
  imports 
    "build/Generated_AllRefine"
    WordArrayUpdate
    WordArrayValue
    CorrespondenceHelper
    CogentTypingHelper
begin

(*
section "Abbreviations"

abbreviation "foldmap_funarg_type \<Xi>' x 
  \<equiv> (funarg_type \<circ> present_type \<circ> (\<lambda>xs. xs ! 3) \<circ> rec_type_list \<circ> prod.fst \<circ> prod.snd \<circ> \<Xi>') x"

abbreviation "foldmap_funret_type \<Xi>' x 
  \<equiv> (funret_type \<circ> present_type \<circ> (\<lambda>xs. xs ! 3) \<circ> rec_type_list \<circ> prod.fst \<circ> prod.snd \<circ> \<Xi>') x"

abbreviation "foldmap_acc_type \<Xi>' x 
  \<equiv> (present_type \<circ> (\<lambda>xs. xs ! 4) \<circ> rec_type_list \<circ> prod.fst \<circ> prod.snd \<circ> \<Xi>') x"

abbreviation "foldmap_obsv_type \<Xi>' x 
  \<equiv> (present_type \<circ> (\<lambda>xs. xs ! 5) \<circ> rec_type_list \<circ> prod.fst \<circ> prod.snd \<circ> \<Xi>') x"
*)

section "Base Level Locale"

locale level0 =
  upd: level0_update +
  val: level0_value
begin

definition l0uv_val :: "('f \<Rightarrow> poly_type) \<Rightarrow> abstyp \<Rightarrow> 'av \<Rightarrow> name \<Rightarrow> type list \<Rightarrow> sigil \<Rightarrow> 'l set \<Rightarrow> 'l set \<Rightarrow> ('f, 'au, 'l) store \<Rightarrow> bool"
  where
"l0uv_val \<Xi>' au av nm ts s r w \<sigma> = False"
end

sublocale level0 \<subseteq> correspondence upd.l0u_repr val.l0v_typing upd.l0u_typing l0uv_val
  apply (unfold l0uv_val_def[abs_def] val.l0v_typing_def[abs_def] upd.l0u_typing_def[abs_def] upd.l0u_repr_def[abs_def])
  apply (unfold_locales)
  by simp+

section "WordArray Locale Definition"

locale WordArray = 
  l0 : level0 +
  upd: WordArrayUpdate +
  val: WordArrayValue
begin

  definition  "wa_abs_upd_val \<Xi>' au av name \<tau>s sig (r :: ptrtyp set) (w :: ptrtyp set) \<sigma> \<equiv>
    upd.wa_abs_typing_u \<Xi>' au name \<tau>s sig r w \<sigma> \<and> val.wa_abs_typing_v \<Xi>' av name \<tau>s \<and>
    (case au of
      UWA t len arr \<Rightarrow>
        (case av of 
          VWA t' xs \<Rightarrow> unat len = length xs \<and> \<tau>s = [t] \<and> t = t' \<and> size_of_type t \<noteq> 0 \<and>
          (\<forall>i < len. \<exists>x x'. \<sigma> (arr + size_of_type t * i) = option.Some x \<and> xs ! unat i = x' \<and> l0.upd_val_rel \<Xi>' \<sigma> x x' t {} {})
          | _ \<Rightarrow> False)
      | _ \<Rightarrow> (case av of
                VTOther _ \<Rightarrow> True
             |  _ \<Rightarrow> False))"

lemma wa_abs_upd_val_elims:
  "wa_abs_upd_val \<Xi>' au av n \<tau>s s r w \<sigma> \<Longrightarrow> upd.wa_abs_typing_u \<Xi>' au n \<tau>s s r w \<sigma>"
  "wa_abs_upd_val \<Xi>' au av n \<tau>s s r w \<sigma> \<Longrightarrow> val.wa_abs_typing_v \<Xi>' av n \<tau>s"
  "wa_abs_upd_val \<Xi>' (UWA \<tau> len arr) (VWA \<tau> xs) n \<tau>s s r w \<sigma>
    \<Longrightarrow> unat len = length xs"
  "wa_abs_upd_val \<Xi>' (UWA t len arr) (VWA t xs) n \<tau>s s r w \<sigma>
    \<Longrightarrow> \<forall>i < len. \<exists>x x'. \<sigma> (arr + size_of_type t * i) = option.Some x \<and> 
      xs ! unat i = x' \<and> l0.upd_val_rel \<Xi>' \<sigma> x x' t {} {}"
  "wa_abs_upd_val \<Xi>' (UWA \<tau> len arr) av n \<tau>s s r w \<sigma>
    \<Longrightarrow> \<exists>xs. av = VWA \<tau> xs"
  "wa_abs_upd_val \<Xi>' au (VWA \<tau> xs) n \<tau>s s r w \<sigma>
    \<Longrightarrow> \<exists>len arr. au = UWA \<tau> len arr"
  "wa_abs_upd_val \<Xi>' (UWA t len arr) (VWA t' xs) n \<tau>s s r w \<sigma>
    \<Longrightarrow> t = t'"
  "wa_abs_upd_val \<Xi>' (UWA t len arr) (VWA t xs) n \<tau>s s r w \<sigma>
    \<Longrightarrow> size_of_type t \<noteq> 0"
  by (unfold wa_abs_upd_val_def[abs_def]; 
      clarsimp split: atyp.splits vatyp.splits type.splits prim_type.splits)+

lemma wa_abs_upd_val_update:
  "\<lbrakk>wa_abs_upd_val \<Xi>' (UWA t len arr) (VWA t xs) n \<tau>s (Boxed Writable ptrl) r w \<sigma>;
    i < len; l0.upd_val_rel \<Xi>' \<sigma> u v t {} {}\<rbrakk>
    \<Longrightarrow> wa_abs_upd_val \<Xi>' (UWA t len arr) (VWA t (xs[unat i := v])) n 
      \<tau>s (Boxed Writable ptrl) r w (\<sigma> ((arr + size_of_type t * i) \<mapsto> u))"
  apply (clarsimp simp: wa_abs_upd_val_def)
  apply (frule l0.upd_val_rel_to_uval_typing)
  apply (frule l0.upd_val_rel_to_vval_typing)
  apply (drule upd.wa_abs_typing_u_update; simp?; clarsimp)
  apply (drule_tac i = "unat i" in val.wa_abs_typing_v_update; simp add: word_less_nat_alt; clarsimp)
  apply (rule conjI; clarsimp simp: nth_list_update)
   apply (rule conjI; clarsimp)
    apply (erule l0.upd_val_rel_frame(1)[where w = "{}" and r = "{}", simplified, OF upd.frame_single_update])
   apply (rename_tac j)
   apply (cut_tac a = j and b = i and c = "size_of_type t" and d = len in word_mult_cancel_left_bounded; simp?)
     apply (clarsimp simp: word_less_nat_alt word_le_nat_alt)+
   apply (fastforce dest: upd.wa_abs_typing_u_elims(6))
  apply (rename_tac j)
  apply (erule_tac x = j in allE; clarsimp)
  apply (erule l0.upd_val_rel_frame(1)[where w = "{}" and r = "{}", simplified, OF upd.frame_single_update])
  done

end (* of context *)

sublocale WordArray \<subseteq> correspondence upd.wa_abs_repr val.wa_abs_typing_v upd.wa_abs_typing_u wa_abs_upd_val
  apply (unfold_locales)
     apply (unfold wa_abs_upd_val_def[abs_def]; clarsimp split: atyp.splits vatyp.splits)
    apply (unfold wa_abs_upd_val_def[abs_def]; clarsimp split: atyp.splits vatyp.splits)
   apply (unfold wa_abs_upd_val_def[abs_def]; clarsimp split: atyp.splits vatyp.splits)
     apply (drule upd.abs_typing_bang; simp)
    apply (drule val.abs_typing_bang; simp)
    apply (drule val.wa_abs_typing_v_elims(4); clarsimp simp: no_heap_imp_bang)
   apply (drule upd.abs_typing_bang; simp)
   apply (drule val.abs_typing_bang; simp)
  apply (unfold wa_abs_upd_val_def[abs_def]; clarsimp split: atyp.splits vatyp.splits)
   apply (drule upd.abs_typing_frame[rotated 1]; simp?)
   apply clarsimp
   apply (rename_tac len arr t xs i)
   apply (elim allE impE; assumption?)
   apply clarsimp
   apply (frule l0.upd_val_rel_frame; simp?)
   apply (intro exI conjI; simp?)
   apply (clarsimp simp: frame_def)
   apply (erule_tac x = "arr + size_of_type t * i" in allE)
   apply (drule val.wa_abs_typing_v_elims(3); clarsimp)
   apply (frule upd.wa_abs_typing_u_elims(4))
   apply (case_tac s; clarsimp; rename_tac perm ptrl; case_tac perm; clarsimp)
    apply (frule upd.wa_abs_typing_u_elims(2); clarsimp)
    apply (drule_tac x = "arr + size_of_type t * i" in orthD1; simp)
    apply (intro exI conjI; simp?)
   apply (frule upd.wa_abs_typing_u_elims(3); clarsimp)
   apply (drule_tac x = "arr + size_of_type t * i" in orthD1; simp)
   apply (intro exI conjI; simp?)
  apply (drule upd.abs_typing_frame[rotated 1]; simp?)
  done

context WordArray begin

lemma l0_imp_upd_val_rel:
  shows "l0.upd_val_rel \<Xi>' \<sigma> u v t r w\<Longrightarrow> upd_val_rel \<Xi>' \<sigma> u v t r w"
  and   "l0.upd_val_rel_record \<Xi>' \<sigma> us vs ts r w \<Longrightarrow> upd_val_rel_record \<Xi>' \<sigma> us vs ts r w"
proof (induct rule: l0.upd_val_rel_upd_val_rel_record.inducts)
qed (fastforce intro!: correspondence.upd_val_rel_upd_val_rel_record.intros[OF correspondence_axioms]
                 simp: upd.l0_eq_uval_repr upd.l0_eq_uval_repr_deep l0.l0uv_val_def)+

lemma no_tcon_upd_val_rel_imp_l0:
  "\<lbrakk>no_tvars t; no_tcon t; upd_val_rel \<Xi>' \<sigma> u v t r w\<rbrakk> \<Longrightarrow> l0.upd_val_rel \<Xi>' \<sigma> u v t r w"
proof (induct t arbitrary: \<sigma> u v r w)
case (TRecord x1a x2a)
  then show ?case 
    apply (clarsimp simp: find_None_iff_nth)
    apply (erule u_v_trecordE; clarsimp intro!: l0.upd_val_rel_upd_val_rel_record.intros)
      apply (drule upd_val_rel_record_alt1)
      apply (rule l0.upd_val_rel_record_alt2)
      apply clarsimp
      apply (rule exI, rule conjI, simp)
      apply (rule exI, rule conjI, simp)
      apply clarsimp
      apply (rename_tac i)
      apply (erule_tac x = i in allE; clarsimp)+
      apply (clarsimp simp: upd.l0_eq_uval_repr upd.l0_eq_uval_repr_deep set_conv_nth)
      apply (elim meta_allE meta_impE; simp?)
      apply (intro exI conjI; simp?)
     apply (rule l0.u_v_p_rec_ro; simp?)
     apply (drule upd_val_rel_record_alt1)
     apply (rule l0.upd_val_rel_record_alt2)
     apply clarsimp
     apply (rule exI, rule conjI, simp)
     apply (rule exI, rule conjI, simp)
     apply clarsimp
     apply (rename_tac i)
     apply (erule_tac x = i in allE; clarsimp)+
     apply (clarsimp simp: upd.l0_eq_uval_repr upd.l0_eq_uval_repr_deep set_conv_nth)
     apply (elim meta_allE meta_impE; simp?)
     apply (intro exI conjI; simp?)
    apply (rule l0.u_v_p_rec_w; simp?)
    apply (drule upd_val_rel_record_alt1)
    apply (rule l0.upd_val_rel_record_alt2)
    apply clarsimp
    apply (rule exI, rule conjI, simp)
    apply (rule exI, rule conjI, simp)
    apply clarsimp
    apply (rename_tac i)
    apply (erule_tac x = i in allE; clarsimp)+
    apply (clarsimp simp: upd.l0_eq_uval_repr upd.l0_eq_uval_repr_deep set_conv_nth)
    apply (elim meta_allE meta_impE; simp?)
    apply (intro exI conjI; simp?)
    done
qed (fastforce elim!: u_v_tfunE u_v_tprimE u_v_tsumE u_v_tproductE u_v_tunitE u_v_tcnumE
              intro!: l0.upd_val_rel_upd_val_rel_record.intros
                simp: find_None_iff)+

section "Word Array Methods"

subsection "wordarray_length"

lemma uvwa_length_monocorrespond_upward_propagation:
  "\<And>\<sigma> \<sigma>' au av v v' r w.
       \<lbrakk>upd_val_rel \<Xi>' \<sigma> au av (TCon ''WordArray'' \<tau>s (Boxed ReadOnly ptrl)) r w;
        uwa_length (\<sigma>, au) (\<sigma>', v)\<rbrakk>
       \<Longrightarrow> (vwa_length av v' \<longrightarrow>
            (\<exists>r' w'. upd_val_rel \<Xi>' \<sigma>' v v' (TPrim (Num U32)) r' w' \<and> r' \<subseteq> r \<and> frame \<sigma> w \<sigma>' w')) \<and>
            (\<exists>v'. vwa_length av v')"
  apply (clarsimp simp: uwa_length_def vwa_length_def)
  apply (erule u_v_uptrE; clarsimp)
  apply (rule conjI; clarsimp)
   apply (frule wa_abs_upd_val_elims(2)[THEN val.wa_abs_typing_v_elims(1)]; clarsimp)
   apply (frule wa_abs_upd_val_elims(5); clarsimp)
   apply (drule wa_abs_upd_val_elims(3); clarsimp)
   apply (intro exI conjI, rule  u_v_prim'; simp?)
   apply (rule upd.frame_id)
  apply (frule wa_abs_upd_val_elims(5); clarsimp)
  apply (drule wa_abs_upd_val_elims(3); clarsimp)
  apply (intro exI conjI, rule sym, assumption)
  done

subsection "wordarray_get"

lemma uvwa_get_monocorrespond_upward_propagation:
  "\<And>\<sigma> \<sigma>' au av v v' r w.
       \<lbrakk>upd_val_rel \<Xi>' \<sigma> au av  (TRecord 
                      [(''arr'', TCon ''WordArray'' [t] (Boxed ReadOnly ptrl), Present),
                       (''idx'', TPrim (Num U32), Present),
                       (''val'', t, Present)] Unboxed) r w;
        uwa_get (\<sigma>, au) (\<sigma>', v)\<rbrakk>
       \<Longrightarrow> (vwa_get av v' \<longrightarrow>
            (\<exists>r' w'. upd_val_rel \<Xi>' \<sigma>' v v' t r' w' \<and> r' \<subseteq> r \<and> frame \<sigma> w \<sigma>' w')) \<and>
            (\<exists>v'. vwa_get av v')"
  apply (clarsimp simp: uwa_get_def)
  apply (erule u_v_urecE; clarsimp)
  apply (erule u_v_r_consE'; clarsimp)+
  apply (erule u_v_r_uemptyE; clarsimp)
  apply (erule u_v_uptrE; clarsimp)
  apply (erule u_v_uprimE; clarsimp)
  apply (frule wa_abs_upd_val_elims(1)[THEN upd.wa_abs_typing_u_elims(1)]; clarsimp)
  apply (frule wa_abs_upd_val_elims(5); clarsimp)
  apply (frule wa_abs_upd_val_elims(2)[THEN val.wa_abs_typing_v_elims(4)])
  apply (frule wa_abs_upd_val_elims(3))
  apply (rename_tac \<sigma> \<sigma>' v v' p len arr i x x' rb wb rc xs)
  apply clarsimp
  apply (frule (2) u_v_no_heap_no_pointers)
  apply clarsimp
  apply (rule conjI; clarsimp)
   apply (clarsimp simp: vwa_get_def)
   apply (case_tac "unat i < length xs"; clarsimp simp: word_less_nat_alt)
    apply (drule wa_abs_upd_val_elims(4))
    apply (clarsimp simp: word_less_nat_alt)
    apply (elim allE impE, assumption)
    apply clarsimp
    apply (drule l0_imp_upd_val_rel)
    apply (intro exI conjI, assumption, blast, rule upd.frame_id)
   apply (intro exI conjI, assumption, blast, rule upd.frame_id)
  apply (clarsimp split: if_splits simp: word_less_nat_alt)
   apply (rule_tac x = "xs ! unat i" in exI)
   apply (clarsimp simp: vwa_get_def)
   apply (drule wa_abs_upd_val_elims(4))
  apply (erule_tac x = i in allE; clarsimp simp: word_less_nat_alt)
   apply (erule (3) val.no_tfun_imp_no_vfuns[OF _ _ _ upd_val_rel_to_vval_typing(1)[OF l0_imp_upd_val_rel(1)]])
  apply (rule_tac x = x' in exI)
  apply (clarsimp simp: vwa_get_def)
  apply (erule (3) val.no_tfun_imp_no_vfuns[OF _ _ _ upd_val_rel_to_vval_typing(1)])
  done

section "wordarray_put"

subsection "wordarray_get"

lemma uvwa_put_monocorrespond_upward_propagation:
  "\<And>\<sigma> \<sigma>' au av v v' r w.
       \<lbrakk>upd_val_rel \<Xi>' \<sigma> au av  (TRecord 
                      [(''arr'', TCon ''WordArray'' [t] (Boxed Writable ptrl), Present),
                       (''idx'', TPrim (Num U32), Present),
                       (''val'', t, Present)] Unboxed) r w;
        uwa_put (\<sigma>, au) (\<sigma>', v)\<rbrakk>
       \<Longrightarrow> (vwa_put av v' \<longrightarrow>
            (\<exists>r' w'. upd_val_rel \<Xi>' \<sigma>' v v' (TCon ''WordArray'' [t] (Boxed Writable ptrl)) r' w' \<and> 
              r' \<subseteq> r \<and> frame \<sigma> w \<sigma>' w')) \<and>
            (\<exists>v'. vwa_put av v')"
  apply (clarsimp simp: uwa_put_def)
  apply (erule u_v_urecE; clarsimp)
  apply (erule u_v_r_consE'; clarsimp)+
  apply (erule u_v_r_uemptyE; clarsimp)
  apply (erule u_v_uptrE; clarsimp)
  apply (erule u_v_uprimE; clarsimp)
  apply (drule_tac t = "type_repr _ " in sym)
  apply (frule wa_abs_upd_val_elims(1)[THEN upd.wa_abs_typing_u_elims(1)]; clarsimp)
  apply (frule wa_abs_upd_val_elims(5); clarsimp)
  apply (frule wa_abs_upd_val_elims(2)[THEN val.wa_abs_typing_v_elims(4)])
  apply (frule wa_abs_upd_val_elims(3); clarsimp)
  apply (frule (2) u_v_no_heap_no_pointers)
  apply clarsimp
  apply (rename_tac \<sigma> \<sigma>' v v' p len arr i ra x x' wa xs)
  apply (rule conjI; clarsimp)
   apply (rule_tac x = ra in exI)
   apply (rule_tac x = "insert p wa" in exI)
   apply (clarsimp split: if_splits simp: upd.frame_id)
    apply (frule wa_abs_upd_val_elims(1)[THEN upd.wa_abs_typing_u_elims(3)]; clarsimp)
    apply (rule conjI; clarsimp simp: vwa_put_def)
    apply (rule_tac a = "UWA t len arr" in u_v_p_abs_w[where ts = "[t]", simplified]; simp?)
      apply (rule wa_abs_upd_val_update; simp?)
      apply (erule (2) no_tcon_upd_val_rel_imp_l0)
     apply clarsimp
    apply (rule upd.frame_expand(1)[OF upd.frame_single_update_expand]; clarsimp)
    apply (intro exI conjI; simp)
   apply (clarsimp simp: vwa_put_def)
   apply (rule_tac a = "UWA t len arr" in u_v_p_abs_w[where ts = "[t]", simplified]; simp?)
   apply (clarsimp simp: word_less_nat_alt)
  apply (rule_tac x = "VAbstract (VWA t (xs[unat i := x']))" in exI)
  apply (clarsimp simp: vwa_put_def)
  apply (erule (3) val.no_tfun_imp_no_vfuns[OF _ _ _ upd_val_rel_to_vval_typing(1)])
  done

subsection "wordarray_get_opt"

lemma uvwa_get_opt_monocorrespond_upward_propagation:
  "\<And>\<sigma> \<sigma>' au av v v' r w.
       \<lbrakk>upd_val_rel \<Xi>' \<sigma> au av  (TRecord 
                      [(''arr'', TCon ''WordArray'' [t] (Boxed ReadOnly ptrl), Present),
                       (''idx'', TPrim (Num U32), Present)] Unboxed) r w;
        uwa_get_opt (\<sigma>, au) (\<sigma>', v)\<rbrakk>
       \<Longrightarrow> (vwa_get_opt av v' \<longrightarrow>
            (\<exists>r' w'. upd_val_rel \<Xi>' \<sigma>' v v' (TSum [(''Nothing'', TUnit, Unchecked), (''Something'', t, Unchecked)]) r' w' \<and>
              r' \<subseteq> r \<and> frame \<sigma> w \<sigma>' w')) \<and>
            (\<exists>v'. vwa_get_opt av v')"
  apply (clarsimp simp: uwa_get_opt_def)
  apply (erule u_v_urecE; clarsimp)
  apply (erule u_v_r_consE'; clarsimp)+
  apply (erule u_v_r_uemptyE; clarsimp)
  apply (erule u_v_uptrE; clarsimp)
  apply (erule u_v_uprimE; clarsimp)
  apply (drule_tac t = "type_repr _" in sym)
  apply (frule wa_abs_upd_val_elims(1)[THEN upd.wa_abs_typing_u_elims(1)]; clarsimp)
  apply (frule wa_abs_upd_val_elims(5); clarsimp)
  apply (frule wa_abs_upd_val_elims(2)[THEN val.wa_abs_typing_v_elims(4)])
  apply (frule wa_abs_upd_val_elims(3))
  apply clarsimp
  apply (rename_tac \<sigma> \<sigma>' v v' p len arr i rb xs)
  apply (rule conjI; clarsimp)
   apply (clarsimp simp: vwa_get_opt_def)
   apply (case_tac "unat i < length xs"; clarsimp simp: word_less_nat_alt)
    apply (drule wa_abs_upd_val_elims(4))
    apply (clarsimp simp: word_less_nat_alt)
    apply (elim allE impE, assumption)
    apply clarsimp
    apply (drule l0_imp_upd_val_rel)
    apply (rule_tac x = "{}" in exI)
    apply (rule_tac x = "{}" in exI)
    apply (fastforce intro!: u_v_sum simp: upd.frame_id)
   apply (rule_tac x = "{}" in exI)
   apply (rule_tac x = "{}" in exI)
   apply (fastforce intro!: u_v_sum u_v_unit simp: upd.frame_id)
  apply (clarsimp split: if_splits simp: word_less_nat_alt)
   apply (rule_tac x = "VSum ''Something'' (xs ! unat i)" in exI)
   apply (clarsimp simp: vwa_get_opt_def)
   apply (drule wa_abs_upd_val_elims(4))
   apply (erule_tac x = i in allE; clarsimp simp: word_less_nat_alt)
   apply (erule (3) val.no_tfun_imp_no_vfuns[OF _ _ _ upd_val_rel_to_vval_typing(1)[OF l0_imp_upd_val_rel(1)]])
  apply (rule_tac x = "VSum ''Nothing'' VUnit" in exI)
  apply (clarsimp simp: vwa_get_opt_def)
  done

end (* of context *)

end