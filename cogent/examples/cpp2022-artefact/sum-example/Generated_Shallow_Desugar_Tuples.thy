(*
This file is generated by Cogent

*)

theory Generated_Shallow_Desugar_Tuples
imports "Generated_ShallowShared_Tuples"
begin

definition
  wordarray_get_u32 :: "32 word WordArray \<times> 32 word \<Rightarrow> 32 word"
where
  "wordarray_get_u32 ds\<^sub>0 \<equiv>
    (wordarray_get :: 32 word WordArray \<times> 32 word \<Rightarrow> 32 word) ds\<^sub>0"

definition
  wordarray_length_u32 :: "32 word WordArray \<Rightarrow> 32 word"
where
  "wordarray_length_u32 ds\<^sub>0 \<equiv>
    (wordarray_length :: 32 word WordArray \<Rightarrow> 32 word) ds\<^sub>0"

definition
  wordarray_put2_u32 :: "(32 word WordArray, 32 word, 32 word) WordArrayPutP \<Rightarrow> 32 word WordArray"
where
  "wordarray_put2_u32 ds\<^sub>0 \<equiv>
    (wordarray_put2 :: (32 word WordArray, 32 word, 32 word) WordArrayPutP \<Rightarrow> 32 word WordArray) ds\<^sub>0"

definition
  add :: "(32 word, 32 word, unit) ElemAO \<Rightarrow> 32 word"
where
  "add ds\<^sub>0 \<equiv>
    let elem = ElemAO.elem\<^sub>f ds\<^sub>0;
      acc = ElemAO.acc\<^sub>f ds\<^sub>0
    in (+) elem acc"

definition
  sum_arr :: "32 word WordArray \<Rightarrow> 32 word"
where
  "sum_arr ds\<^sub>0 \<equiv>
    let e = (wordarray_length :: 32 word WordArray \<Rightarrow> 32 word) ds\<^sub>0;
      arg = \<lparr>
          WordArrayMapNoBreakP.arr\<^sub>f = ds\<^sub>0,
          frm\<^sub>f = (0 :: 32 word),
          to\<^sub>f = e, f\<^sub>f = add,
          acc\<^sub>f = (0 :: 32 word),
          obsv\<^sub>f = () \<rparr>
    in (wordarray_fold_no_break :: (32 word WordArray, 32 word, 32 word, (32 word, 32 word, unit) ElemAO \<Rightarrow> 32 word, 32 word, unit) WordArrayMapNoBreakP \<Rightarrow> 32 word) arg"

definition
  dec :: "(32 word, unit, unit) ElemAO \<Rightarrow> 32 word \<times> unit"
where
  "dec ds\<^sub>0 \<equiv>
    let elem = ElemAO.elem\<^sub>f ds\<^sub>0;
      acc = ElemAO.acc\<^sub>f ds\<^sub>0
    in ( (-) elem (1 :: 32 word),
        acc )"

definition
  dec_arr :: "32 word WordArray \<Rightarrow> 32 word WordArray \<times> unit"
where
  "dec_arr ds\<^sub>0 \<equiv>
    let end = (wordarray_length :: 32 word WordArray \<Rightarrow> 32 word) ds\<^sub>0;
      arg = \<lparr>
          WordArrayMapNoBreakP.arr\<^sub>f = ds\<^sub>0,
          frm\<^sub>f = (0 :: 32 word),
          to\<^sub>f = end,
          f\<^sub>f = dec,
          acc\<^sub>f = (),
          obsv\<^sub>f = () \<rparr>
    in (wordarray_map_no_break :: (32 word WordArray, 32 word, 32 word, (32 word, unit, unit) ElemAO \<Rightarrow> 32 word \<times> unit, unit, unit) WordArrayMapNoBreakP \<Rightarrow> 32 word WordArray \<times> unit) arg"

definition
  inc :: "(32 word, unit, unit) ElemAO \<Rightarrow> 32 word \<times> unit"
where
  "inc ds\<^sub>0 \<equiv>
    let elem = ElemAO.elem\<^sub>f ds\<^sub>0;
      acc = ElemAO.acc\<^sub>f ds\<^sub>0
    in ( (+) elem (1 :: 32 word),
        acc )"

definition
  inc_arr :: "32 word WordArray \<Rightarrow> 32 word WordArray \<times> unit"
where
  "inc_arr ds\<^sub>0 \<equiv>
    let end = (wordarray_length :: 32 word WordArray \<Rightarrow> 32 word) ds\<^sub>0;
      arg = \<lparr>
          WordArrayMapNoBreakP.arr\<^sub>f = ds\<^sub>0,
          frm\<^sub>f = (0 :: 32 word),
          to\<^sub>f = end,
          f\<^sub>f = inc,
          acc\<^sub>f = (),
          obsv\<^sub>f = () \<rparr>
    in (wordarray_map_no_break :: (32 word WordArray, 32 word, 32 word, (32 word, unit, unit) ElemAO \<Rightarrow> 32 word \<times> unit, unit, unit) WordArrayMapNoBreakP \<Rightarrow> 32 word WordArray \<times> unit) arg"

definition
  mul :: "(32 word, 32 word, unit) ElemAO \<Rightarrow> 32 word"
where
  "mul ds\<^sub>0 \<equiv>
    let elem = ElemAO.elem\<^sub>f ds\<^sub>0;
      acc = ElemAO.acc\<^sub>f ds\<^sub>0
    in (*) elem acc"

definition
  mul_arr :: "32 word WordArray \<Rightarrow> 32 word"
where
  "mul_arr ds\<^sub>0 \<equiv>
    let e = (wordarray_length :: 32 word WordArray \<Rightarrow> 32 word) ds\<^sub>0;
      arg = \<lparr>
          WordArrayMapNoBreakP.arr\<^sub>f = ds\<^sub>0,
          frm\<^sub>f = (0 :: 32 word),
          to\<^sub>f = e, f\<^sub>f = mul,
          acc\<^sub>f = (0 :: 32 word),
          obsv\<^sub>f = () \<rparr>
    in (wordarray_fold_no_break :: (32 word WordArray, 32 word, 32 word, (32 word, 32 word, unit) ElemAO \<Rightarrow> 32 word, 32 word, unit) WordArrayMapNoBreakP \<Rightarrow> 32 word) arg"

end
