(*
This file is generated by Cogent

*)

theory Generated_Deep_Normal
imports "Cogent.Cogent"
begin

definition
  abbreviatedType1 :: " Cogent.type"
where
  "abbreviatedType1 \<equiv> TRecord [(''elem'', (TPrim (Num U32), Present)), (''acc'', (TPrim (Num U32), Present)), (''obsv'', (TUnit, Present))] Unboxed"

definition
  abbreviatedType2 :: " Cogent.type"
where
  "abbreviatedType2 \<equiv> TRecord [(''p1'', (TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined), Present)), (''p2'', (TUnit, Present))] Unboxed"

definition
  abbreviatedType3 :: " Cogent.type"
where
  "abbreviatedType3 \<equiv> TRecord [(''p1'', (TPrim (Num U32), Present)), (''p2'', (TUnit, Present))] Unboxed"

definition
  abbreviatedType4 :: " Cogent.type"
where
  "abbreviatedType4 \<equiv> TRecord [(''elem'', (TPrim (Num U32), Present)), (''acc'', (TUnit, Present)), (''obsv'', (TUnit, Present))] Unboxed"

definition
  abbreviatedType5 :: " Cogent.type"
where
  "abbreviatedType5 \<equiv> TRecord [(''arr'', (TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined), Present)), (''idx'', (TPrim (Num U32), Present)), (''val'', (TPrim (Num U32), Present))] Unboxed"

definition
  abbreviatedType6 :: " Cogent.type"
where
  "abbreviatedType6 \<equiv> TRecord [(''p1'', (TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly undefined), Present)), (''p2'', (TPrim (Num U32), Present))] Unboxed"

lemmas abbreviated_type_defs =
  abbreviatedType5_def
  abbreviatedType4_def
  abbreviatedType1_def
  abbreviatedType3_def
  abbreviatedType6_def
  abbreviatedType2_def

definition
  wordarray_get_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_get_type \<equiv> ([{E, S, D}], (TRecord [(''p1'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), Present)), (''p2'', (TPrim (Num U32), Present))] Unboxed, TVar 0))"

definition
  wordarray_length_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_length_type \<equiv> ([{E, S, D}], (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), TPrim (Num U32)))"

definition
  wordarray_put2_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_put2_type \<equiv> ([{E, S, D}], (TRecord [(''arr'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''idx'', (TPrim (Num U32), Present)), (''val'', (TVar 0, Present))] Unboxed, TCon ''WordArray'' [TVar 0] (Boxed Writable undefined)))"

definition
  wordarray_fold_no_break_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_fold_no_break_type \<equiv> ([{E, S, D}, {}, {}], (TRecord [(''arr'', (TCon ''WordArray'' [TVarBang 0] (Boxed ReadOnly undefined), Present)), (''frm'', (TPrim (Num U32), Present)), (''to'', (TPrim (Num U32), Present)), (''f'', (TFun (TRecord [(''elem'', (TVar 0, Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVarBang 2, Present))] Unboxed) (TVar 1), Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVarBang 2, Present))] Unboxed, TVar 1))"

definition
  wordarray_map_no_break_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_map_no_break_type \<equiv> ([{E, S, D}, {}, {}], (TRecord [(''arr'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''frm'', (TPrim (Num U32), Present)), (''to'', (TPrim (Num U32), Present)), (''f'', (TFun (TRecord [(''elem'', (TVar 0, Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVarBang 2, Present))] Unboxed) (TRecord [(''p1'', (TVar 0, Present)), (''p2'', (TVar 1, Present))] Unboxed), Present)), (''acc'', (TVar 1, Present)), (''obsv'', (TVar 2, Present))] Unboxed, TRecord [(''p1'', (TCon ''WordArray'' [TVar 0] (Boxed Writable undefined), Present)), (''p2'', (TVar 1, Present))] Unboxed))"

definition
  wordarray_get_u32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_get_u32_type \<equiv> ([], (abbreviatedType6, TPrim (Num U32)))"

definition
  wordarray_get_u32 :: "string Cogent.expr"
where
  "wordarray_get_u32 \<equiv> Let (Var 0) (App (AFun ''wordarray_get'' [TPrim (Num U32)]) (Var 0))"

definition
  wordarray_length_u32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_length_u32_type \<equiv> ([], (TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly undefined), TPrim (Num U32)))"

definition
  wordarray_length_u32 :: "string Cogent.expr"
where
  "wordarray_length_u32 \<equiv> Let (Var 0) (App (AFun ''wordarray_length'' [TPrim (Num U32)]) (Var 0))"

definition
  wordarray_put2_u32_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "wordarray_put2_u32_type \<equiv> ([], (abbreviatedType5, TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined)))"

definition
  wordarray_put2_u32 :: "string Cogent.expr"
where
  "wordarray_put2_u32 \<equiv> Let (Var 0) (App (AFun ''wordarray_put2'' [TPrim (Num U32)]) (Var 0))"

definition
  add_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "add_type \<equiv> ([], (abbreviatedType1, TPrim (Num U32)))"

definition
  add :: "string Cogent.expr"
where
  "add \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 1) 2 (Prim (Plus U32) [Var 4, Var 2])))"

definition
  sum_arr_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "sum_arr_type \<equiv> ([], (TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly undefined), TPrim (Num U32)))"

definition
  sum_arr :: "string Cogent.expr"
where
  "sum_arr \<equiv> Let (Var 0) (Let (App (AFun ''wordarray_length'' [TPrim (Num U32)]) (Var 0)) (Let (Lit (LU32 0)) (Let (Fun add []) (Let (Lit (LU32 0)) (Let Unit (Let (Struct [TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly undefined), TPrim (Num U32), TPrim (Num U32), TFun abbreviatedType1 (TPrim (Num U32)), TPrim (Num U32), TUnit] [Var 5, Var 3, Var 4, Var 2, Var 1, Var 0]) (App (AFun ''wordarray_fold_no_break'' [TPrim (Num U32), TPrim (Num U32), TUnit]) (Var 0))))))))"

definition
  dec_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "dec_type \<equiv> ([], (abbreviatedType4, abbreviatedType3))"

definition
  dec :: "string Cogent.expr"
where
  "dec \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 1) 2 (Let (Lit (LU32 1)) (Let (Prim (Minus U32) [Var 5, Var 0]) (Struct [TPrim (Num U32), TUnit] [Var 0, Var 4])))))"

definition
  dec_arr_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "dec_arr_type \<equiv> ([], (TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined), abbreviatedType2))"

definition
  dec_arr :: "string Cogent.expr"
where
  "dec_arr \<equiv> Let (Var 0) (LetBang (set [0]) (App (AFun ''wordarray_length'' [TPrim (Num U32)]) (Var 0)) (Let (Lit (LU32 0)) (Let (Fun dec []) (Let Unit (Let Unit (Let (Struct [TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined), TPrim (Num U32), TPrim (Num U32), TFun abbreviatedType4 abbreviatedType3, TUnit, TUnit] [Var 5, Var 3, Var 4, Var 2, Var 1, Var 0]) (App (AFun ''wordarray_map_no_break'' [TPrim (Num U32), TUnit, TUnit]) (Var 0))))))))"

definition
  inc_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "inc_type \<equiv> ([], (abbreviatedType4, abbreviatedType3))"

definition
  inc :: "string Cogent.expr"
where
  "inc \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 1) 2 (Let (Lit (LU32 1)) (Let (Prim (Plus U32) [Var 5, Var 0]) (Struct [TPrim (Num U32), TUnit] [Var 0, Var 4])))))"

definition
  inc_arr_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "inc_arr_type \<equiv> ([], (TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined), abbreviatedType2))"

definition
  inc_arr :: "string Cogent.expr"
where
  "inc_arr \<equiv> Let (Var 0) (LetBang (set [0]) (App (AFun ''wordarray_length'' [TPrim (Num U32)]) (Var 0)) (Let (Lit (LU32 0)) (Let (Fun inc []) (Let Unit (Let Unit (Let (Struct [TCon ''WordArray'' [TPrim (Num U32)] (Boxed Writable undefined), TPrim (Num U32), TPrim (Num U32), TFun abbreviatedType4 abbreviatedType3, TUnit, TUnit] [Var 5, Var 3, Var 4, Var 2, Var 1, Var 0]) (App (AFun ''wordarray_map_no_break'' [TPrim (Num U32), TUnit, TUnit]) (Var 0))))))))"

definition
  mul_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "mul_type \<equiv> ([], (abbreviatedType1, TPrim (Num U32)))"

definition
  mul :: "string Cogent.expr"
where
  "mul \<equiv> Take (Var 0) 0 (Take (Var 1) 1 (Take (Var 1) 2 (Prim (Times U32) [Var 4, Var 2])))"

definition
  mul_arr_type :: " Cogent.kind list \<times>  Cogent.type \<times>  Cogent.type"
where
  "mul_arr_type \<equiv> ([], (TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly undefined), TPrim (Num U32)))"

definition
  mul_arr :: "string Cogent.expr"
where
  "mul_arr \<equiv> Let (Var 0) (Let (App (AFun ''wordarray_length'' [TPrim (Num U32)]) (Var 0)) (Let (Lit (LU32 0)) (Let (Fun mul []) (Let (Lit (LU32 0)) (Let Unit (Let (Struct [TCon ''WordArray'' [TPrim (Num U32)] (Boxed ReadOnly undefined), TPrim (Num U32), TPrim (Num U32), TFun abbreviatedType1 (TPrim (Num U32)), TPrim (Num U32), TUnit] [Var 5, Var 3, Var 4, Var 2, Var 1, Var 0]) (App (AFun ''wordarray_fold_no_break'' [TPrim (Num U32), TPrim (Num U32), TUnit]) (Var 0))))))))"

ML \<open>
val Cogent_functions = ["wordarray_get_u32", "wordarray_length_u32", "wordarray_put2_u32", "add", "sum_arr", "dec", "dec_arr", "inc", "inc_arr", "mul", "mul_arr"]
val Cogent_abstract_functions = ["wordarray_get", "wordarray_length", "wordarray_put2", "wordarray_fold_no_break", "wordarray_map_no_break"]
\<close>

end
