(*
This file is generated by Cogent

*)

theory BilbyFs_Shallow_Desugar_Tuples
imports "BilbyFs_ShallowShared_Tuples"
begin

definition
  snd :: "'a \<times> 'b \<Rightarrow> 'b"
where
  "snd ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P2_p2\<^sub>f) (\<lambda>(b,ds\<^sub>3). Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>4. b)))"

definition
  setu8 :: "(8 word, unit, 8 word) ElemAO \<Rightarrow> (8 word, unit) ElemA"
where
  "setu8 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(acc,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 ElemAO.obsv\<^sub>f) (\<lambda>(elem,ds\<^sub>1). ElemA.make elem acc))))"

definition
  serialise_size_u8 :: "8 word \<Rightarrow> 32 word"
where
  "serialise_size_u8 ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. (1 :: 32 word))"

definition
  serialise_size_le64 :: "64 word \<Rightarrow> 32 word"
where
  "serialise_size_le64 ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. (8 :: 32 word))"

definition
  serialise_size_le32 :: "32 word \<Rightarrow> 32 word"
where
  "serialise_size_le32 ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. (4 :: 32 word))"

definition
  second :: "('b \<Rightarrow> 'b') \<times> 'a \<times> 'b \<Rightarrow> 'a \<times> 'b'"
where
  "second ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(f,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p1\<^sub>f) (\<lambda>(a,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p2\<^sub>f) (\<lambda>(b,ds\<^sub>5). (a, f b)))))"

definition
  print_field_u64 :: "string \<times> 64 word \<Rightarrow> unit"
where
  "print_field_u64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>2,ds\<^sub>4). Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>2 (\<lambda>ds\<^sub>6. ()))))"

definition
  print_field_u32 :: "string \<times> 32 word \<Rightarrow> unit"
where
  "print_field_u32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>2,ds\<^sub>4). Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>2 (\<lambda>ds\<^sub>6. ()))))"

definition
  min_u64 :: "64 word \<times> 64 word \<Rightarrow> 64 word"
where
  "min_u64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.If ((<) a b) a b))"

definition
  min_u32 :: "32 word \<times> 32 word \<Rightarrow> 32 word"
where
  "min_u32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.If ((<) a b) a b))"

definition
  max_u64 :: "64 word \<times> 64 word \<Rightarrow> 64 word"
where
  "max_u64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.If ((<) a b) b a))"

definition
  max_u32 :: "32 word \<times> 32 word \<Rightarrow> 32 word"
where
  "max_u32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.If ((<) a b) b a))"

definition
  mark_used_modifier :: "(8 word, 32 word, unit) ElemAO \<Rightarrow> (8 word, 32 word) ElemA"
where
  "mark_used_modifier ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(nb_free_eb,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>1). Let\<^sub>d\<^sub>s ds\<^sub>6 (\<lambda>ds\<^sub>7. ElemA.make (1 :: 8 word) ((-) nb_free_eb (1 :: 32 word)))))))"

definition
  mark_dirty_modifier :: "(32 word, unit, 32 word) ElemAO \<Rightarrow> (32 word, unit) ElemA"
where
  "mark_dirty_modifier ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(dirt,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(len,ds\<^sub>1). ElemA.make ((+) dirt len) ()))))"

definition
  is_set :: "32 word \<times> 32 word \<Rightarrow> bool"
where
  "is_set ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(flags,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(mask,ds\<^sub>2). (~=) ((AND) flags mask) (0 :: 32 word)))"

definition
  in_range_u32 :: "32 word \<times> 32 word \<times> 32 word \<Rightarrow> bool"
where
  "in_range_u32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(needle,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(from\<^sub>r,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(to,ds\<^sub>3). HOL.If ((>=) needle from\<^sub>r \<and> (<) needle to) True False)))"

definition
  fst :: "'a \<times> 'b \<Rightarrow> 'a"
where
  "fst ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(a,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>4. a)))"

definition
  first :: "('a \<Rightarrow> 'a') \<times> 'a \<times> 'b \<Rightarrow> 'a' \<times> 'b"
where
  "first ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(f,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p1\<^sub>f) (\<lambda>(a,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p2\<^sub>f) (\<lambda>(b,ds\<^sub>5). (f a, b)))))"

definition
  drop :: "'a \<Rightarrow> unit"
where
  "drop ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. ())"

definition
  cogent_warn_u16 :: "16 word \<Rightarrow> unit"
where
  "cogent_warn_u16 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. cogent_warn_u32 (ucast x :: 32 word))"

definition
  cogent_low_16_bits :: "32 word \<Rightarrow> 16 word"
where
  "cogent_low_16_bits ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. u32_to_u16 ((AND) x (65535 :: 32 word)))"

definition
  cogent_high_16_bits :: "32 word \<Rightarrow> 16 word"
where
  "cogent_high_16_bits ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. u32_to_u16 (checked_shift shiftr ((AND) x (4294901760 :: 32 word)) (16 :: 32 word)))"

definition
  cogent_debug_u8 :: "8 word \<Rightarrow> unit"
where
  "cogent_debug_u8 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. cogent_debug_u32 (ucast x :: 32 word))"

definition
  cogent_debug_u16 :: "16 word \<Rightarrow> unit"
where
  "cogent_debug_u16 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>x. cogent_debug_u32 (ucast x :: 32 word))"

definition
  cmp_log_lvl :: "32 word \<Rightarrow> bool"
where
  "cmp_log_lvl ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>l. (~=) ((AND) l (0 :: 32 word)) (0 :: 32 word))"

definition
  cogent_log :: "32 word \<times> string \<Rightarrow> unit"
where
  "cogent_log ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(l,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(x,ds\<^sub>2). HOL.If (cmp_log_lvl l) (cogent_debug x) ()))"

definition
  cogent_log_bool :: "32 word \<times> bool \<Rightarrow> unit"
where
  "cogent_log_bool ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(l,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(bool,ds\<^sub>2). HOL.If (cmp_log_lvl l) (cogent_debug_bool bool) ()))"

definition
  cogent_log_u32 :: "32 word \<times> 32 word \<Rightarrow> unit"
where
  "cogent_log_u32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(l,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(x,ds\<^sub>2). HOL.If (cmp_log_lvl l) (cogent_debug_u32 x) ()))"

definition
  cogent_log_u16 :: "32 word \<times> 16 word \<Rightarrow> unit"
where
  "cogent_log_u16 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(l,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(x,ds\<^sub>2). cogent_log_u32 (l, (ucast x :: 32 word))))"

definition
  cogent_log_u8 :: "32 word \<times> 8 word \<Rightarrow> unit"
where
  "cogent_log_u8 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(l,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(x,ds\<^sub>2). cogent_log_u32 (l, (ucast x :: 32 word))))"

definition
  cogent_log_u32_hex :: "32 word \<times> 32 word \<Rightarrow> unit"
where
  "cogent_log_u32_hex ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(l,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(x,ds\<^sub>2). HOL.If (cmp_log_lvl l) (cogent_debug_u32_hex x) ()))"

definition
  cogent_log_u32_oct :: "32 word \<times> 32 word \<Rightarrow> unit"
where
  "cogent_log_u32_oct ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(l,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(x,ds\<^sub>2). HOL.If (cmp_log_lvl l) (cogent_debug_u32_oct x) ()))"

definition
  cogent_log_u64 :: "32 word \<times> 64 word \<Rightarrow> unit"
where
  "cogent_log_u64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(l,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(x,ds\<^sub>2). HOL.If (cmp_log_lvl l) (cogent_debug_u64 x) ()))"

definition
  cogent_log_u64_hex :: "32 word \<times> 64 word \<Rightarrow> unit"
where
  "cogent_log_u64_hex ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(l,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(x,ds\<^sub>2). HOL.If (cmp_log_lvl l) (cogent_debug_u64_hex x) ()))"

definition
  buffer_memset_loop :: "(8 word, unit, 8 word) ElemAO \<Rightarrow> 8 word \<times> unit"
where
  "buffer_memset_loop ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>5). Let\<^sub>d\<^sub>s ds\<^sub>6 (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 ElemAO.obsv\<^sub>f) (\<lambda>(val,ds\<^sub>1). (val, ()))))))"

definition
  binNot :: "64 word \<Rightarrow> 64 word"
where
  "binNot ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>w. (XOR) (18446744073709551615 :: 64 word) w)"

definition
  serialise_size_ObjSummary :: "32 word \<Rightarrow> 32 word"
where
  "serialise_size_ObjSummary ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>nb_sum_entry. (+) ((+) (4 :: 32 word) ((*) nb_sum_entry (26 :: 32 word))) (4 :: 32 word))"

definition
  is_len_and_type_ok :: "8 word \<times> 32 word \<Rightarrow> bool"
where
  "is_len_and_type_ok ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(otype,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(olen,ds\<^sub>2). HOL.If ((=) otype (0 :: 8 word)) ((=) olen ((+) (24 :: 32 word) (60 :: 32 word))) (HOL.If ((=) otype (1 :: 8 word)) ((>=) olen ((+) (24 :: 32 word) (8 :: 32 word))) (HOL.If ((=) otype (2 :: 8 word)) ((>=) olen ((+) ((+) (24 :: 32 word) (12 :: 32 word)) (8 :: 32 word))) (HOL.If ((=) otype (3 :: 8 word)) ((=) olen ((+) (24 :: 32 word) (8 :: 32 word))) (HOL.If ((=) otype (4 :: 8 word)) ((=) olen ((+) (24 :: 32 word) (40 :: 32 word))) (HOL.If ((=) otype (6 :: 8 word)) ((>=) olen ((+) (24 :: 32 word) (4 :: 32 word))) (HOL.If ((=) otype (5 :: 8 word)) ((>=) olen (24 :: 32 word)) False))))))))"

definition
  align64 :: "64 word \<times> 64 word \<Rightarrow> 64 word"
where
  "align64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(x,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(powof2,ds\<^sub>2). (AND) ((+) x ((-) powof2 (1 :: 64 word))) (NOT ((-) powof2 (1 :: 64 word)))))"

definition
  align32 :: "32 word \<times> 32 word \<Rightarrow> 32 word"
where
  "align32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(x,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(powof2,ds\<^sub>2). (AND) ((+) x ((-) powof2 (1 :: 32 word))) (NOT ((-) powof2 (1 :: 32 word)))))"

definition
  dtype_to_vtype :: "8 word \<Rightarrow> 32 word"
where
  "dtype_to_vtype ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>dtype. HOL.If ((=) dtype (0 :: 8 word)) (32768 :: 32 word) (HOL.If ((=) dtype (1 :: 8 word)) (16384 :: 32 word) (HOL.If ((=) dtype (2 :: 8 word)) (40960 :: 32 word) (HOL.If ((=) dtype (3 :: 8 word)) (24576 :: 32 word) (HOL.If ((=) dtype (4 :: 8 word)) (8192 :: 32 word) (HOL.If ((=) dtype (5 :: 8 word)) (4096 :: 32 word) (49152 :: 32 word)))))))"

definition
  vtype_to_dtype :: "32 word \<Rightarrow> 8 word"
where
  "vtype_to_dtype ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>vt. HOL.If ((=) vt (32768 :: 32 word)) (0 :: 8 word) (HOL.If ((=) vt (16384 :: 32 word)) (1 :: 8 word) (HOL.If ((=) vt (40960 :: 32 word)) (2 :: 8 word) (HOL.If ((=) vt (24576 :: 32 word)) (3 :: 8 word) (HOL.If ((=) vt (8192 :: 32 word)) (4 :: 8 word) (HOL.If ((=) vt (4096 :: 32 word)) (5 :: 8 word) (6 :: 8 word)))))))"

definition
  vmode_is_blk :: "32 word \<Rightarrow> bool"
where
  "vmode_is_blk ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>mode. (=) ((AND) mode (61440 :: 32 word)) (24576 :: 32 word))"

definition
  vmode_is_chr :: "32 word \<Rightarrow> bool"
where
  "vmode_is_chr ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>mode. (=) ((AND) mode (61440 :: 32 word)) (8192 :: 32 word))"

definition
  vmode_is_dir :: "32 word \<Rightarrow> bool"
where
  "vmode_is_dir ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>mode. (=) ((AND) mode (61440 :: 32 word)) (16384 :: 32 word))"

definition
  vmode_is_reg :: "32 word \<Rightarrow> bool"
where
  "vmode_is_reg ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>mode. (=) ((AND) mode (61440 :: 32 word)) (32768 :: 32 word))"

definition
  vmode_to_vtype :: "32 word \<Rightarrow> 32 word"
where
  "vmode_to_vtype ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>vm. (AND) vm (61440 :: 32 word))"

definition
  linux_decode_device_new :: "32 word \<Rightarrow> 32 word \<times> 32 word"
where
  "linux_decode_device_new ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>val. (checked_shift shiftr ((AND) val (1048320 :: 32 word)) (8 :: 32 word), (OR) ((AND) val (255 :: 32 word)) ((AND) (checked_shift shiftr val (12 :: 32 word)) (1048320 :: 32 word))))"

definition
  linux_decode_device_old :: "16 word \<Rightarrow> 32 word \<times> 32 word"
where
  "linux_decode_device_old ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>val. ((AND) (checked_shift shiftr (ucast val :: 32 word) (8 :: 32 word)) (255 :: 32 word), (AND) (ucast val :: 32 word) (255 :: 32 word)))"

definition
  linux_encode_device_new :: " VfsDevice \<Rightarrow> 32 word"
where
  "linux_encode_device_new ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>dev. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (vfs_device_inspect dev) P2_p1\<^sub>f) (\<lambda>(maj,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(min,ds\<^sub>2). (OR) ((OR) ((AND) min (255 :: 32 word)) (checked_shift shiftl maj (8 :: 32 word))) (checked_shift shiftl ((AND) min (NOT (255 :: 32 word))) (12 :: 32 word)))))"

definition
  linux_encode_device_old :: " VfsDevice \<Rightarrow> 16 word"
where
  "linux_encode_device_old ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>dev. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (vfs_device_inspect dev) P2_p1\<^sub>f) (\<lambda>(maj,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(min,ds\<^sub>2). checked_shift shiftl (u32_to_u16 maj) ((OR) (8 :: 16 word) (u32_to_u16 min)))))"

definition
  linux_valid_old_dev :: " VfsDevice \<Rightarrow> bool"
where
  "linux_valid_old_dev ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>dev. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (vfs_device_inspect dev) P2_p1\<^sub>f) (\<lambda>(maj,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(min,ds\<^sub>2). (<) maj (256 :: 32 word) \<and> (<) min (256 :: 32 word))))"

definition
  wordarray_free' :: "( SysState, 'a WordArray) T1 \<Rightarrow>  SysState"
where
  "wordarray_free' ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 T1.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 T1.obj\<^sub>f) (\<lambda>(obj,ds\<^sub>1). wordarray_free (ex, obj)))"

definition
  error :: "'b \<Rightarrow> ('b, 'a) R"
where
  "error ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>b. (R.Error b :: ('b, 'a) R))"

definition
  safe_add32 :: "32 word \<times> 32 word \<Rightarrow> (unit, 32 word) R"
where
  "safe_add32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((+) a b) (\<lambda>r. HOL.If ((<) r a \<or> (<) r b) (R.Error () :: (unit, 32 word) R) (R.Success r :: (unit, 32 word) R))))"

definition
  safe_add64 :: "64 word \<times> 64 word \<Rightarrow> (unit, 64 word) R"
where
  "safe_add64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((+) a b) (\<lambda>r. HOL.If ((<) r a \<or> (<) r b) (R.Error () :: (unit, 64 word) R) (R.Success r :: (unit, 64 word) R))))"

definition
  safe_sub32 :: "32 word \<times> 32 word \<Rightarrow> (unit, 32 word) R"
where
  "safe_sub32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((-) a b) (\<lambda>r. HOL.If ((>) r a) (R.Error () :: (unit, 32 word) R) (R.Success r :: (unit, 32 word) R))))"

definition
  safe_sub64 :: "64 word \<times> 64 word \<Rightarrow> (unit, 64 word) R"
where
  "safe_sub64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(a,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(b,ds\<^sub>2). HOL.Let ((-) a b) (\<lambda>r. HOL.If ((>) r a) (R.Error () :: (unit, 64 word) R) (R.Success r :: (unit, 64 word) R))))"

definition
  success :: "'a \<Rightarrow> ('b, 'a) R"
where
  "success ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>a. (R.Success a :: ('b, 'a) R))"

definition
  wordarray_clone :: " SysState \<times> 'a WordArray \<Rightarrow> ( SysState,  SysState \<times> 'a WordArray) R"
where
  "wordarray_clone ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(src,ds\<^sub>2). HOL.Let (wordarray_length src) (\<lambda>size. Let\<^sub>d\<^sub>s (wordarray_create (ex, size)) (\<lambda>ds\<^sub>3. case_R (\<lambda>ex. (R.Error ex :: ( SysState,  SysState \<times> 'a WordArray) R)) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(dest,ds\<^sub>7). (R.Success (ex, wordarray_copy (dest, src, (0 :: 32 word), (0 :: 32 word), size)) :: ( SysState,  SysState \<times> 'a WordArray) R)))) ds\<^sub>3))))"

definition
  wordarray_get_bounded :: "'a WordArray \<times> 32 word \<Rightarrow> (unit, 'a) R"
where
  "wordarray_get_bounded ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(arr,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(idx,ds\<^sub>2). HOL.If ((<) idx (wordarray_length arr)) (R.Success (wordarray_get (arr, idx)) :: (unit, 'a) R) (R.Error () :: (unit, 'a) R)))"

definition
  freeOptRbtNode :: " SysState \<times> (unit, ('k, 'v) RbtNode) Option \<Rightarrow>  SysState"
where
  "freeOptRbtNode ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(optnode,ds\<^sub>2). case_Option (\<lambda>ds\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>5. ex)) (\<lambda>node. freeRbtNode (ex, node)) optnode))"

definition
  optionToResult :: "(unit, 'a) Option \<Rightarrow> (unit, 'a) R"
where
  "optionToResult ds\<^sub>0 \<equiv> case_Option (\<lambda>ds\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>3. (R.Error () :: (unit, 'a) R))) (\<lambda>a. (R.Success a :: (unit, 'a) R)) ds\<^sub>0"

definition
  resultToOption :: "('e, 'a) R \<Rightarrow> (unit, 'a) Option"
where
  "resultToOption ds\<^sub>0 \<equiv> case_R (\<lambda>ds\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>3. (Option.None () :: (unit, 'a) Option))) (\<lambda>a. (Option.Some a :: (unit, 'a) Option)) ds\<^sub>0"

definition
  get_obj_trans :: "32 word \<times> 32 word \<Rightarrow> 8 word"
where
  "get_obj_trans ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(i,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(nb_objs,ds\<^sub>2). Let\<^sub>d\<^sub>s (cogent_assert ((>) nb_objs (0 :: 32 word))) (\<lambda>ds\<^sub>3. HOL.If ((=) i ((-) nb_objs (1 :: 32 word))) (2 :: 8 word) (1 :: 8 word))))"

definition
  deep_freeObjSuper :: " SysState \<times>  ObjSuper\<^sub>T \<Rightarrow>  SysState"
where
  "deep_freeObjSuper ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(v,ds\<^sub>2). freeObjSuper (ex, v)))"

definition
  mkObjSuper :: " ObjSuper\<^sub>T \<times>  UbiVolInfo \<times>  UbiDevInfo \<Rightarrow>  ObjSuper\<^sub>T"
where
  "mkObjSuper ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(sup,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(vol,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(dev,ds\<^sub>3). ObjSuper.next_sqnum\<^sub>f_update (\<lambda>_. (0 :: 64 word)) (ObjSuper.last_inum\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (ObjSuper.cur_offs\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (ObjSuper.cur_eb\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (ObjSuper.nb_reserved_del\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (ObjSuper.nb_reserved_gc\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (ObjSuper.io_size\<^sub>f_update (\<lambda>_. wubi_dev_min_io_size dev) (ObjSuper.eb_size\<^sub>f_update (\<lambda>_. wubi_vol_usable_leb_size vol) (ObjSuper.nb_eb\<^sub>f_update (\<lambda>_. wubi_vol_size vol) sup)))))))))))"

definition
  print_ObjSuper :: " ObjSuper\<^sub>T \<Rightarrow> unit"
where
  "print_ObjSuper ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. ())"

definition
  print_obj_super :: " ObjSuper\<^sub>T \<Rightarrow> unit"
where
  "print_obj_super ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. ())"

definition
  serialise_size_ObjSuper :: " ObjSuper\<^sub>T \<Rightarrow> 32 word"
where
  "serialise_size_ObjSuper ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. (40 :: 32 word))"

definition
  reinit_summary :: " ObjSummary\<^sub>T \<Rightarrow>  ObjSummary\<^sub>T"
where
  "reinit_summary ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>summary. ObjSummary.sum_offs\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (ObjSummary.nb_sum_entry\<^sub>f_update (\<lambda>_. (0 :: 32 word)) summary))"

definition
  serialise_size_summary_Obj_with_extra :: " ObjSummary\<^sub>T \<times> 32 word \<Rightarrow> 32 word"
where
  "serialise_size_summary_Obj_with_extra ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(summary,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(nb_extra,ds\<^sub>2). (+) (24 :: 32 word) (serialise_size_ObjSummary ((+) (ObjSummary.nb_sum_entry\<^sub>f summary) nb_extra))))"

definition
  obj_sum_entry_is_del :: " ObjSumEntry\<^sub>T \<Rightarrow> bool"
where
  "obj_sum_entry_is_del ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>entry. (~=) ((AND) (ObjSumEntry.del_flags_and_offs\<^sub>f entry) (2147483648 :: 32 word)) (0 :: 32 word))"

definition
  obj_sum_entry_offs :: " ObjSumEntry\<^sub>T \<Rightarrow> 32 word"
where
  "obj_sum_entry_offs ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>entry. (AND) (ObjSumEntry.del_flags_and_offs\<^sub>f entry) (NOT (2147483648 :: 32 word)))"

definition
  proc_obj_sum_f :: "( ObjSumEntry\<^sub>T, unit,  ObjSumEntry\<^sub>T) ElemAO \<Rightarrow> ( ObjSumEntry\<^sub>T, unit) ElemA"
where
  "proc_obj_sum_f ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>5). Let\<^sub>d\<^sub>s ds\<^sub>6 (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 ElemAO.obsv\<^sub>f) (\<lambda>(sum_entry,ds\<^sub>1). ElemA.make sum_entry ())))))"

definition
  summary_clean :: " SysState \<times>  ObjSummary\<^sub>T \<Rightarrow>  SysState"
where
  "summary_clean ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 ObjSummary.entries\<^sub>f) (\<lambda>(entries,sum). HOL.Let (wordarray_free (ex, entries)) (\<lambda>ex. freeObjSummary (ex, sum)))))"

definition
  deep_freeObjInode :: " SysState \<times>  ObjInode\<^sub>T \<Rightarrow>  SysState"
where
  "deep_freeObjInode ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(v,ds\<^sub>2). freeObjInode (ex, v)))"

definition
  serialise_size_ObjInode :: " ObjInode\<^sub>T \<Rightarrow> 32 word"
where
  "serialise_size_ObjInode ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. (60 :: 32 word))"

definition
  inum_from_obj_id :: "64 word \<Rightarrow> 32 word"
where
  "inum_from_obj_id ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>oid. u64_to_u32 (checked_shift shiftr oid (32 :: 64 word)))"

definition
  obj_id_inode_mk :: "32 word \<Rightarrow> 64 word"
where
  "obj_id_inode_mk ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>ino. (OR) (checked_shift shiftl (ucast ino :: 64 word) (32 :: 64 word)) (checked_shift shiftl (0 :: 64 word) (29 :: 64 word)))"

definition
  next_inode_id :: "64 word \<Rightarrow> 64 word"
where
  "next_inode_id ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>oid. HOL.Let (inum_from_obj_id oid) (\<lambda>inum. HOL.If ((=) inum (4294967295 :: 32 word)) (18446744073709551615 :: 64 word) (obj_id_inode_mk ((+) inum (1 :: 32 word)))))"

definition
  obj_id_data_mk :: "32 word \<times> 32 word \<Rightarrow> 64 word"
where
  "obj_id_data_mk ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ino,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(blk,ds\<^sub>2). (OR) ((OR) (obj_id_inode_mk ino) (checked_shift shiftl (1 :: 64 word) (29 :: 64 word))) (ucast blk :: 64 word)))"

definition
  obj_id_end_mk :: "32 word \<Rightarrow> 64 word"
where
  "obj_id_end_mk ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>ino. (OR) (obj_id_inode_mk ino) (4294967295 :: 64 word))"

definition
  obj_id_pad_mk :: "unit \<Rightarrow> 64 word"
where
  "obj_id_pad_mk ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. checked_shift shiftl (5 :: 64 word) (29 :: 64 word))"

definition
  obj_id_type :: "64 word \<Rightarrow> 64 word"
where
  "obj_id_type ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>oid. checked_shift shiftr ((AND) oid (checked_shift shiftl (7 :: 64 word) (29 :: 64 word))) (29 :: 64 word))"

definition
  obj_id_is_data :: "64 word \<Rightarrow> bool"
where
  "obj_id_is_data ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>oid. (=) (obj_id_type oid) (1 :: 64 word))"

definition
  obj_id_is_dentarr :: "64 word \<Rightarrow> bool"
where
  "obj_id_is_dentarr ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>oid. (=) (obj_id_type oid) (2 :: 64 word))"

definition
  obj_id_is_inode :: "64 word \<Rightarrow> bool"
where
  "obj_id_is_inode ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>oid. (=) (obj_id_type oid) (0 :: 64 word))"

definition
  deep_freeObjDentry :: " SysState \<times>  ObjDentry\<^sub>T \<Rightarrow>  SysState"
where
  "deep_freeObjDentry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 ObjDentry.name\<^sub>f) (\<lambda>(name,obj). HOL.Let (freeObjDentry (ex, obj)) (\<lambda>ex. wordarray_free (ex, name)))))"

definition
  deep_freeOptionObjDentry :: " SysState \<times> (unit,  ObjDentry\<^sub>T) Option \<Rightarrow>  SysState"
where
  "deep_freeOptionObjDentry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(opt_dent,ds\<^sub>2). case_Option (\<lambda>ds\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>5. ex)) (\<lambda>obj. deep_freeObjDentry (ex, obj)) opt_dent))"

definition
  del_dentry_modifier :: "( ObjDentry\<^sub>T,  SysState, 8 word WordArray) ElemAO \<Rightarrow>  SysState \<times> ( ObjDentry\<^sub>T, unit) R"
where
  "del_dentry_modifier ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(dentry,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ex,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(name,ds\<^sub>1). HOL.Let (wordarray_cmp (name, ObjDentry.name\<^sub>f dentry)) (\<lambda>same_names. HOL.If same_names (HOL.Let (deep_freeObjDentry (ex, dentry)) (\<lambda>ex. (ex, (R.Success () :: ( ObjDentry\<^sub>T, unit) R)))) (ex, (R.Error dentry :: ( ObjDentry\<^sub>T, unit) R))))))"

definition
  free_opt_ObjDentry :: " SysState \<times> (unit,  ObjDentry\<^sub>T) Option \<Rightarrow>  SysState"
where
  "free_opt_ObjDentry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(opt_entry,ds\<^sub>2). case_Option (\<lambda>ds\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>5. ex)) (\<lambda>old. deep_freeObjDentry (ex, old)) opt_entry))"

definition
  add_dentry_modifier :: "((unit,  ObjDentry\<^sub>T) Option,  SysState \<times> (unit,  ObjDentry\<^sub>T) Option) OptElemA \<Rightarrow> ((unit,  ObjDentry\<^sub>T) Option,  SysState \<times> (unit,  ObjDentry\<^sub>T) Option) OptElemA"
where
  "add_dentry_modifier ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 OptElemA.oelem\<^sub>f) (\<lambda>(old_entry,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 OptElemA.acc\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p2\<^sub>f) (\<lambda>(opt_newentry,ds\<^sub>5). case_Option (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s ds\<^sub>7 (\<lambda>ds\<^sub>8. OptElemA.make old_entry (ex, (Option.None () :: (unit,  ObjDentry\<^sub>T) Option)))) (\<lambda>newentry. HOL.Let (free_opt_ObjDentry (ex, old_entry)) (\<lambda>ex. OptElemA.make (Option.Some newentry :: (unit,  ObjDentry\<^sub>T) Option) (ex, (Option.None () :: (unit,  ObjDentry\<^sub>T) Option)))) opt_newentry))))"

definition
  print_ObjDentry :: " ObjDentry\<^sub>T \<Rightarrow> unit"
where
  "print_ObjDentry ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. ())"

definition
  serialise_size_ObjDentry :: " ObjDentry\<^sub>T \<Rightarrow> 32 word"
where
  "serialise_size_ObjDentry ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>dent. (+) (8 :: 32 word) (wordarray_length (ObjDentry.name\<^sub>f dent)))"

definition
  serialise_size_Arr_ObjDentry_f :: "( ObjDentry\<^sub>T, 32 word, unit) ElemAO \<Rightarrow> 32 word"
where
  "serialise_size_Arr_ObjDentry_f ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(dentry,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(sz,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>1). Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>5. (+) sz (serialise_size_ObjDentry dentry)))))"

definition
  serialise_size_ObjDel :: " ObjDel\<^sub>T \<Rightarrow> 32 word"
where
  "serialise_size_ObjDel ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. (8 :: 32 word))"

definition
  freeObjData :: " SysState \<times>  ObjData\<^sub>T \<Rightarrow>  SysState"
where
  "freeObjData ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(od,ds\<^sub>2). ex))"

definition
  deep_freeObjData :: " SysState \<times>  ObjData\<^sub>T \<Rightarrow>  SysState"
where
  "deep_freeObjData ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(v,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t v ObjData.odata\<^sub>f) (\<lambda>(odata,v). HOL.Let (wordarray_free (ex, odata)) (\<lambda>ex. freeObjData (ex, v)))))"

definition
  serialise_size_ObjData :: " ObjData\<^sub>T \<Rightarrow> 32 word"
where
  "serialise_size_ObjData ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>od. (+) (8 :: 32 word) (wordarray_length (ObjData.odata\<^sub>f od)))"

definition
  set_node :: "(64 word,  ObjAddr\<^sub>T) RbtNode \<times> 64 word \<times>  ObjAddr\<^sub>T \<Rightarrow> (64 word,  ObjAddr\<^sub>T) RbtNode"
where
  "set_node ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(node,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(oid,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(oaddr,ds\<^sub>3). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. HOL.Let (rbtnode_put_key (node, oid)) (\<lambda>node. rbtnode_put_val (node, oaddr))))))"

definition
  u64_to_TimeSpec :: "64 word \<Rightarrow>  OSTimeSpec\<^sub>T"
where
  "u64_to_TimeSpec ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>v. OSTimeSpec.make (u64_to_u32 (checked_shift shiftr v (32 :: 64 word))) (u64_to_u32 v))"

definition
  find_sum_entry_del_f :: "( ObjSumEntry\<^sub>T, 32 word, 64 word \<times> 64 word) ElemAO \<Rightarrow> ((unit, 32 word \<times> 16 word) Option, 32 word) LoopResult"
where
  "find_sum_entry_del_f ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(entry,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(idx,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(oid,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(sqnum,ds\<^sub>6). HOL.Let (obj_id_type oid) (\<lambda>oid_type. HOL.If ((=) oid_type (2 :: 64 word)) (HOL.If ((=) oid (ObjSumEntry.id\<^sub>f entry)) (HOL.If ((>) (ObjSumEntry.sqnum\<^sub>f entry) sqnum) (LoopResult.Break (Option.None () :: (unit, 32 word \<times> 16 word) Option) :: ((unit, 32 word \<times> 16 word) Option, 32 word) LoopResult) (LoopResult.Break (Option.Some (idx, ObjSumEntry.count\<^sub>f entry) :: (unit, 32 word \<times> 16 word) Option) :: ((unit, 32 word \<times> 16 word) Option, 32 word) LoopResult)) (LoopResult.Iterate ((+) idx (1 :: 32 word)) :: ((unit, 32 word \<times> 16 word) Option, 32 word) LoopResult)) (HOL.If ((=) (inum_from_obj_id oid) (inum_from_obj_id (ObjSumEntry.id\<^sub>f entry)) \<and> (>) (ObjSumEntry.id\<^sub>f entry) oid) (HOL.If ((>) (ObjSumEntry.sqnum\<^sub>f entry) sqnum) (LoopResult.Break (Option.None () :: (unit, 32 word \<times> 16 word) Option) :: ((unit, 32 word \<times> 16 word) Option, 32 word) LoopResult) (LoopResult.Break (Option.Some (idx, ObjSumEntry.count\<^sub>f entry) :: (unit, 32 word \<times> 16 word) Option) :: ((unit, 32 word \<times> 16 word) Option, 32 word) LoopResult)) (LoopResult.Iterate ((+) idx (1 :: 32 word)) :: ((unit, 32 word \<times> 16 word) Option, 32 word) LoopResult))))))))"

definition
  find_sum_entry_f :: "( ObjSumEntry\<^sub>T, 32 word, 64 word \<times> 64 word) ElemAO \<Rightarrow> ((unit, 32 word \<times> 16 word) Option, 32 word) LoopResult"
where
  "find_sum_entry_f ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(entry,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(idx,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(oid,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(sqnum,ds\<^sub>6). HOL.Let (obj_id_type oid) (\<lambda>oid_type. HOL.If (obj_sum_entry_is_del entry \<and> (~=) oid_type (2 :: 64 word)) (LoopResult.Iterate ((+) idx (1 :: 32 word)) :: ((unit, 32 word \<times> 16 word) Option, 32 word) LoopResult) (HOL.If ((=) oid (ObjSumEntry.id\<^sub>f entry)) (HOL.If ((>) (ObjSumEntry.sqnum\<^sub>f entry) sqnum) (LoopResult.Break (Option.None () :: (unit, 32 word \<times> 16 word) Option) :: ((unit, 32 word \<times> 16 word) Option, 32 word) LoopResult) (LoopResult.Break (Option.Some (idx, ObjSumEntry.count\<^sub>f entry) :: (unit, 32 word \<times> 16 word) Option) :: ((unit, 32 word \<times> 16 word) Option, 32 word) LoopResult)) (LoopResult.Iterate ((+) idx (1 :: 32 word)) :: ((unit, 32 word \<times> 16 word) Option, 32 word) LoopResult))))))))"

definition
  is_0xff :: "(8 word, unit, unit) ElemAO \<Rightarrow> (unit, unit) LoopResult"
where
  "is_0xff ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(c,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>1). Let\<^sub>d\<^sub>s ds\<^sub>6 (\<lambda>ds\<^sub>7. HOL.If ((=) c (255 :: 8 word)) (LoopResult.Iterate () :: (unit, unit) LoopResult) (LoopResult.Break () :: (unit, unit) LoopResult))))))"

definition
  obj_id_hash_map :: "(8 word, 32 word, unit) ElemAO \<Rightarrow> (32 word, 32 word) LoopResult"
where
  "obj_id_hash_map ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(elem,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(a,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). HOL.Let (ucast elem :: 32 word) (\<lambda>v. HOL.Let (checked_shift shiftl ((+) a v) (4 :: 32 word)) (\<lambda>a. HOL.Let (checked_shift shiftr ((+) a v) (4 :: 32 word)) (\<lambda>a. (LoopResult.Iterate ((*) a (11 :: 32 word)) :: (32 word, 32 word) LoopResult)))))))"

definition
  set_gim_node :: "(64 word,  GimNode\<^sub>T) RbtNode \<times> 64 word \<times> 16 word \<times> 64 word \<Rightarrow> (64 word,  GimNode\<^sub>T) RbtNode"
where
  "set_gim_node ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(node,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(oid,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(count,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(sqnum,ds\<^sub>4). HOL.Let (rbtnode_put_key (node, oid)) (\<lambda>node. rbtnode_put_val (node, GimNode.make count sqnum))))))"

definition
  gim_modifier :: "((64 word,  GimNode\<^sub>T) RbtNode, unit, 64 word \<times> 64 word \<times> 16 word) ElemAO \<Rightarrow> (64 word,  GimNode\<^sub>T) RbtNode \<times> unit"
where
  "gim_modifier ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(node,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P3_p1\<^sub>f) (\<lambda>(oid,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P3_p2\<^sub>f) (\<lambda>(sqnum,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P3_p3\<^sub>f) (\<lambda>(count,ds\<^sub>9). (set_gim_node (node, oid, count, sqnum), ()))))))))"

definition
  set_read_only_mode :: " FsopState\<^sub>T \<Rightarrow>  FsopState\<^sub>T"
where
  "set_read_only_mode ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopState.is_ro\<^sub>f) (\<lambda>(is_ro,fsop_st). FsopState.is_ro\<^sub>f_update (\<lambda>_. True) fsop_st)"

definition
  fsm_alloc_eb_loop_body :: "(8 word, 32 word,  FsmState\<^sub>T) ElemAO \<Rightarrow> (32 word, 32 word) LoopResult"
where
  "fsm_alloc_eb_loop_body ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(is_used,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ebnum,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. HOL.If ((~=) is_used (0 :: 8 word)) (LoopResult.Iterate ((+) ebnum (1 :: 32 word)) :: (32 word, 32 word) LoopResult) (LoopResult.Break ebnum :: (32 word, 32 word) LoopResult)))))"

definition
  fsm_clean :: " SysState \<times>  FsmState\<^sub>T \<Rightarrow>  SysState"
where
  "fsm_clean ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 FsmState.gim\<^sub>f) (\<lambda>(gim,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsmState.dirty_space\<^sub>f) (\<lambda>(dirty_space,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsmState.used_eb\<^sub>f) (\<lambda>(used_eb,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsmState.nb_free_eb\<^sub>f) (\<lambda>(nb_free_eb,fsm_st). HOL.Let (wordarray_free (ex, used_eb)) (\<lambda>ex. HOL.Let (wordarray_free (ex, dirty_space)) (\<lambda>ex. HOL.Let (rbt_free (ex, gim)) (\<lambda>ex. freeFsmState (ex, fsm_st))))))))))"

definition
  deep_freeVfsInode :: " SysState \<times>  VfsInode\<^sub>T \<Rightarrow>  SysState"
where
  "deep_freeVfsInode ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(v,ds\<^sub>2). freeVfsInode (ex, v)))"

definition
  free_opt_VfsInode :: " SysState \<times> (unit,  VfsInode\<^sub>T) Option \<Rightarrow>  SysState"
where
  "free_opt_VfsInode ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(opt_vnode,ds\<^sub>2). case_Option (\<lambda>ds\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>5. ex)) (\<lambda>v. deep_freeVfsInode (ex, v)) opt_vnode))"

definition
  vfs_inode_put_tuple :: " SysState \<times>  VfsInode\<^sub>T \<Rightarrow>  SysState"
where
  "vfs_inode_put_tuple ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(inode,ds\<^sub>2). vfs_inode_put (T6.make ex inode)))"

definition
  opt_vnode_set_nlink :: "(unit,  VfsInode\<^sub>T) Option \<times> 32 word \<Rightarrow> (unit,  VfsInode\<^sub>T) Option"
where
  "opt_vnode_set_nlink ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(opt,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(nlink,ds\<^sub>2). case_Option (\<lambda>ds\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>5. (Option.None () :: (unit,  VfsInode\<^sub>T) Option))) (\<lambda>v. (Option.Some (vfs_inode_set_nlink (v, nlink)) :: (unit,  VfsInode\<^sub>T) Option)) opt))"

definition
  vfs_inode_add_bytes :: " VfsInode\<^sub>T \<times> 64 word \<Rightarrow>  VfsInode\<^sub>T"
where
  "vfs_inode_add_bytes ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(inode,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(bytes,ds\<^sub>2). HOL.Let (vfs_inode_lock inode) (\<lambda>inode. HOL.Let (vfs_inode_get_blocks inode) (\<lambda>curblocks. HOL.Let ((+) curblocks (checked_shift shiftr bytes (9 :: 64 word))) (\<lambda>newblocks. HOL.Let (vfs_inode_set_blocks (inode, newblocks)) (\<lambda>inode. HOL.Let (u64_to_u16 ((AND) bytes (511 :: 64 word))) (\<lambda>bytes. HOL.Let (vfs_inode_get_bytes inode) (\<lambda>curbytes. HOL.Let ((+) curbytes bytes) (\<lambda>newbytes. HOL.Let (vfs_inode_set_bytes (inode, newbytes)) (\<lambda>inode. HOL.If ((>=) newbytes (512 :: 16 word)) (HOL.Let (vfs_inode_set_blocks (inode, (+) newblocks (1 :: 64 word))) (\<lambda>inode. HOL.Let (vfs_inode_set_bytes (inode, (-) newbytes (512 :: 16 word))) (\<lambda>inode. vfs_inode_unlock inode))) (vfs_inode_unlock inode)))))))))))"

definition
  vfs_inode_sub_bytes :: " VfsInode\<^sub>T \<times> 64 word \<Rightarrow>  VfsInode\<^sub>T"
where
  "vfs_inode_sub_bytes ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(inode,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(bytes,ds\<^sub>2). HOL.Let (vfs_inode_lock inode) (\<lambda>inode. HOL.Let (vfs_inode_get_blocks inode) (\<lambda>curblocks. HOL.Let ((-) curblocks (checked_shift shiftr bytes (9 :: 64 word))) (\<lambda>newblocks. HOL.Let (vfs_inode_set_blocks (inode, newblocks)) (\<lambda>inode. HOL.Let (u64_to_u16 ((AND) bytes (511 :: 64 word))) (\<lambda>bytes. HOL.Let (vfs_inode_get_bytes inode) (\<lambda>curbytes. HOL.Let ((-) curbytes bytes) (\<lambda>newbytes. HOL.Let (vfs_inode_set_bytes (inode, newbytes)) (\<lambda>inode. HOL.If ((<) curbytes bytes) (HOL.Let (vfs_inode_set_blocks (inode, (-) newblocks (1 :: 64 word))) (\<lambda>inode. HOL.Let (vfs_inode_set_bytes (inode, (+) newbytes (512 :: 16 word))) (\<lambda>inode. vfs_inode_unlock inode))) (vfs_inode_unlock inode)))))))))))"

definition
  vfs_rename_get_dest_dir2 :: " VfsRenameDirs\<^sub>T \<Rightarrow>  VfsInode\<^sub>T"
where
  "vfs_rename_get_dest_dir2 ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>dirs. case_VfsRenameDirs (\<lambda>dest_dir. dest_dir) (\<lambda>both. VfsRenameDirsDiff.dest_dir\<^sub>f both) dirs)"

definition
  vnode_init_perm :: " SysState \<times>  VfsInode\<^sub>T \<times>  VfsInode\<^sub>T \<times> 32 word \<Rightarrow>  SysState \<times>  VfsInode\<^sub>T"
where
  "vnode_init_perm ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(vdir,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(inode,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(mode,ds\<^sub>4). HOL.Let (os_get_current_fsuid ex) (\<lambda>v_uid. HOL.Let (is_set (vfs_inode_get_mode vdir, (1024 :: 32 word))) (\<lambda>is_gid. HOL.Let (HOL.If (is_gid \<and> vmode_is_dir mode) ((OR) mode (1024 :: 32 word)) mode) (\<lambda>mode. HOL.Let (HOL.If is_gid (vfs_inode_get_gid vdir) (os_get_current_fsgid ex)) (\<lambda>v_gid. HOL.Let (vfs_inode_set_uid (inode, v_uid)) (\<lambda>inode. HOL.Let (vfs_inode_set_gid (inode, v_gid)) (\<lambda>inode. HOL.Let (vfs_inode_set_mode (inode, mode)) (\<lambda>inode. (ex, inode))))))))))))"

definition
  index_get_addr :: " IndexState\<^sub>T \<times> 64 word \<Rightarrow> (32 word,  ObjAddr\<^sub>T) R"
where
  "index_get_addr ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(index_st,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(oid,ds\<^sub>2). Let\<^sub>d\<^sub>s (rbt_get_value (IndexState.addrs\<^sub>f index_st, oid)) (\<lambda>ds\<^sub>3. case_R (\<lambda>ds\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>6. (R.Error (2 :: 32 word) :: (32 word,  ObjAddr\<^sub>T) R))) (\<lambda>oaddr. (R.Success oaddr :: (32 word,  ObjAddr\<^sub>T) R)) ds\<^sub>3)))"

definition
  obj_dentry_new_init :: " SysState \<times> 32 word \<times> 8 word WordArray \<times> 8 word \<Rightarrow>  SysState \<times> (32 word,  ObjDentry\<^sub>T) R"
where
  "obj_dentry_new_init ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(ino,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(name,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(dtype,ds\<^sub>4). Let\<^sub>d\<^sub>s (newObjDentry ex) (\<lambda>ds\<^sub>5. case_R (\<lambda>ex. (ex, (R.Error (12 :: 32 word) :: (32 word,  ObjDentry\<^sub>T) R))) (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(odent,ds\<^sub>9). Let\<^sub>d\<^sub>s (wordarray_clone (ex, name)) (\<lambda>ds\<^sub>1\<^sub>0. case_R (\<lambda>ex. (freeObjDentry (ex, odent), (R.Error (12 :: 32 word) :: (32 word,  ObjDentry\<^sub>T) R))) (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(name,ds\<^sub>1\<^sub>4). HOL.Let (u32_to_u16 (wordarray_length name)) (\<lambda>nlen. (ex, (R.Success (ObjDentry.name\<^sub>f_update (\<lambda>_. name) (ObjDentry.nlen\<^sub>f_update (\<lambda>_. nlen) (ObjDentry.ino\<^sub>f_update (\<lambda>_. ino) (ObjDentry.dtype\<^sub>f_update (\<lambda>_. dtype) odent)))) :: (32 word,  ObjDentry\<^sub>T) R)))))) ds\<^sub>1\<^sub>0)))) ds\<^sub>5)))))"

definition
  rbtFTrue :: "(('k, 'v) RbtNode, 'acc, 'obsv) ElemAO \<Rightarrow> bool"
where
  "rbtFTrue ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. True)"

definition
  fsm_mark_dirty_use :: "((64 word,  GimNode\<^sub>T) RbtNode,  SysState \<times> (64 word,  GimNode\<^sub>T) Rbt, 64 word \<times> 64 word \<times> 16 word) ElemAO \<Rightarrow>  SysState \<times> (64 word,  GimNode\<^sub>T) Rbt"
where
  "fsm_mark_dirty_use ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(node,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(gim,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P3_p1\<^sub>f) (\<lambda>(oid,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P3_p2\<^sub>f) (\<lambda>(sqnum,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p3\<^sub>f) (\<lambda>(count,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (rbt_modify (RbtModifyP.make gim oid gim_modifier node () (oid, sqnum, count))) RbtModifyR.rbt\<^sub>f) (\<lambda>(gim,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 RbtModifyR.optnode\<^sub>f) (\<lambda>(optnode,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 RbtModifyR.acc\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>4,ds\<^sub>1\<^sub>1). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>4 (\<lambda>ds\<^sub>1\<^sub>5. HOL.Let (freeOptRbtNode (ex, optnode)) (\<lambda>ex. (ex, gim))))))))))))))"

definition
  find_sum_entry :: " ObjSummary\<^sub>T \<times> 64 word \<times> 64 word \<times> 8 word \<Rightarrow> (unit, 32 word \<times> 16 word) R"
where
  "find_sum_entry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(summary,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(oid,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(sqnum,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(otype,ds\<^sub>4). Let\<^sub>d\<^sub>s (HOL.If ((=) otype (3 :: 8 word)) (wordarray_fold (ArrayMapP.make (ObjSummary.entries\<^sub>f summary) (0 :: 32 word) (ObjSummary.nb_sum_entry\<^sub>f summary) find_sum_entry_del_f (0 :: 32 word) (oid, sqnum))) (wordarray_fold (ArrayMapP.make (ObjSummary.entries\<^sub>f summary) (0 :: 32 word) (ObjSummary.nb_sum_entry\<^sub>f summary) find_sum_entry_f (0 :: 32 word) (oid, sqnum)))) (\<lambda>ds\<^sub>5. case_LoopResult (\<lambda>opt. optionToResult opt) (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s ds\<^sub>7 (\<lambda>ds\<^sub>8. (R.Success (ObjSummary.nb_sum_entry\<^sub>f summary, (0 :: 16 word)) :: (unit, 32 word \<times> 16 word) R))) ds\<^sub>5)))))"

definition
  obj_id_hash_name :: "8 word WordArray \<Rightarrow> 32 word"
where
  "obj_id_hash_name ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>nm. HOL.Let (0 :: 32 word) (\<lambda>a. HOL.Let (wordarray_length nm) (\<lambda>len. Let\<^sub>d\<^sub>s (wordarray_fold (ArrayMapP.make nm (0 :: 32 word) len obj_id_hash_map a ())) (\<lambda>ds\<^sub>1. case_LoopResult (\<lambda>a. Let\<^sub>d\<^sub>s (cogent_assert False) (\<lambda>ds\<^sub>3. (AND) a (u64_to_u32 (536870911 :: 64 word)))) (\<lambda>a. (AND) a (u64_to_u32 (536870911 :: 64 word))) ds\<^sub>1))))"

definition
  obj_id_dentarr_mk :: "32 word \<times> 8 word WordArray \<Rightarrow> 64 word"
where
  "obj_id_dentarr_mk ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ino,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(name,ds\<^sub>2). HOL.Let (checked_shift shiftl (ucast ino :: 64 word) (32 :: 64 word)) (\<lambda>oid. HOL.Let (ucast (obj_id_hash_name name) :: 64 word) (\<lambda>h. (OR) ((OR) oid (checked_shift shiftl (2 :: 64 word) (29 :: 64 word))) h))))"

definition
  copy_n :: "('a, 32 word, 'a WordArray) ElemAO \<Rightarrow> 'a \<times> 32 word"
where
  "copy_n ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(elem,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(idx,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(afrm,ds\<^sub>1). (wordarray_get (afrm, idx), (+) idx (1 :: 32 word)))))"

definition
  check_flash_empty_loop :: "( SysState,  UbiVol, 32 word) Seq32_bodyParam \<Rightarrow>  SysState \<times> (32 word, unit) LoopResult"
where
  "check_flash_empty_loop ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 Seq32_bodyParam.acc\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 Seq32_bodyParam.obsv\<^sub>f) (\<lambda>(ubi_vol,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 Seq32_bodyParam.idx\<^sub>f) (\<lambda>(i,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (wubi_is_mapped (WubiIsMappedP.make ex ubi_vol i)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>5). case_R (\<lambda>err. (ex, (LoopResult.Break err :: (32 word, unit) LoopResult))) (\<lambda>is_mapped. HOL.If is_mapped (ex, (LoopResult.Break (39 :: 32 word) :: (32 word, unit) LoopResult)) (ex, (LoopResult.Iterate () :: (32 word, unit) LoopResult))) r)))))"

definition
  new_delnode_sum_init :: " SysState \<times>  ObjSumEntry\<^sub>T \<times> 32 word \<Rightarrow> ( SysState,  SysState \<times>  DelNode\<^sub>T ListNode) R"
where
  "new_delnode_sum_init ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(sum_entry,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(ebnum,ds\<^sub>3). Let\<^sub>d\<^sub>s (newListNode ex) (\<lambda>ds\<^sub>4. case_R (\<lambda>ex. (R.Error ex :: ( SysState,  SysState \<times>  DelNode\<^sub>T ListNode) R)) (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(del,ds\<^sub>8). HOL.Let (ObjAddr.make ebnum (obj_sum_entry_offs sum_entry) (ObjSumEntry.len\<^sub>f sum_entry) (ObjSumEntry.sqnum\<^sub>f sum_entry)) (\<lambda>oaddr. HOL.Let (listnode_put (del, DelNode.make (ObjSumEntry.id\<^sub>f sum_entry) oaddr)) (\<lambda>del. (R.Success (ex, del) :: ( SysState,  SysState \<times>  DelNode\<^sub>T ListNode) R)))))) ds\<^sub>4))))"

definition
  emit_dir :: "( ObjDentry\<^sub>T,  VfsDirContext\<^sub>T \<times> bool, unit) ElemAO \<Rightarrow>  VfsDirContext\<^sub>T \<times> bool"
where
  "emit_dir ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(dentry,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(vctx,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>5,ds\<^sub>7). Let\<^sub>d\<^sub>s ds\<^sub>5 (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>9,ds\<^sub>1). Let\<^sub>d\<^sub>s ds\<^sub>9 (\<lambda>ds\<^sub>1\<^sub>0. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>1. Let\<^sub>d\<^sub>s (vfs_dir_emit (VfsDirEmitP.make vctx (ObjDentry.name\<^sub>f dentry) (ObjDentry.ino\<^sub>f dentry) (dtype_to_vtype (ObjDentry.dtype\<^sub>f dentry)))) (\<lambda>ds\<^sub>1\<^sub>2. case_LoopResult (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 T4.dirctx\<^sub>f) (\<lambda>(vctx,ds\<^sub>1\<^sub>5). (vctx, True))) (\<lambda>ds\<^sub>1\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 T4.dirctx\<^sub>f) (\<lambda>(vctx,ds\<^sub>1\<^sub>6). (vctx, False))) ds\<^sub>1\<^sub>2)))))))))"

definition
  vfs_rename_get_dest_dir :: " VfsRenameContext\<^sub>T \<Rightarrow>  VfsInode\<^sub>T"
where
  "vfs_rename_get_dest_dir ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>ctx. Let\<^sub>d\<^sub>s (VfsRenameContext.dirs\<^sub>f ctx) (\<lambda>ds\<^sub>1. case_VfsRenameDirs (\<lambda>dest_dir. dest_dir) (\<lambda>both. VfsRenameDirsDiff.dest_dir\<^sub>f both) ds\<^sub>1))"

definition
  vfs_rename_get_src_dir :: " VfsRenameContext\<^sub>T \<Rightarrow>  VfsInode\<^sub>T"
where
  "vfs_rename_get_src_dir ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>ctx. Let\<^sub>d\<^sub>s (VfsRenameContext.dirs\<^sub>f ctx) (\<lambda>ds\<^sub>1. case_VfsRenameDirs (\<lambda>dest_dir. dest_dir) (\<lambda>both. VfsRenameDirsDiff.src_dir\<^sub>f both) ds\<^sub>1))"

definition
  buf_length :: " Buffer\<^sub>T \<Rightarrow> 32 word"
where
  "buf_length ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>buf. wordarray_length (Buffer.data\<^sub>f buf))"

definition
  buf_memset :: " Buffer\<^sub>T \<times> 32 word \<times> 32 word \<times> 8 word \<Rightarrow>  Buffer\<^sub>T"
where
  "buf_memset ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p2\<^sub>f) (\<lambda>(frm,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p3\<^sub>f) (\<lambda>(len,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P4_p4\<^sub>f) (\<lambda>(val,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 Buffer.data\<^sub>f) (\<lambda>(data,buf). HOL.Let (HOL.If ((<) frm (Buffer.bound\<^sub>f buf)) frm (Buffer.bound\<^sub>f buf)) (\<lambda>frm. HOL.Let (HOL.If ((<) ((+) frm len) (Buffer.bound\<^sub>f buf)) len ((-) (Buffer.bound\<^sub>f buf) frm)) (\<lambda>len. HOL.Let (wordarray_set (data, frm, len, val)) (\<lambda>data. Buffer.data\<^sub>f_update (\<lambda>_. data) buf))))))))"

definition
  eb_empty_pages_from :: " Buffer\<^sub>T \<times> 32 word \<Rightarrow> bool"
where
  "eb_empty_pages_from ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). Let\<^sub>d\<^sub>s (wordarray_fold (ArrayMapP.make (Buffer.data\<^sub>f buf) offs (Buffer.bound\<^sub>f buf) is_0xff () ())) (\<lambda>ds\<^sub>3. case_LoopResult (\<lambda>ds\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>6. False)) (\<lambda>ds\<^sub>6. Let\<^sub>d\<^sub>s ds\<^sub>6 (\<lambda>ds\<^sub>7. True)) ds\<^sub>3)))"

definition
  buf_free :: " SysState \<times>  Buffer\<^sub>T \<Rightarrow>  SysState"
where
  "buf_free ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 Buffer.data\<^sub>f) (\<lambda>(data,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 Buffer.bound\<^sub>f) (\<lambda>(bound,buf). HOL.Let (wordarray_free (ex, data)) (\<lambda>ex. freeBuffer (ex, buf))))))"

definition
  buf_create :: " SysState \<times> 32 word \<Rightarrow> ( SysState,  SysState \<times>  Buffer\<^sub>T) R"
where
  "buf_create ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(buffer_length,ds\<^sub>2). Let\<^sub>d\<^sub>s (wordarray_create (ex, buffer_length)) (\<lambda>ds\<^sub>3. case_R (\<lambda>ex. (R.Error ex :: ( SysState,  SysState \<times>  Buffer\<^sub>T) R)) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(data,ds\<^sub>7). Let\<^sub>d\<^sub>s (newBuffer ex) (\<lambda>ds\<^sub>8. case_R (\<lambda>ex. (R.Error (wordarray_free (ex, data)) :: ( SysState,  SysState \<times>  Buffer\<^sub>T) R)) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>1\<^sub>2). (R.Success (ex, Buffer.bound\<^sub>f_update (\<lambda>_. buffer_length) (Buffer.data\<^sub>f_update (\<lambda>_. data) buf)) :: ( SysState,  SysState \<times>  Buffer\<^sub>T) R)))) ds\<^sub>8)))) ds\<^sub>3)))"

definition
  loop_body_wbuf_read_leb :: "( SysState \<times>  Buffer\<^sub>T, 32 word \<times> 32 word \<times>  UbiVol, 32 word) Seq32_bodyParam \<Rightarrow> ( SysState \<times>  Buffer\<^sub>T) \<times> (32 word, unit) LoopResult"
where
  "loop_body_wbuf_read_leb ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 Seq32_bodyParam.acc\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 Seq32_bodyParam.obsv\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P3_p1\<^sub>f) (\<lambda>(ebnum,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P3_p2\<^sub>f) (\<lambda>(io_size,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p3\<^sub>f) (\<lambda>(ubi_vol,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 Seq32_bodyParam.idx\<^sub>f) (\<lambda>(i,ds\<^sub>1). HOL.Let ((*) i io_size) (\<lambda>offs. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (wubi_leb_read (WubiLebReadP.make ex ubi_vol ebnum buf offs io_size)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>1,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>1\<^sub>5). case_R (\<lambda>e. ((ex, buf), (LoopResult.Break e :: (32 word, unit) LoopResult))) (\<lambda>ds\<^sub>1\<^sub>6. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>6 (\<lambda>ds\<^sub>1\<^sub>8. ((ex, buf), (LoopResult.Iterate () :: (32 word, unit) LoopResult)))) r)))))))))))))"

definition
  buf_bound :: " Buffer\<^sub>T \<Rightarrow> 32 word"
where
  "buf_bound ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>buf. Buffer.bound\<^sub>f buf)"

definition
  buf_set_bound :: " Buffer\<^sub>T \<times> 32 word \<Rightarrow> ( Buffer\<^sub>T,  Buffer\<^sub>T) R"
where
  "buf_set_bound ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(newbound,ds\<^sub>2). HOL.Let (buf_length buf) (\<lambda>len. HOL.If ((>) newbound len) (R.Error buf :: ( Buffer\<^sub>T,  Buffer\<^sub>T) R) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t buf Buffer.bound\<^sub>f) (\<lambda>(bound,buf). (R.Success (Buffer.bound\<^sub>f_update (\<lambda>_. newbound) buf) :: ( Buffer\<^sub>T,  Buffer\<^sub>T) R))))))"

definition
  deserialise_ObjPad :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<times> 32 word \<Rightarrow> (32 word \<times>  SysState,  SysState \<times> unit \<times> 32 word) R"
where
  "deserialise_ObjPad ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(olen,ds\<^sub>4). HOL.Let ((-) olen (24 :: 32 word)) (\<lambda>len. HOL.If ((>) len olen) (R.Error ((22 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times> unit \<times> 32 word) R) (R.Success (ex, (), (+) offs len) :: (32 word \<times>  SysState,  SysState \<times> unit \<times> 32 word) R))))))"

definition
  deserialise_le16 :: " Buffer\<^sub>T \<times> 32 word \<Rightarrow> 16 word"
where
  "deserialise_le16 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, offs)) (\<lambda>b0. HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, (+) offs (1 :: 32 word))) (\<lambda>b1. (OR) (checked_shift shiftl (ucast b1 :: 16 word) (8 :: 16 word)) (ucast b0 :: 16 word)))))"

definition
  deserialise_le32 :: " Buffer\<^sub>T \<times> 32 word \<Rightarrow> 32 word"
where
  "deserialise_le32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, offs)) (\<lambda>b0. HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, (+) offs (1 :: 32 word))) (\<lambda>b1. HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, (+) offs (2 :: 32 word))) (\<lambda>b2. HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, (+) offs (3 :: 32 word))) (\<lambda>b3. (OR) ((OR) ((OR) (checked_shift shiftl (ucast b3 :: 32 word) (24 :: 32 word)) (checked_shift shiftl (ucast b2 :: 32 word) (16 :: 32 word))) (checked_shift shiftl (ucast b1 :: 32 word) (8 :: 32 word))) (ucast b0 :: 32 word)))))))"

definition
  deserialise_le64 :: " Buffer\<^sub>T \<times> 32 word \<Rightarrow> 64 word"
where
  "deserialise_le64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, offs)) (\<lambda>b0. HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, (+) offs (1 :: 32 word))) (\<lambda>b1. HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, (+) offs (2 :: 32 word))) (\<lambda>b2. HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, (+) offs (3 :: 32 word))) (\<lambda>b3. HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, (+) offs (4 :: 32 word))) (\<lambda>b4. HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, (+) offs (5 :: 32 word))) (\<lambda>b5. HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, (+) offs (6 :: 32 word))) (\<lambda>b6. HOL.Let (wordarray_get (Buffer.data\<^sub>f buf, (+) offs (7 :: 32 word))) (\<lambda>b7. (OR) ((OR) ((OR) ((OR) ((OR) ((OR) ((OR) (checked_shift shiftl (ucast b7 :: 64 word) (56 :: 64 word)) (checked_shift shiftl (ucast b6 :: 64 word) (48 :: 64 word))) (checked_shift shiftl (ucast b5 :: 64 word) (40 :: 64 word))) (checked_shift shiftl (ucast b4 :: 64 word) (32 :: 64 word))) (checked_shift shiftl (ucast b3 :: 64 word) (24 :: 64 word))) (checked_shift shiftl (ucast b2 :: 64 word) (16 :: 64 word))) (checked_shift shiftl (ucast b1 :: 64 word) (8 :: 64 word))) (ucast b0 :: 64 word)))))))))))"

definition
  deserialise_ObjDel :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<Rightarrow> (32 word \<times>  SysState,  SysState \<times>  ObjDel\<^sub>T \<times> 32 word) R"
where
  "deserialise_ObjDel ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (deserialise_le64 (buf, offs)) (\<lambda>id. HOL.Let ((AND) id (binNot (checked_shift shiftl (7 :: 64 word) (29 :: 64 word)))) (\<lambda>idtype. HOL.If ((~=) idtype (checked_shift shiftl (1 :: 64 word) (29 :: 64 word)) \<and> (~=) idtype (checked_shift shiftl (0 :: 64 word) (29 :: 64 word)) \<and> (~=) idtype (checked_shift shiftl (2 :: 64 word) (29 :: 64 word))) (R.Error ((22 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjDel\<^sub>T \<times> 32 word) R) (R.Success (ex, ObjDel.make id, (+) offs (8 :: 32 word)) :: (32 word \<times>  SysState,  SysState \<times>  ObjDel\<^sub>T \<times> 32 word) R))))))"

definition
  deserialise_ObjInode :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<Rightarrow> (32 word \<times>  SysState,  SysState \<times>  ObjInode\<^sub>T \<times> 32 word) R"
where
  "deserialise_ObjInode ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (deserialise_le64 (buf, offs)) (\<lambda>id. HOL.If ((~=) ((OR) ((AND) id (binNot ((OR) (checked_shift shiftl (7 :: 64 word) (29 :: 64 word)) (4294967295 :: 64 word)))) (checked_shift shiftl (0 :: 64 word) (29 :: 64 word))) id) (R.Error ((22 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjInode\<^sub>T \<times> 32 word) R) (Let\<^sub>d\<^sub>s (newObjInode ex) (\<lambda>ds\<^sub>4. case_R (\<lambda>ex. (R.Error ((12 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjInode\<^sub>T \<times> 32 word) R)) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(oi,ds\<^sub>8). HOL.Let (deserialise_le64 (buf, (+) offs (8 :: 32 word))) (\<lambda>size. HOL.Let (deserialise_le64 (buf, (+) offs (16 :: 32 word))) (\<lambda>atime_sec. HOL.Let (deserialise_le64 (buf, (+) offs (24 :: 32 word))) (\<lambda>ctime_sec. HOL.Let (deserialise_le64 (buf, (+) offs (32 :: 32 word))) (\<lambda>mtime_sec. HOL.Let (deserialise_le32 (buf, (+) offs (40 :: 32 word))) (\<lambda>nlink. HOL.Let (deserialise_le32 (buf, (+) offs (44 :: 32 word))) (\<lambda>uid. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>0. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (deserialise_le32 (buf, (+) offs (48 :: 32 word))) (\<lambda>gid. HOL.Let (deserialise_le32 (buf, (+) offs (52 :: 32 word))) (\<lambda>mode. HOL.Let (deserialise_le32 (buf, (+) offs (56 :: 32 word))) (\<lambda>flags. HOL.Let (ObjInode.flags\<^sub>f_update (\<lambda>_. flags) (ObjInode.mode\<^sub>f_update (\<lambda>_. mode) (ObjInode.gid\<^sub>f_update (\<lambda>_. gid) (ObjInode.uid\<^sub>f_update (\<lambda>_. uid) (ObjInode.nlink\<^sub>f_update (\<lambda>_. nlink) (ObjInode.mtime_sec\<^sub>f_update (\<lambda>_. mtime_sec) (ObjInode.ctime_sec\<^sub>f_update (\<lambda>_. ctime_sec) (ObjInode.atime_sec\<^sub>f_update (\<lambda>_. atime_sec) (ObjInode.size\<^sub>f_update (\<lambda>_. size) (ObjInode.id\<^sub>f_update (\<lambda>_. id) oi)))))))))) (\<lambda>oi. (R.Success (ex, oi, (+) offs (60 :: 32 word)) :: (32 word \<times>  SysState,  SysState \<times>  ObjInode\<^sub>T \<times> 32 word) R))))))))))))))))) ds\<^sub>4))))))"

definition
  deserialise_ObjSumEntry :: " Buffer\<^sub>T \<times> 32 word \<Rightarrow>  ObjSumEntry\<^sub>T \<times> 32 word"
where
  "deserialise_ObjSumEntry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (deserialise_le64 (buf, offs)) (\<lambda>id. HOL.Let (deserialise_le64 (buf, (+) offs (8 :: 32 word))) (\<lambda>sqnum. HOL.Let (deserialise_le32 (buf, (+) offs (16 :: 32 word))) (\<lambda>len. HOL.Let (deserialise_le32 (buf, (+) offs (20 :: 32 word))) (\<lambda>del_flags_and_offs. HOL.Let (deserialise_le16 (buf, (+) offs (24 :: 32 word))) (\<lambda>count. HOL.Let (ObjSumEntry.make id sqnum len del_flags_and_offs count) (\<lambda>entry. (entry, (+) offs (26 :: 32 word))))))))))"

definition
  deserialise_ObjSumEntry_map :: "( ObjSumEntry\<^sub>T, 32 word,  Buffer\<^sub>T) ElemAO \<Rightarrow>  ObjSumEntry\<^sub>T \<times> 32 word"
where
  "deserialise_ObjSumEntry_map ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(entry,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (deserialise_ObjSumEntry (buf, offs)) P2_p1\<^sub>f) (\<lambda>(entry,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>5). (entry, offs))))))"

definition
  deserialise_ObjSuper :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<Rightarrow> (32 word \<times>  SysState,  SysState \<times>  ObjSuper\<^sub>T \<times> 32 word) R"
where
  "deserialise_ObjSuper ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). Let\<^sub>d\<^sub>s (newObjSuper ex) (\<lambda>ds\<^sub>4. case_R (\<lambda>ex. (R.Error ((12 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjSuper\<^sub>T \<times> 32 word) R)) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(sup,ds\<^sub>8). HOL.Let (deserialise_le32 (buf, offs)) (\<lambda>nb_eb. HOL.Let (deserialise_le32 (buf, (+) offs (4 :: 32 word))) (\<lambda>eb_size. HOL.Let (deserialise_le32 (buf, (+) offs (8 :: 32 word))) (\<lambda>io_size. HOL.Let (deserialise_le32 (buf, (+) offs (12 :: 32 word))) (\<lambda>nb_reserved_gc. HOL.Let (deserialise_le32 (buf, (+) offs (16 :: 32 word))) (\<lambda>nb_reserved_del. HOL.Let (deserialise_le32 (buf, (+) offs (20 :: 32 word))) (\<lambda>cur_eb. HOL.Let (deserialise_le32 (buf, (+) offs (24 :: 32 word))) (\<lambda>cur_offs. HOL.Let (deserialise_le32 (buf, (+) offs (28 :: 32 word))) (\<lambda>last_inum. HOL.Let (deserialise_le64 (buf, (+) offs (32 :: 32 word))) (\<lambda>next_sqnum. HOL.Let (ObjSuper.next_sqnum\<^sub>f_update (\<lambda>_. next_sqnum) (ObjSuper.last_inum\<^sub>f_update (\<lambda>_. last_inum) (ObjSuper.cur_offs\<^sub>f_update (\<lambda>_. cur_offs) (ObjSuper.cur_eb\<^sub>f_update (\<lambda>_. cur_eb) (ObjSuper.nb_reserved_del\<^sub>f_update (\<lambda>_. nb_reserved_del) (ObjSuper.nb_reserved_gc\<^sub>f_update (\<lambda>_. nb_reserved_gc) (ObjSuper.io_size\<^sub>f_update (\<lambda>_. io_size) (ObjSuper.eb_size\<^sub>f_update (\<lambda>_. eb_size) (ObjSuper.nb_eb\<^sub>f_update (\<lambda>_. nb_eb) sup))))))))) (\<lambda>sup. (R.Success (ex, sup, (+) offs (40 :: 32 word)) :: (32 word \<times>  SysState,  SysState \<times>  ObjSuper\<^sub>T \<times> 32 word) R)))))))))))))) ds\<^sub>4))))"

definition
  deserialise_u8 :: " Buffer\<^sub>T \<times> 32 word \<Rightarrow> 8 word"
where
  "deserialise_u8 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). wordarray_get (Buffer.data\<^sub>f buf, offs)))"

definition
  deserialise_waU8_map :: "(8 word, 32 word, 8 word WordArray) ElemAO \<Rightarrow> 8 word \<times> 32 word"
where
  "deserialise_waU8_map ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(offs,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 ElemAO.obsv\<^sub>f) (\<lambda>(data,ds\<^sub>1). (wordarray_get (data, offs), (+) offs (1 :: 32 word))))))"

definition
  deserialise_wordarray_ObjSumEntry :: " ObjSumEntry\<^sub>T WordArray \<times>  Buffer\<^sub>T \<times> 32 word \<times> 32 word \<Rightarrow>  ObjSumEntry\<^sub>T WordArray \<times> (32 word, 32 word) R"
where
  "deserialise_wordarray_ObjSumEntry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(entries,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(nb_sum_entry,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (wordarray_map_no_break (ArrayMapP.make entries (0 :: 32 word) nb_sum_entry deserialise_ObjSumEntry_map offs buf)) P2_p1\<^sub>f) (\<lambda>(entries,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>6). (entries, (R.Success offs :: (32 word, 32 word) R))))))))"

definition
  deserialise_ObjSummary :: " Buffer\<^sub>T \<times> 32 word \<times>  ObjSummary\<^sub>T \<Rightarrow>  ObjSummary\<^sub>T \<times> (32 word, 32 word) R"
where
  "deserialise_ObjSummary ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P3_p3\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 ObjSummary.entries\<^sub>f) (\<lambda>(entries,sum). HOL.Let (deserialise_le32 (buf, offs)) (\<lambda>nb_sum_entry. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (deserialise_wordarray_ObjSumEntry (entries, buf, (+) offs (4 :: 32 word), nb_sum_entry)) P2_p1\<^sub>f) (\<lambda>(entries,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>6). case_R (\<lambda>e. (ObjSummary.entries\<^sub>f_update (\<lambda>_. entries) (ObjSummary.nb_sum_entry\<^sub>f_update (\<lambda>_. nb_sum_entry) sum), (R.Error e :: (32 word, 32 word) R))) (\<lambda>offs'. HOL.Let (deserialise_le32 (buf, offs')) (\<lambda>sum_offs. (ObjSummary.sum_offs\<^sub>f_update (\<lambda>_. sum_offs) (ObjSummary.entries\<^sub>f_update (\<lambda>_. entries) (ObjSummary.nb_sum_entry\<^sub>f_update (\<lambda>_. nb_sum_entry) sum)), (R.Success ((+) offs' (4 :: 32 word)) :: (32 word, 32 word) R)))) r)))))))"

definition
  deserialise_wordarray_U8 :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<times> 32 word \<Rightarrow> (32 word \<times>  SysState,  SysState \<times> 8 word WordArray) R"
where
  "deserialise_wordarray_U8 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(len,ds\<^sub>4). Let\<^sub>d\<^sub>s (wordarray_create (ex, len)) (\<lambda>ds\<^sub>5. case_R (\<lambda>ex. (R.Error ((12 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times> 8 word WordArray) R)) (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(wa,ds\<^sub>9). HOL.Let (wordarray_copy (wa, Buffer.data\<^sub>f buf, (0 :: 32 word), offs, len)) (\<lambda>wa. (R.Success (ex, wa) :: (32 word \<times>  SysState,  SysState \<times> 8 word WordArray) R))))) ds\<^sub>5)))))"

definition
  deserialise_ObjData :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<times> 32 word \<Rightarrow> (32 word \<times>  SysState,  SysState \<times>  ObjData\<^sub>T \<times> 32 word) R"
where
  "deserialise_ObjData ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(olen,ds\<^sub>4). HOL.Let ((-) ((-) olen (24 :: 32 word)) (8 :: 32 word)) (\<lambda>len. HOL.If ((>) len olen) (R.Error ((22 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjData\<^sub>T \<times> 32 word) R) (HOL.Let (deserialise_le64 (buf, offs)) (\<lambda>id. HOL.If ((~=) ((OR) ((AND) id (binNot (checked_shift shiftl (7 :: 64 word) (29 :: 64 word)))) (checked_shift shiftl (1 :: 64 word) (29 :: 64 word))) id) (R.Error ((22 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjData\<^sub>T \<times> 32 word) R) (Let\<^sub>d\<^sub>s (deserialise_wordarray_U8 (ex, buf, (+) offs (8 :: 32 word), len)) (\<lambda>ds\<^sub>5. case_R (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>9). (R.Error (e, ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjData\<^sub>T \<times> 32 word) R)))) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(odata,ds\<^sub>1\<^sub>0). HOL.Let (ObjData.make id odata) (\<lambda>od. (R.Success (ex, od, (+) ((+) offs (8 :: 32 word)) len) :: (32 word \<times>  SysState,  SysState \<times>  ObjData\<^sub>T \<times> 32 word) R))))) ds\<^sub>5)))))))))"

definition
  deserialise_ObjDentry :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<times> 32 word \<Rightarrow> (32 word \<times>  SysState,  SysState \<times>  ObjDentry\<^sub>T \<times> 32 word) R"
where
  "deserialise_ObjDentry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(end_offs,ds\<^sub>4). HOL.Let (deserialise_le32 (buf, offs)) (\<lambda>ino. HOL.Let (deserialise_u8 (buf, (+) offs (4 :: 32 word))) (\<lambda>dtype. HOL.Let (deserialise_le16 (buf, (+) offs (6 :: 32 word))) (\<lambda>nlen. HOL.Let (ucast nlen :: 32 word) (\<lambda>nlen32. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>6. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. HOL.If ((>) ((+) ((+) offs (8 :: 32 word)) nlen32) (Buffer.bound\<^sub>f buf) \<or> (>) nlen32 ((+) (255 :: 32 word) (1 :: 32 word)) \<or> (=) nlen32 (0 :: 32 word) \<or> (>) ((+) ((+) offs (8 :: 32 word)) nlen32) end_offs) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. (R.Error ((22 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjDentry\<^sub>T \<times> 32 word) R))) (Let\<^sub>d\<^sub>s (deserialise_wordarray_U8 (ex, buf, (+) offs (8 :: 32 word), nlen32)) (\<lambda>ds\<^sub>1\<^sub>0. case_R (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>6. (R.Error (e, ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjDentry\<^sub>T \<times> 32 word) R))))) (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(name,ds\<^sub>1\<^sub>4). Let\<^sub>d\<^sub>s (newObjDentry ex) (\<lambda>ds\<^sub>1\<^sub>5. case_R (\<lambda>ex. HOL.Let (wordarray_free (ex, name)) (\<lambda>ex. (R.Error ((12 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjDentry\<^sub>T \<times> 32 word) R))) (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(dentry,ds\<^sub>1\<^sub>9). HOL.Let (ObjDentry.name\<^sub>f_update (\<lambda>_. name) (ObjDentry.nlen\<^sub>f_update (\<lambda>_. nlen) (ObjDentry.dtype\<^sub>f_update (\<lambda>_. dtype) (ObjDentry.ino\<^sub>f_update (\<lambda>_. ino) dentry)))) (\<lambda>dentry. (R.Success (ex, dentry, (+) ((+) offs (8 :: 32 word)) nlen32) :: (32 word \<times>  SysState,  SysState \<times>  ObjDentry\<^sub>T \<times> 32 word) R))))) ds\<^sub>1\<^sub>5)))) ds\<^sub>1\<^sub>0))))))))))))))"

definition
  ostore_read_sum_f :: "( SysState \<times>  Buffer\<^sub>T \<times> 32 word, 32 word \<times> 32 word \<times>  UbiVol, 32 word) Seq32_bodyParam \<Rightarrow> ( SysState \<times>  Buffer\<^sub>T \<times> 32 word) \<times> (32 word, unit) LoopResult"
where
  "ostore_read_sum_f ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 Seq32_bodyParam.acc\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P3_p2\<^sub>f) (\<lambda>(rbuf,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 Seq32_bodyParam.obsv\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P3_p1\<^sub>f) (\<lambda>(ebnum,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p2\<^sub>f) (\<lambda>(io_size,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P3_p3\<^sub>f) (\<lambda>(ubi_vol,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 Seq32_bodyParam.idx\<^sub>f) (\<lambda>(idx,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (wubi_leb_read (WubiLebReadP.make ex ubi_vol ebnum rbuf offs io_size)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>2,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(rbuf,ds\<^sub>1\<^sub>6). case_R (\<lambda>e. ((ex, rbuf, (+) offs io_size), (LoopResult.Break e :: (32 word, unit) LoopResult))) (\<lambda>ds\<^sub>1\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>8 (\<lambda>ds\<^sub>1\<^sub>9. ((ex, rbuf, (+) offs io_size), (LoopResult.Iterate () :: (32 word, unit) LoopResult)))) r)))))))))))))"

definition
  serialise_ObjPad :: " Buffer\<^sub>T \<times> 32 word \<times> 32 word \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjPad ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(olen,ds\<^sub>3). HOL.Let ((-) olen (24 :: 32 word)) (\<lambda>padlen. HOL.Let (buf_memset (buf, offs, padlen, (66 :: 8 word))) (\<lambda>buf. (buf, (+) offs padlen))))))"

definition
  serialise_wordarray_U8 :: " Buffer\<^sub>T \<times> 32 word \<times> 8 word WordArray \<Rightarrow>  Buffer\<^sub>T"
where
  "serialise_wordarray_U8 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P3_p3\<^sub>f) (\<lambda>(wa,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 Buffer.data\<^sub>f) (\<lambda>(data,buf). HOL.Let (wordarray_length wa) (\<lambda>len. HOL.Let (HOL.If ((>) ((+) offs len) (Buffer.bound\<^sub>f buf)) (Buffer.bound\<^sub>f buf) ((+) offs len)) (\<lambda>end. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>6. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. HOL.Let (wordarray_copy (data, wa, offs, (0 :: 32 word), end)) (\<lambda>data. Buffer.data\<^sub>f_update (\<lambda>_. data) buf))))))))))))"

definition
  loop_deserialise_ObjDentry :: "((unit,  ObjDentry\<^sub>T) Option,  SysState \<times> 32 word,  Buffer\<^sub>T \<times> 32 word) OptElemAO \<Rightarrow> ((unit,  ObjDentry\<^sub>T) Option \<times> 32 word \<times>  SysState, (unit,  ObjDentry\<^sub>T) Option \<times>  SysState \<times> 32 word) LoopResult"
where
  "loop_deserialise_ObjDentry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 OptElemAO.oelem\<^sub>f) (\<lambda>(oelem,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 OptElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 OptElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(end_offs,ds\<^sub>9). HOL.Let (deep_freeOptionObjDentry (ex, oelem)) (\<lambda>ex. Let\<^sub>d\<^sub>s (deserialise_ObjDentry (ex, buf, offs, end_offs)) (\<lambda>ds\<^sub>1\<^sub>0. case_R (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>5. (LoopResult.Break ((Option.None () :: (unit,  ObjDentry\<^sub>T) Option), ((22 :: 32 word), ex)) :: ((unit,  ObjDentry\<^sub>T) Option \<times> 32 word \<times>  SysState, (unit,  ObjDentry\<^sub>T) Option \<times>  SysState \<times> 32 word) LoopResult))))) (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p2\<^sub>f) (\<lambda>(dent,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>6). (LoopResult.Iterate ((Option.Some dent :: (unit,  ObjDentry\<^sub>T) Option), (ex, offs)) :: ((unit,  ObjDentry\<^sub>T) Option \<times> 32 word \<times>  SysState, (unit,  ObjDentry\<^sub>T) Option \<times>  SysState \<times> 32 word) LoopResult))))) ds\<^sub>1\<^sub>0)))))))))"

definition
  find_name :: "( ObjDentry\<^sub>T, unit, 8 word WordArray) ElemAO \<Rightarrow> (32 word, unit) LoopResult"
where
  "find_name ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(de,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(name,ds\<^sub>1). HOL.If (wordarray_cmp (ObjDentry.name\<^sub>f de, name)) (LoopResult.Break (ObjDentry.ino\<^sub>f de) :: (32 word, unit) LoopResult) (LoopResult.Iterate () :: (32 word, unit) LoopResult)))))"

definition
  check_flash_is_empty :: " SysState \<times>  MountState\<^sub>T \<times>  UbiVol \<Rightarrow>  SysState \<times> (32 word, bool) R"
where
  "check_flash_is_empty ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(ubi_vol,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (seq32 (Seq32Param.make (0 :: 32 word) (ObjSuper.nb_eb\<^sub>f (MountState.super\<^sub>f mount_st)) (1 :: 32 word) check_flash_empty_loop ex ubi_vol)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>5). case_LoopResult (\<lambda>err. HOL.If ((=) err (39 :: 32 word)) (ex, (R.Success False :: (32 word, bool) R)) (ex, (R.Error err :: (32 word, bool) R))) (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s ds\<^sub>7 (\<lambda>ds\<^sub>8. (ex, (R.Success True :: (32 word, bool) R)))) r)))))"

definition
  fsm_check_free_space :: " MountState\<^sub>T \<times>  FsmState\<^sub>T \<times> 32 word \<Rightarrow> (32 word, unit) R"
where
  "fsm_check_free_space ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(osw_flags,ds\<^sub>3). HOL.Let (ObjSuper.nb_reserved_gc\<^sub>f (MountState.super\<^sub>f mount_st)) (\<lambda>n_gc. HOL.Let (ObjSuper.nb_reserved_del\<^sub>f (MountState.super\<^sub>f mount_st)) (\<lambda>n_del. HOL.Let (FsmState.nb_free_eb\<^sub>f fsm_st) (\<lambda>n_free. HOL.If ((<) n_free n_gc \<and> (=) ((AND) osw_flags (1 :: 32 word)) (0 :: 32 word)) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. (R.Error (28 :: 32 word) :: (32 word, unit) R))) (HOL.If ((<) n_free ((+) n_del n_gc) \<and> (=) ((AND) osw_flags (2 :: 32 word)) (0 :: 32 word) \<and> (=) ((AND) osw_flags (1 :: 32 word)) (0 :: 32 word)) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. (R.Error (28 :: 32 word) :: (32 word, unit) R))) (R.Success () :: (32 word, unit) R))))))))"

definition
  fsm_init :: " SysState \<times>  MountState\<^sub>T \<times>  FsmState\<^sub>T \<Rightarrow>  SysState \<times> (32 word \<times>  FsmState\<^sub>T,  FsmState\<^sub>T) R"
where
  "fsm_init ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>3). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. HOL.Let (ObjSuper.nb_eb\<^sub>f (MountState.super\<^sub>f mount_st)) (\<lambda>nb_eb. Let\<^sub>d\<^sub>s (wordarray_create (ex, nb_eb)) (\<lambda>ds\<^sub>5. case_R (\<lambda>ex. (ex, (R.Error ((12 :: 32 word), fsm_st) :: (32 word \<times>  FsmState\<^sub>T,  FsmState\<^sub>T) R))) (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(used_eb,ds\<^sub>9). Let\<^sub>d\<^sub>s (wordarray_create (ex, nb_eb)) (\<lambda>ds\<^sub>1\<^sub>0. case_R (\<lambda>ex. HOL.Let (wordarray_free (ex, used_eb)) (\<lambda>ex. (ex, (R.Error ((12 :: 32 word), fsm_st) :: (32 word \<times>  FsmState\<^sub>T,  FsmState\<^sub>T) R)))) (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(dirty_space,ds\<^sub>1\<^sub>4). Let\<^sub>d\<^sub>s (rbt_create ex) (\<lambda>ds\<^sub>1\<^sub>5. case_R (\<lambda>ex. HOL.Let (wordarray_free (ex, used_eb)) (\<lambda>ex. HOL.Let (wordarray_free (ex, dirty_space)) (\<lambda>ex. (ex, (R.Error ((12 :: 32 word), fsm_st) :: (32 word \<times>  FsmState\<^sub>T,  FsmState\<^sub>T) R))))) (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(gim,ds\<^sub>1\<^sub>9). Let\<^sub>d\<^sub>s (print_obj_super (MountState.super\<^sub>f mount_st)) (\<lambda>ds\<^sub>2\<^sub>0. HOL.Let ((-) (ObjSuper.nb_eb\<^sub>f (MountState.super\<^sub>f mount_st)) (2 :: 32 word)) (\<lambda>nb_free_eb. (ex, (R.Success (FsmState.nb_free_eb\<^sub>f_update (\<lambda>_. nb_free_eb) (FsmState.gim\<^sub>f_update (\<lambda>_. gim) (FsmState.dirty_space\<^sub>f_update (\<lambda>_. dirty_space) (FsmState.used_eb\<^sub>f_update (\<lambda>_. used_eb) fsm_st)))) :: (32 word \<times>  FsmState\<^sub>T,  FsmState\<^sub>T) R))))))) ds\<^sub>1\<^sub>5)))) ds\<^sub>1\<^sub>0)))) ds\<^sub>5))))))"

definition
  read_obj_pages_in_buf :: " SysState \<times>  MountState\<^sub>T \<times>  UbiVol \<times>  Buffer\<^sub>T \<times>  ObjAddr\<^sub>T \<Rightarrow> ( SysState \<times>  Buffer\<^sub>T) \<times> (32 word, unit) R"
where
  "read_obj_pages_in_buf ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p3\<^sub>f) (\<lambda>(ubi_vol,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p4\<^sub>f) (\<lambda>(buf,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p5\<^sub>f) (\<lambda>(addr,ds\<^sub>5). HOL.Let (ObjSuper.io_size\<^sub>f (MountState.super\<^sub>f mount_st)) (\<lambda>io_size. HOL.Let (checked_mod (ObjAddr.offs\<^sub>f addr) io_size) (\<lambda>offs_in_page. HOL.Let ((-) (ObjAddr.offs\<^sub>f addr) offs_in_page) (\<lambda>offs. HOL.Let (align32 ((+) (ObjAddr.offs\<^sub>f addr) (ObjAddr.len\<^sub>f addr), io_size)) (\<lambda>offs_end. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (wubi_leb_read (WubiLebReadP.make ex ubi_vol (ObjAddr.ebnum\<^sub>f addr) buf offs ((-) offs_end offs))) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>1\<^sub>0). case_R (\<lambda>e. ((ex, buf), (R.Error e :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>1 (\<lambda>ds\<^sub>1\<^sub>3. ((ex, Buffer.bound\<^sub>f_update (\<lambda>_. offs_end) buf), (R.Success () :: (32 word, unit) R)))) r)))))))))))))"

definition
  wbuf_read_leb :: " SysState \<times>  MountState\<^sub>T \<times>  UbiVol \<times>  Buffer\<^sub>T \<times> 32 word \<Rightarrow> ( SysState \<times>  Buffer\<^sub>T) \<times> (32 word, unit) R"
where
  "wbuf_read_leb ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p3\<^sub>f) (\<lambda>(ubi_vol,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p4\<^sub>f) (\<lambda>(buf,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p5\<^sub>f) (\<lambda>(ebnum,ds\<^sub>5). HOL.Let (ObjSuper.io_size\<^sub>f (MountState.super\<^sub>f mount_st)) (\<lambda>io_size. HOL.Let (checked_div (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) io_size) (\<lambda>nb_reads. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (seq32 (Seq32Param.make (0 :: 32 word) nb_reads (1 :: 32 word) loop_body_wbuf_read_leb (ex, buf) (ebnum, io_size, ubi_vol))) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>1\<^sub>0). case_LoopResult (\<lambda>e. ((ex, buf), (R.Error e :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>1 (\<lambda>ds\<^sub>1\<^sub>3. ((ex, buf), (R.Success () :: (32 word, unit) R)))) r)))))))))))"

definition
  deserialise_ObjHeader :: " Buffer\<^sub>T \<times> 32 word \<times>  Obj\<^sub>T \<Rightarrow>  Obj\<^sub>T \<times> (32 word, 32 word) R"
where
  "deserialise_ObjHeader ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(obj,ds\<^sub>3). HOL.Let (deserialise_le32 (buf, offs)) (\<lambda>magic. HOL.Let (deserialise_le32 (buf, (+) offs (4 :: 32 word))) (\<lambda>crc. HOL.Let (deserialise_le64 (buf, (+) offs (8 :: 32 word))) (\<lambda>sqnum. HOL.Let (deserialise_le32 (buf, (+) offs (16 :: 32 word))) (\<lambda>len. HOL.Let (deserialise_u8 (buf, (+) offs (22 :: 32 word))) (\<lambda>trans. HOL.Let (deserialise_u8 (buf, (+) offs (23 :: 32 word))) (\<lambda>otype. HOL.Let (Obj.otype\<^sub>f_update (\<lambda>_. otype) (Obj.trans\<^sub>f_update (\<lambda>_. trans) (Obj.len\<^sub>f_update (\<lambda>_. len) (Obj.offs\<^sub>f_update (\<lambda>_. offs) (Obj.sqnum\<^sub>f_update (\<lambda>_. sqnum) (Obj.crc\<^sub>f_update (\<lambda>_. crc) (Obj.magic\<^sub>f_update (\<lambda>_. magic) obj))))))) (\<lambda>obj. HOL.Let ((+) len offs) (\<lambda>end_offs. HOL.If ((<) end_offs offs \<or> (>) end_offs (Buffer.bound\<^sub>f buf) \<or> (~=) magic (186104309 :: 32 word) \<or> (~=) trans (1 :: 8 word) \<and> (~=) trans (2 :: 8 word) \<or> HOL.Not (is_len_and_type_ok (otype, len))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. (obj, (R.Error (22 :: 32 word) :: (32 word, 32 word) R)))) (obj, (R.Success ((+) offs (24 :: 32 word)) :: (32 word, 32 word) R)))))))))))))"

definition
  get_obj_oid :: " Obj\<^sub>T \<Rightarrow> 64 word"
where
  "get_obj_oid ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>obj. Let\<^sub>d\<^sub>s (Obj.ounion\<^sub>f obj) (\<lambda>ds\<^sub>1. HOL.Let (\<lambda>ds\<^sub>2. HOL.Let (\<lambda>ds\<^sub>3. HOL.Let (\<lambda>ds\<^sub>4. HOL.Let (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>5 (\<lambda>ds\<^sub>6. (18446744073709551615 :: 64 word))) (\<lambda>ccase\<^sub>G\<^sub>1. case_ObjUnion (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjData v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>obj. ObjDel.id\<^sub>f obj) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjDentarr v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjInode v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjPad v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjSummary v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjSuper v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) ds\<^sub>4)) (\<lambda>ccase\<^sub>G\<^sub>3. case_ObjUnion (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjData v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjDel v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>obj. ObjDentarr.id\<^sub>f obj) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjInode v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjPad v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjSummary v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjSuper v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) ds\<^sub>3)) (\<lambda>ccase\<^sub>G\<^sub>5. case_ObjUnion (\<lambda>obj. ObjData.id\<^sub>f obj) (\<lambda>v\<^sub>G\<^sub>4. ccase\<^sub>G\<^sub>5 (ObjUnion.TObjDel v\<^sub>G\<^sub>4 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>4. ccase\<^sub>G\<^sub>5 (ObjUnion.TObjDentarr v\<^sub>G\<^sub>4 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>4. ccase\<^sub>G\<^sub>5 (ObjUnion.TObjInode v\<^sub>G\<^sub>4 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>4. ccase\<^sub>G\<^sub>5 (ObjUnion.TObjPad v\<^sub>G\<^sub>4 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>4. ccase\<^sub>G\<^sub>5 (ObjUnion.TObjSummary v\<^sub>G\<^sub>4 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>4. ccase\<^sub>G\<^sub>5 (ObjUnion.TObjSuper v\<^sub>G\<^sub>4 ::  ObjUnion\<^sub>T)) ds\<^sub>2)) (\<lambda>ccase\<^sub>G\<^sub>7. case_ObjUnion (\<lambda>v\<^sub>G\<^sub>6. ccase\<^sub>G\<^sub>7 (ObjUnion.TObjData v\<^sub>G\<^sub>6 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>6. ccase\<^sub>G\<^sub>7 (ObjUnion.TObjDel v\<^sub>G\<^sub>6 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>6. ccase\<^sub>G\<^sub>7 (ObjUnion.TObjDentarr v\<^sub>G\<^sub>6 ::  ObjUnion\<^sub>T)) (\<lambda>obj. ObjInode.id\<^sub>f obj) (\<lambda>v\<^sub>G\<^sub>6. ccase\<^sub>G\<^sub>7 (ObjUnion.TObjPad v\<^sub>G\<^sub>6 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>6. ccase\<^sub>G\<^sub>7 (ObjUnion.TObjSummary v\<^sub>G\<^sub>6 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>6. ccase\<^sub>G\<^sub>7 (ObjUnion.TObjSuper v\<^sub>G\<^sub>6 ::  ObjUnion\<^sub>T)) ds\<^sub>1)))"

definition
  new_delnode_init :: " SysState \<times>  Obj\<^sub>T \<times> 32 word \<Rightarrow> ( SysState,  SysState \<times>  DelNode\<^sub>T ListNode) R"
where
  "new_delnode_init ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(ebnum,ds\<^sub>3). Let\<^sub>d\<^sub>s (newListNode ex) (\<lambda>ds\<^sub>4. case_R (\<lambda>ex. (R.Error ex :: ( SysState,  SysState \<times>  DelNode\<^sub>T ListNode) R)) (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(del,ds\<^sub>8). HOL.Let (ObjAddr.make ebnum (Obj.offs\<^sub>f obj) (Obj.len\<^sub>f obj) (Obj.sqnum\<^sub>f obj)) (\<lambda>oaddr. HOL.Let (listnode_put (del, DelNode.make (get_obj_oid obj) oaddr)) (\<lambda>del. (R.Success (ex, del) :: ( SysState,  SysState \<times>  DelNode\<^sub>T ListNode) R)))))) ds\<^sub>4))))"

definition
  obj_init_default :: " Obj\<^sub>T \<times> 8 word \<Rightarrow>  Obj\<^sub>T"
where
  "obj_init_default ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(obj,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(otype,ds\<^sub>2). Obj.otype\<^sub>f_update (\<lambda>_. otype) (Obj.trans\<^sub>f_update (\<lambda>_. (1 :: 8 word)) (Obj.len\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (Obj.offs\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (Obj.sqnum\<^sub>f_update (\<lambda>_. (0 :: 64 word)) (Obj.crc\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (Obj.magic\<^sub>f_update (\<lambda>_. (186104309 :: 32 word)) obj))))))))"

definition
  obj_data_new :: " SysState \<times> 64 word \<times> 32 word \<times> 8 word WordArray \<Rightarrow>  SysState \<times> (32 word \<times> 8 word WordArray,  Obj\<^sub>T) R"
where
  "obj_data_new ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(id,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(len,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(odata,ds\<^sub>4). Let\<^sub>d\<^sub>s (newObj ex) (\<lambda>ds\<^sub>5. case_R (\<lambda>ex. (ex, (R.Error ((12 :: 32 word), odata) :: (32 word \<times> 8 word WordArray,  Obj\<^sub>T) R))) (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>9). HOL.Let (ObjData.make id odata) (\<lambda>od. HOL.Let (obj_init_default (obj, (1 :: 8 word))) (\<lambda>obj. HOL.Let (Obj.len\<^sub>f_update (\<lambda>_. (+) ((+) (24 :: 32 word) (8 :: 32 word)) len) obj) (\<lambda>obj. (ex, (R.Success (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjData od ::  ObjUnion\<^sub>T)) obj) :: (32 word \<times> 8 word WordArray,  Obj\<^sub>T) R)))))))) ds\<^sub>5)))))"

definition
  obj_init_super :: " Obj\<^sub>T \<times> 64 word \<times> 32 word \<Rightarrow>  Obj\<^sub>T"
where
  "obj_init_super ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(obj,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(sqnum,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let ((+) (40 :: 32 word) (24 :: 32 word)) (\<lambda>len. Obj.otype\<^sub>f_update (\<lambda>_. (4 :: 8 word)) (Obj.trans\<^sub>f_update (\<lambda>_. (2 :: 8 word)) (Obj.len\<^sub>f_update (\<lambda>_. len) (Obj.offs\<^sub>f_update (\<lambda>_. offs) (Obj.sqnum\<^sub>f_update (\<lambda>_. sqnum) (Obj.crc\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (Obj.magic\<^sub>f_update (\<lambda>_. (186104309 :: 32 word)) obj))))))))))"

definition
  ostore_update_padding_obj :: " Obj\<^sub>T \<times> 64 word \<times> 32 word \<Rightarrow>  Obj\<^sub>T"
where
  "ostore_update_padding_obj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p2\<^sub>f) (\<lambda>(sqnum,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P3_p3\<^sub>f) (\<lambda>(pad_sz,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 Obj.sqnum\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>5). Let\<^sub>d\<^sub>s ds\<^sub>6 (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 Obj.len\<^sub>f) (\<lambda>(len,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 Obj.trans\<^sub>f) (\<lambda>(trans,obj). HOL.Let ((+) pad_sz (24 :: 32 word)) (\<lambda>len. HOL.Let (2 :: 8 word) (\<lambda>trans. Obj.trans\<^sub>f_update (\<lambda>_. trans) (Obj.len\<^sub>f_update (\<lambda>_. len) (Obj.sqnum\<^sub>f_update (\<lambda>_. sqnum) obj)))))))))))"

definition
  print_ObjHeader :: " Obj\<^sub>T \<Rightarrow> unit"
where
  "print_ObjHeader ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. ())"

definition
  print_obj_type :: " Obj\<^sub>T \<Rightarrow> unit"
where
  "print_obj_type ds\<^sub>0 \<equiv> Let\<^sub>d\<^sub>s ds\<^sub>0 (\<lambda>ds\<^sub>1. ())"

definition
  summary_init :: " SysState \<times> 32 word \<Rightarrow> ( SysState,  SysState \<times>  ObjSummary\<^sub>T \<times>  Obj\<^sub>T) R"
where
  "summary_init ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(max_nb_sum_entry,ds\<^sub>2). Let\<^sub>d\<^sub>s (newObjSummary ex) (\<lambda>ds\<^sub>3. case_R (\<lambda>ex. (R.Error ex :: ( SysState,  SysState \<times>  ObjSummary\<^sub>T \<times>  Obj\<^sub>T) R)) (\<lambda>ds\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(sum,ds\<^sub>7). Let\<^sub>d\<^sub>s (wordarray_create (ex, max_nb_sum_entry)) (\<lambda>ds\<^sub>8. case_R (\<lambda>ex. HOL.Let (freeObjSummary (ex, sum)) (\<lambda>ex. (R.Error ex :: ( SysState,  SysState \<times>  ObjSummary\<^sub>T \<times>  Obj\<^sub>T) R))) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(entries,ds\<^sub>1\<^sub>2). Let\<^sub>d\<^sub>s (newObj ex) (\<lambda>ds\<^sub>1\<^sub>3. case_R (\<lambda>ex. HOL.Let (freeObjSummary (ex, sum)) (\<lambda>ex. HOL.Let (wordarray_free (ex, entries)) (\<lambda>ex. (R.Error ex :: ( SysState,  SysState \<times>  ObjSummary\<^sub>T \<times>  Obj\<^sub>T) R)))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p2\<^sub>f) (\<lambda>(sum_obj,ds\<^sub>1\<^sub>7). HOL.Let (obj_init_default (sum_obj, (6 :: 8 word))) (\<lambda>sum_obj. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjPad () ::  ObjUnion\<^sub>T)) (Obj.trans\<^sub>f_update (\<lambda>_. (2 :: 8 word)) sum_obj)) (\<lambda>sum_obj. HOL.Let (0 :: 32 word) (\<lambda>sum_offs. (R.Success (ex, ObjSummary.sum_offs\<^sub>f_update (\<lambda>_. sum_offs) (ObjSummary.entries\<^sub>f_update (\<lambda>_. entries) (ObjSummary.nb_sum_entry\<^sub>f_update (\<lambda>_. (0 :: 32 word)) sum)), sum_obj) :: ( SysState,  SysState \<times>  ObjSummary\<^sub>T \<times>  Obj\<^sub>T) R))))))) ds\<^sub>1\<^sub>3)))) ds\<^sub>8)))) ds\<^sub>3)))"

definition
  trans_size_loop_body :: "( Obj\<^sub>T, 32 word, unit) ElemAO \<Rightarrow> 32 word"
where
  "trans_size_loop_body ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(obj,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(trans_size,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>1). Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>5. (+) trans_size (Obj.len\<^sub>f obj)))))"

definition
  trimObjSuper :: " ObjUnion\<^sub>T \<Rightarrow>  ObjUnion\<^sub>T"
where
  "trimObjSuper ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>u. HOL.Let (\<lambda>ds\<^sub>2. HOL.Let (\<lambda>ds\<^sub>4. HOL.Let ds\<^sub>4 (\<lambda>obj. obj)) (\<lambda>ccase\<^sub>G\<^sub>1. case_ObjUnion (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjData v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjDel v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjDentarr v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjInode v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjPad v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjSummary v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>ds\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>5. (ObjUnion.TObjPad () ::  ObjUnion\<^sub>T))) ds\<^sub>2)) (\<lambda>ccase\<^sub>G\<^sub>3. case_ObjUnion (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjData v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjDel v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjDentarr v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjInode v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjPad v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>ds\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1 (\<lambda>ds\<^sub>3. (ObjUnion.TObjPad () ::  ObjUnion\<^sub>T))) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjSuper v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) u))"

definition
  extract_dentarr_from_union :: " SysState \<times>  ObjUnion\<^sub>T \<Rightarrow> ( SysState,  SysState \<times>  ObjDentarr\<^sub>T) R"
where
  "extract_dentarr_from_union ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ounion,ds\<^sub>2). case_ObjUnion (\<lambda>v. (R.Error (deep_freeObjData (ex, v)) :: ( SysState,  SysState \<times>  ObjDentarr\<^sub>T) R)) (\<lambda>v. (R.Error ex :: ( SysState,  SysState \<times>  ObjDentarr\<^sub>T) R)) (\<lambda>odent. (R.Success (ex, odent) :: ( SysState,  SysState \<times>  ObjDentarr\<^sub>T) R)) (\<lambda>v. (R.Error (deep_freeObjInode (ex, v)) :: ( SysState,  SysState \<times>  ObjDentarr\<^sub>T) R)) (\<lambda>ds\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>5. (R.Error ex :: ( SysState,  SysState \<times>  ObjDentarr\<^sub>T) R))) (\<lambda>v. (R.Error (summary_clean (ex, v)) :: ( SysState,  SysState \<times>  ObjDentarr\<^sub>T) R)) (\<lambda>v. (R.Error (deep_freeObjSuper (ex, v)) :: ( SysState,  SysState \<times>  ObjDentarr\<^sub>T) R)) ounion))"

definition
  deep_freeObjDentarr :: " SysState \<times>  ObjDentarr\<^sub>T \<Rightarrow>  SysState"
where
  "deep_freeObjDentarr ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 ObjDentarr.id\<^sub>f) (\<lambda>(id,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 ObjDentarr.nb_dentry\<^sub>f) (\<lambda>(nb_dentry,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 ObjDentarr.entries\<^sub>f) (\<lambda>(entries,obj). HOL.Let (freeObjDentarr (ex, obj)) (\<lambda>ex. array_free (ArrayFreeP.make entries deep_freeObjDentry ex)))))))"

definition
  deep_freeObjUnion :: " SysState \<times>  ObjUnion\<^sub>T \<Rightarrow>  SysState"
where
  "deep_freeObjUnion ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ounion,ds\<^sub>2). case_ObjUnion (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 ObjData.id\<^sub>f) (\<lambda>(id,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 ObjData.odata\<^sub>f) (\<lambda>(odata,obj). HOL.Let (freeObjData (ex, obj)) (\<lambda>ex. wordarray_free (ex, odata))))) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 ObjDel.id\<^sub>f) (\<lambda>(id,obj). ex)) (\<lambda>obj. deep_freeObjDentarr (ex, obj)) (\<lambda>ds\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 ObjInode.id\<^sub>f) (\<lambda>(id,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 ObjInode.size\<^sub>f) (\<lambda>(size,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 ObjInode.atime_sec\<^sub>f) (\<lambda>(atime_sec,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 ObjInode.ctime_sec\<^sub>f) (\<lambda>(ctime_sec,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 ObjInode.mtime_sec\<^sub>f) (\<lambda>(mtime_sec,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 ObjInode.nlink\<^sub>f) (\<lambda>(nlink,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 ObjInode.uid\<^sub>f) (\<lambda>(uid,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 ObjInode.gid\<^sub>f) (\<lambda>(gid,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 ObjInode.mode\<^sub>f) (\<lambda>(mode,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 ObjInode.flags\<^sub>f) (\<lambda>(flags,obj). freeObjInode (ex, obj)))))))))))) (\<lambda>ds\<^sub>1\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>4 (\<lambda>ds\<^sub>1\<^sub>5. ex)) (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 ObjSummary.nb_sum_entry\<^sub>f) (\<lambda>(nb_sum_entry,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 ObjSummary.entries\<^sub>f) (\<lambda>(entries,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 ObjSummary.sum_offs\<^sub>f) (\<lambda>(sum_offs,obj). HOL.Let (wordarray_free (ex, entries)) (\<lambda>ex. freeObjSummary (ex, obj)))))) (\<lambda>ds\<^sub>1\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 ObjSuper.nb_eb\<^sub>f) (\<lambda>(nb_eb,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 ObjSuper.eb_size\<^sub>f) (\<lambda>(eb_size,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 ObjSuper.io_size\<^sub>f) (\<lambda>(io_size,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 ObjSuper.cur_eb\<^sub>f) (\<lambda>(cur_eb,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 ObjSuper.cur_offs\<^sub>f) (\<lambda>(cur_offs,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 ObjSuper.next_sqnum\<^sub>f) (\<lambda>(next_sqnum,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 ObjSuper.last_inum\<^sub>f) (\<lambda>(last_inum,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 ObjSuper.nb_reserved_gc\<^sub>f) (\<lambda>(nb_reserved_gc,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 ObjSuper.nb_reserved_del\<^sub>f) (\<lambda>(nb_reserved_del,obj). freeObjSuper (ex, obj))))))))))) ounion))"

definition
  deep_freeObj :: " SysState \<times>  Obj\<^sub>T \<Rightarrow>  SysState"
where
  "deep_freeObj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.magic\<^sub>f) (\<lambda>(magic,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 Obj.crc\<^sub>f) (\<lambda>(crc,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 Obj.sqnum\<^sub>f) (\<lambda>(sqnum,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 Obj.offs\<^sub>f) (\<lambda>(offs,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 Obj.len\<^sub>f) (\<lambda>(len,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 Obj.trans\<^sub>f) (\<lambda>(trans,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 Obj.otype\<^sub>f) (\<lambda>(otype,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 Obj.ounion\<^sub>f) (\<lambda>(ounion,obj). HOL.Let (deep_freeObjUnion (ex, ounion)) (\<lambda>ex. freeObj (ex, obj))))))))))))"

definition
  deep_opt_freeObj :: " SysState \<times> (unit,  Obj\<^sub>T) Option \<Rightarrow>  SysState"
where
  "deep_opt_freeObj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(opt_obj,ds\<^sub>2). case_Option (\<lambda>ds\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>5. ex)) (\<lambda>obj. Let\<^sub>d\<^sub>s (cogent_assert False) (\<lambda>ds\<^sub>5. deep_freeObj (ex, obj))) opt_obj))"

definition
  free_opt_obj :: " SysState \<times> (unit,  Obj\<^sub>T) Option \<Rightarrow>  SysState"
where
  "free_opt_obj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(opt_obj,ds\<^sub>2). case_Option (\<lambda>ds\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>5. ex)) (\<lambda>obj. deep_freeObj (ex, obj)) opt_obj))"

definition
  object_eraser :: "( Obj\<^sub>T,  SysState, unit) ElemAO \<Rightarrow>  SysState \<times> ( Obj\<^sub>T, unit) R"
where
  "object_eraser ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(obj,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ex,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>1). Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>5. (deep_freeObj (ex, obj), (R.Success () :: ( Obj\<^sub>T, unit) R))))))"

definition
  set_obj :: "((unit,  Obj\<^sub>T) Option,  SysState \<times> (unit,  Obj\<^sub>T) Option) OptElemA \<Rightarrow> ((unit,  Obj\<^sub>T) Option,  SysState \<times> (unit,  Obj\<^sub>T) Option) OptElemA"
where
  "set_obj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 OptElemA.oelem\<^sub>f) (\<lambda>(opt_obj,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 OptElemA.acc\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p2\<^sub>f) (\<lambda>(newopt_obj,ds\<^sub>5). case_Option (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s ds\<^sub>7 (\<lambda>ds\<^sub>8. OptElemA.make opt_obj (ex, (Option.None () :: (unit,  Obj\<^sub>T) Option)))) (\<lambda>newo. case_Option (\<lambda>ds\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>8 (\<lambda>ds\<^sub>9. OptElemA.make (Option.Some newo :: (unit,  Obj\<^sub>T) Option) (ex, (Option.None () :: (unit,  Obj\<^sub>T) Option)))) (\<lambda>obj. HOL.Let (deep_freeObj (ex, obj)) (\<lambda>ex. OptElemA.make (Option.Some newo :: (unit,  Obj\<^sub>T) Option) (ex, (Option.None () :: (unit,  Obj\<^sub>T) Option)))) opt_obj) newopt_obj))))"

definition
  deserialise_ObjSummary_crc :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<times>  Obj\<^sub>T \<times>  ObjSummary\<^sub>T \<Rightarrow> ( SysState \<times>  Obj\<^sub>T \<times>  ObjSummary\<^sub>T) \<times> (32 word, 32 word) R"
where
  "deserialise_ObjSummary_crc ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P5_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p4\<^sub>f) (\<lambda>(obj,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p5\<^sub>f) (\<lambda>(summary,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.offs\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>6). Let\<^sub>d\<^sub>s ds\<^sub>7 (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 Obj.magic\<^sub>f) (\<lambda>(magic,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 Obj.crc\<^sub>f) (\<lambda>(crc,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 Obj.sqnum\<^sub>f) (\<lambda>(sqnum,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 Obj.len\<^sub>f) (\<lambda>(len,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 Obj.trans\<^sub>f) (\<lambda>(trans,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 Obj.otype\<^sub>f) (\<lambda>(otype,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 Obj.ounion\<^sub>f) (\<lambda>(ounion,obj). HOL.Let (deep_freeObjUnion (ex, ounion)) (\<lambda>ex. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (deserialise_ObjHeader (buf, offs, obj)) P2_p1\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>6). case_R (\<lambda>e. ((ex, Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjPad () ::  ObjUnion\<^sub>T)) obj, summary), (R.Error e :: (32 word, 32 word) R))) (\<lambda>offs'. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (deserialise_ObjSummary (buf, offs', summary)) P2_p1\<^sub>f) (\<lambda>(summary,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>9). case_R (\<lambda>e. ((ex, Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjPad () ::  ObjUnion\<^sub>T)) obj, summary), (R.Error e :: (32 word, 32 word) R))) (\<lambda>offs'. HOL.Let (crc32_buf (Crc32bufP.make buf ((+) offs (8 :: 32 word)) offs')) (\<lambda>crcsum. HOL.Let (Obj.crc\<^sub>f obj) (\<lambda>crc. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.offs\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>1,obj). Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>1 (\<lambda>ds\<^sub>2\<^sub>2. HOL.Let (Obj.offs\<^sub>f_update (\<lambda>_. offs) obj) (\<lambda>obj. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>3. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>4. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>5. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>6. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjPad () ::  ObjUnion\<^sub>T)) obj) (\<lambda>obj. HOL.If ((=) crc crcsum) ((ex, obj, summary), (R.Success offs' :: (32 word, 32 word) R)) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>7. ((ex, obj, summary), (R.Error (22 :: 32 word) :: (32 word, 32 word) R))))))))))))))) r))) r)))))))))))))))))"

definition
  extract_data_from_union :: " SysState \<times>  ObjUnion\<^sub>T \<Rightarrow> ( SysState,  SysState \<times>  ObjData\<^sub>T) R"
where
  "extract_data_from_union ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ounion,ds\<^sub>2). case_ObjUnion (\<lambda>v. (R.Success (ex, v) :: ( SysState,  SysState \<times>  ObjData\<^sub>T) R)) (\<lambda>v. (R.Error ex :: ( SysState,  SysState \<times>  ObjData\<^sub>T) R)) (\<lambda>v. (R.Error (deep_freeObjDentarr (ex, v)) :: ( SysState,  SysState \<times>  ObjData\<^sub>T) R)) (\<lambda>v. (R.Error (deep_freeObjInode (ex, v)) :: ( SysState,  SysState \<times>  ObjData\<^sub>T) R)) (\<lambda>ds\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>5. (R.Error ex :: ( SysState,  SysState \<times>  ObjData\<^sub>T) R))) (\<lambda>v. (R.Error (summary_clean (ex, v)) :: ( SysState,  SysState \<times>  ObjData\<^sub>T) R)) (\<lambda>v. (R.Error (deep_freeObjSuper (ex, v)) :: ( SysState,  SysState \<times>  ObjData\<^sub>T) R)) ounion))"

definition
  get_data_back :: " SysState \<times> 8 word WordArray \<times> (unit,  Obj\<^sub>T) Option \<Rightarrow>  SysState \<times> 8 word WordArray"
where
  "get_data_back ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(dummy_data,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(opto,ds\<^sub>3). case_Option (\<lambda>ds\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>6. Let\<^sub>d\<^sub>s (cogent_assert False) (\<lambda>ds\<^sub>7. (ex, dummy_data)))) (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 Obj.ounion\<^sub>f) (\<lambda>(ounion,obj). Let\<^sub>d\<^sub>s (extract_data_from_union (ex, ounion)) (\<lambda>ds\<^sub>7. case_R (\<lambda>ex. HOL.Let (freeObj (ex, obj)) (\<lambda>ex. (ex, dummy_data))) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>0,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 ObjData.odata\<^sub>f) (\<lambda>(odata,od). HOL.Let (freeObjData (ex, od)) (\<lambda>ex. HOL.Let (freeObj (ex, obj)) (\<lambda>ex. HOL.Let (wordarray_free (ex, dummy_data)) (\<lambda>ex. (ex, odata)))))))) ds\<^sub>7))) opto)))"

definition
  extract_inode_from_union :: " SysState \<times>  ObjUnion\<^sub>T \<Rightarrow> ( SysState,  SysState \<times>  ObjInode\<^sub>T) R"
where
  "extract_inode_from_union ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ounion,ds\<^sub>2). case_ObjUnion (\<lambda>v. (R.Error (deep_freeObjData (ex, v)) :: ( SysState,  SysState \<times>  ObjInode\<^sub>T) R)) (\<lambda>v. (R.Error ex :: ( SysState,  SysState \<times>  ObjInode\<^sub>T) R)) (\<lambda>v. (R.Error (deep_freeObjDentarr (ex, v)) :: ( SysState,  SysState \<times>  ObjInode\<^sub>T) R)) (\<lambda>v. (R.Success (ex, v) :: ( SysState,  SysState \<times>  ObjInode\<^sub>T) R)) (\<lambda>ds\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>5. (R.Error ex :: ( SysState,  SysState \<times>  ObjInode\<^sub>T) R))) (\<lambda>v. (R.Error (summary_clean (ex, v)) :: ( SysState,  SysState \<times>  ObjInode\<^sub>T) R)) (\<lambda>v. (R.Error (deep_freeObjSuper (ex, v)) :: ( SysState,  SysState \<times>  ObjInode\<^sub>T) R)) ounion))"

definition
  extract_super_from_union :: " SysState \<times>  ObjUnion\<^sub>T \<Rightarrow> ( SysState,  SysState \<times>  ObjSuper\<^sub>T) R"
where
  "extract_super_from_union ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ounion,ds\<^sub>2). case_ObjUnion (\<lambda>v. (R.Error (deep_freeObjData (ex, v)) :: ( SysState,  SysState \<times>  ObjSuper\<^sub>T) R)) (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s ds\<^sub>7 (\<lambda>ds\<^sub>9. (R.Error ex :: ( SysState,  SysState \<times>  ObjSuper\<^sub>T) R))) (\<lambda>v. (R.Error (deep_freeObjDentarr (ex, v)) :: ( SysState,  SysState \<times>  ObjSuper\<^sub>T) R)) (\<lambda>v. (R.Error (deep_freeObjInode (ex, v)) :: ( SysState,  SysState \<times>  ObjSuper\<^sub>T) R)) (\<lambda>ds\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3 (\<lambda>ds\<^sub>5. (R.Error ex :: ( SysState,  SysState \<times>  ObjSuper\<^sub>T) R))) (\<lambda>sum. (R.Error (summary_clean (ex, sum)) :: ( SysState,  SysState \<times>  ObjSuper\<^sub>T) R)) (\<lambda>sup. (R.Success (ex, sup) :: ( SysState,  SysState \<times>  ObjSuper\<^sub>T) R)) ounion))"

definition
  fsop_dir_release :: " SysState \<times> (unit,  BilbyFsReaddirContext\<^sub>T) Option \<Rightarrow>  SysState"
where
  "fsop_dir_release ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(opt_rdctx,ds\<^sub>2). case_Option (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>5 (\<lambda>ds\<^sub>6. ex)) (\<lambda>ds\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 BilbyFsReaddirContext.dentarr\<^sub>f) (\<lambda>(dentarr,v). HOL.Let (deep_freeObjDentarr (ex, dentarr)) (\<lambda>ex. freeBilbyFsReaddirContext (ex, v)))) opt_rdctx))"

definition
  get_rdctx :: " SysState \<times> (unit,  BilbyFsReaddirContext\<^sub>T) Option \<times>  VfsInode\<^sub>T \<Rightarrow> (32 word \<times>  SysState,  SysState \<times>  BilbyFsReaddirContext\<^sub>T) R"
where
  "get_rdctx ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(opt_rdctx,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(vdir,ds\<^sub>3). case_Option (\<lambda>ds\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>6. Let\<^sub>d\<^sub>s (newBilbyFsReaddirContext ex) (\<lambda>ds\<^sub>7. case_R (\<lambda>ex. (R.Error ((12 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  BilbyFsReaddirContext\<^sub>T) R)) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(rdctx,ds\<^sub>1\<^sub>1). Let\<^sub>d\<^sub>s (array_create (ex, (1 :: 32 word))) (\<lambda>ds\<^sub>1\<^sub>2. case_R (\<lambda>ex. HOL.Let (freeBilbyFsReaddirContext (ex, rdctx)) (\<lambda>ex. (R.Error ((12 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  BilbyFsReaddirContext\<^sub>T) R))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(entries,ds\<^sub>1\<^sub>6). Let\<^sub>d\<^sub>s (newObjDentarr ex) (\<lambda>ds\<^sub>1\<^sub>7. case_R (\<lambda>ex. HOL.Let (freeBilbyFsReaddirContext (ex, rdctx)) (\<lambda>ex. HOL.Let (array_free (ArrayFreeP.make entries deep_freeObjDentry ex)) (\<lambda>ex. (R.Error ((12 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  BilbyFsReaddirContext\<^sub>T) R)))) (\<lambda>ds\<^sub>1\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>2\<^sub>1). HOL.Let (obj_id_inode_mk (vfs_inode_get_ino vdir)) (\<lambda>id. HOL.Let (0 :: 32 word) (\<lambda>nb_dentry. HOL.Let (ObjDentarr.entries\<^sub>f_update (\<lambda>_. entries) (ObjDentarr.nb_dentry\<^sub>f_update (\<lambda>_. nb_dentry) (ObjDentarr.id\<^sub>f_update (\<lambda>_. id) dentarr))) (\<lambda>dentarr. HOL.Let (BilbyFsReaddirContext.cur_dentry\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (BilbyFsReaddirContext.dentarr\<^sub>f_update (\<lambda>_. dentarr) rdctx)) (\<lambda>rdctx. (R.Success (ex, rdctx) :: (32 word \<times>  SysState,  SysState \<times>  BilbyFsReaddirContext\<^sub>T) R)))))))) ds\<^sub>1\<^sub>7)))) ds\<^sub>1\<^sub>2)))) ds\<^sub>7))) (\<lambda>rdctx. (R.Success (ex, rdctx) :: (32 word \<times>  SysState,  SysState \<times>  BilbyFsReaddirContext\<^sub>T) R)) opt_rdctx)))"

definition
  dentarr_del_dentry :: " SysState \<times>  ObjDentarr\<^sub>T \<times> 8 word WordArray \<Rightarrow>  SysState \<times>  ObjDentarr\<^sub>T"
where
  "dentarr_del_dentry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P3_p3\<^sub>f) (\<lambda>(name,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 ObjDentarr.entries\<^sub>f) (\<lambda>(entries,odent). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (array_filter (ArrayFoldP.make entries del_dentry_modifier ex name)) ArrA.arr\<^sub>f) (\<lambda>(entries,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 ArrA.acc\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let ((-) (ObjDentarr.nb_dentry\<^sub>f odent) (1 :: 32 word)) (\<lambda>nb_dentry. (ex, ObjDentarr.entries\<^sub>f_update (\<lambda>_. entries) (ObjDentarr.nb_dentry\<^sub>f_update (\<lambda>_. nb_dentry) odent)))))))))"

definition
  deserialise_Array_ObjDentry :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<times> 32 word \<times> 32 word \<Rightarrow> (32 word \<times>  SysState,  SysState \<times>  ObjDentry\<^sub>T Array \<times> 32 word) R"
where
  "deserialise_Array_ObjDentry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P5_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p4\<^sub>f) (\<lambda>(nb_dentry,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p5\<^sub>f) (\<lambda>(end_offs,ds\<^sub>5). Let\<^sub>d\<^sub>s (array_create (ex, (+) nb_dentry (1 :: 32 word))) (\<lambda>ds\<^sub>6. case_R (\<lambda>ex. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. (R.Error ((12 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjDentry\<^sub>T Array \<times> 32 word) R))) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>1\<^sub>0). Let\<^sub>d\<^sub>s (array_map (ArrayMapP.make arr (0 :: 32 word) nb_dentry loop_deserialise_ObjDentry (ex, offs) (buf, end_offs))) (\<lambda>ds\<^sub>1\<^sub>1. case_LoopResult (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(arr,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>4,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>8). HOL.Let (array_free (ArrayFreeP.make arr deep_freeObjDentry ex)) (\<lambda>ex. (R.Error (err, ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjDentry\<^sub>T Array \<times> 32 word) R))))))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(arr,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>5,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>9). (R.Success (ex, arr, offs) :: (32 word \<times>  SysState,  SysState \<times>  ObjDentry\<^sub>T Array \<times> 32 word) R)))))) ds\<^sub>1\<^sub>1)))) ds\<^sub>6))))))"

definition
  deserialise_ObjDentarr :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<times> 32 word \<Rightarrow> (32 word \<times>  SysState,  SysState \<times>  ObjDentarr\<^sub>T \<times> 32 word) R"
where
  "deserialise_ObjDentarr ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(olen,ds\<^sub>4). HOL.Let (deserialise_le64 (buf, offs)) (\<lambda>id. HOL.Let (deserialise_le32 (buf, (+) offs (8 :: 32 word))) (\<lambda>nb_dentry. Let\<^sub>d\<^sub>s (deserialise_Array_ObjDentry (ex, buf, (+) offs (12 :: 32 word), nb_dentry, (-) ((+) offs olen) (24 :: 32 word))) (\<lambda>ds\<^sub>5. case_R (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>9). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>0. (R.Error (e, ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjDentarr\<^sub>T \<times> 32 word) R))))) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p2\<^sub>f) (\<lambda>(entries,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>1). Let\<^sub>d\<^sub>s (newObjDentarr ex) (\<lambda>ds\<^sub>1\<^sub>2. case_R (\<lambda>ex. HOL.Let (array_free (ArrayFreeP.make entries deep_freeObjDentry ex)) (\<lambda>ex. (R.Error ((12 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjDentarr\<^sub>T \<times> 32 word) R))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>1\<^sub>6). HOL.Let (ObjDentarr.entries\<^sub>f_update (\<lambda>_. entries) (ObjDentarr.nb_dentry\<^sub>f_update (\<lambda>_. nb_dentry) (ObjDentarr.id\<^sub>f_update (\<lambda>_. id) dentarr))) (\<lambda>dentarr. (R.Success (ex, dentarr, offs) :: (32 word \<times>  SysState,  SysState \<times>  ObjDentarr\<^sub>T \<times> 32 word) R))))) ds\<^sub>1\<^sub>2))))) ds\<^sub>5)))))))"

definition
  deserialise_ObjUnion :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<times> 8 word \<times> 32 word \<Rightarrow> (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R"
where
  "deserialise_ObjUnion ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P4_p4\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p1\<^sub>f) (\<lambda>(otype,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(olen,ds\<^sub>7). HOL.If ((=) otype (0 :: 8 word)) (Let\<^sub>d\<^sub>s (deserialise_ObjInode (ex, buf, offs)) (\<lambda>ds\<^sub>8. case_R (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). (R.Error (e, ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R)))) (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>4). (R.Success (ex, (ObjUnion.TObjInode obj ::  ObjUnion\<^sub>T), offs) :: (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R))))) ds\<^sub>8)) (HOL.If ((=) otype (1 :: 8 word)) (Let\<^sub>d\<^sub>s (deserialise_ObjData (ex, buf, offs, olen)) (\<lambda>ds\<^sub>9. case_R (\<lambda>ds\<^sub>1\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). (R.Error (e, ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R)))) (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>5). (R.Success (ex, (ObjUnion.TObjData obj ::  ObjUnion\<^sub>T), offs) :: (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R))))) ds\<^sub>9)) (HOL.If ((=) otype (2 :: 8 word)) (Let\<^sub>d\<^sub>s (deserialise_ObjDentarr (ex, buf, offs, olen)) (\<lambda>ds\<^sub>1\<^sub>0. case_R (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). (R.Error (e, ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R)))) (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>6). (R.Success (ex, (ObjUnion.TObjDentarr obj ::  ObjUnion\<^sub>T), offs) :: (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R))))) ds\<^sub>1\<^sub>0)) (HOL.If ((=) otype (3 :: 8 word)) (Let\<^sub>d\<^sub>s (deserialise_ObjDel (ex, buf, offs)) (\<lambda>ds\<^sub>1\<^sub>1. case_R (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). (R.Error (e, ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R)))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>7). (R.Success (ex, (ObjUnion.TObjDel obj ::  ObjUnion\<^sub>T), offs) :: (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R))))) ds\<^sub>1\<^sub>1)) (HOL.If ((=) otype (4 :: 8 word)) (Let\<^sub>d\<^sub>s (deserialise_ObjSuper (ex, buf, offs)) (\<lambda>ds\<^sub>1\<^sub>2. case_R (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). (R.Error (e, ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R)))) (\<lambda>ds\<^sub>1\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>8). (R.Success (ex, (ObjUnion.TObjSuper obj ::  ObjUnion\<^sub>T), offs) :: (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R))))) ds\<^sub>1\<^sub>2)) (Let\<^sub>d\<^sub>s (deserialise_ObjPad (ex, buf, offs, olen)) (\<lambda>ds\<^sub>1\<^sub>3. case_R (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). (R.Error (e, ex) :: (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R)))) (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>9). (R.Success (ex, (ObjUnion.TObjPad obj ::  ObjUnion\<^sub>T), offs) :: (32 word \<times>  SysState,  SysState \<times>  ObjUnion\<^sub>T \<times> 32 word) R))))) ds\<^sub>1\<^sub>3))))))))))))"

definition
  deserialise_Obj :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<Rightarrow> (32 word \<times>  SysState,  SysState \<times>  Obj\<^sub>T \<times> 32 word) R"
where
  "deserialise_Obj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). Let\<^sub>d\<^sub>s (newObj ex) (\<lambda>ds\<^sub>4. case_R (\<lambda>ex. (R.Error ((12 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  Obj\<^sub>T \<times> 32 word) R)) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (deserialise_ObjHeader (buf, offs, obj)) P2_p1\<^sub>f) (\<lambda>(obj,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>0). case_R (\<lambda>e. HOL.Let (freeObj (ex, obj)) (\<lambda>ex. (R.Error (e, ex) :: (32 word \<times>  SysState,  SysState \<times>  Obj\<^sub>T \<times> 32 word) R))) (\<lambda>offs. Let\<^sub>d\<^sub>s (deserialise_ObjUnion (ex, buf, offs, (Obj.otype\<^sub>f obj, Obj.len\<^sub>f obj))) (\<lambda>ds\<^sub>1\<^sub>2. case_R (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (freeObj (ex, obj)) (\<lambda>ex. (R.Error (e, ex) :: (32 word \<times>  SysState,  SysState \<times>  Obj\<^sub>T \<times> 32 word) R)))))) (\<lambda>ds\<^sub>1\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P3_p2\<^sub>f) (\<lambda>(ounion,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p3\<^sub>f) (\<lambda>(offs',ds\<^sub>1\<^sub>8). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>9. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. ounion) obj) (\<lambda>obj. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>0. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>1. (R.Success (ex, obj, offs') :: (32 word \<times>  SysState,  SysState \<times>  Obj\<^sub>T \<times> 32 word) R))))))))) ds\<^sub>1\<^sub>2)) r))))) ds\<^sub>4))))"

definition
  deserialise_Obj_crc :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<Rightarrow> (32 word \<times>  SysState,  SysState \<times>  Obj\<^sub>T \<times> 32 word) R"
where
  "deserialise_Obj_crc ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. Let\<^sub>d\<^sub>s (deserialise_Obj (ex, buf, offs)) (\<lambda>ds\<^sub>5. case_R (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>9). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>0. (R.Error (err, ex) :: (32 word \<times>  SysState,  SysState \<times>  Obj\<^sub>T \<times> 32 word) R))))) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P3_p3\<^sub>f) (\<lambda>(end_offs,ds\<^sub>1\<^sub>1). HOL.Let (crc32_buf (Crc32bufP.make buf ((+) offs (8 :: 32 word)) end_offs)) (\<lambda>crcsum. HOL.Let (Obj.crc\<^sub>f obj) (\<lambda>crc. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.offs\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>2,obj). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>2 (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (Obj.offs\<^sub>f_update (\<lambda>_. offs) obj) (\<lambda>obj. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>4. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>5. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.ounion\<^sub>f) (\<lambda>(ounion,obj). Let\<^sub>d\<^sub>s (print_ObjHeader obj) (\<lambda>ds\<^sub>1\<^sub>7. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>7 (\<lambda>ds\<^sub>1\<^sub>8. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. ounion) obj) (\<lambda>obj. HOL.If ((=) crc crcsum) (R.Success (ex, obj, end_offs) :: (32 word \<times>  SysState,  SysState \<times>  Obj\<^sub>T \<times> 32 word) R) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>9. HOL.Let (deep_freeObj (ex, obj)) (\<lambda>ex. (R.Error ((22 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times>  Obj\<^sub>T \<times> 32 word) R)))))))))))))))))))) ds\<^sub>5)))))"

definition
  read_super_loop :: "( SysState \<times>  Obj\<^sub>T \<times> 32 word,  MountState\<^sub>T \<times>  Buffer\<^sub>T, 32 word) Seq32_bodyParam \<Rightarrow> ( SysState \<times>  Obj\<^sub>T \<times> 32 word) \<times> (unit, unit) LoopResult"
where
  "read_super_loop ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 Seq32_bodyParam.acc\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 Seq32_bodyParam.obsv\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(rbuf,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 Seq32_bodyParam.idx\<^sub>f) (\<lambda>(nb_trans,ds\<^sub>1). Let\<^sub>d\<^sub>s (deserialise_Obj_crc (ex, rbuf, offs)) (\<lambda>ds\<^sub>1\<^sub>1. case_R (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). ((ex, obj, (0 :: 32 word)), (LoopResult.Break () :: (unit, unit) LoopResult))))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P3_p2\<^sub>f) (\<lambda>(obj',ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>7). HOL.Let (Obj.otype\<^sub>f obj') (\<lambda>typ. HOL.If ((~=) typ (4 :: 8 word)) (HOL.Let (deep_freeObj (ex, obj')) (\<lambda>ex. ((ex, obj, offs), (LoopResult.Iterate () :: (unit, unit) LoopResult)))) (HOL.Let (deep_freeObj (ex, obj)) (\<lambda>ex. ((ex, obj', offs), (LoopResult.Iterate () :: (unit, unit) LoopResult))))))))) ds\<^sub>1\<^sub>1)))))))))"

definition
  scan_trans_obj :: "((unit,  Obj\<^sub>T) Option,  SysState \<times> 32 word,  MountState\<^sub>T \<times>  Buffer\<^sub>T) OptElemAO \<Rightarrow> ((unit,  Obj\<^sub>T) Option \<times> (32 word \<times>  SysState,  SysState \<times> 32 word) R, (unit,  Obj\<^sub>T) Option \<times>  SysState \<times> 32 word) LoopResult"
where
  "scan_trans_obj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 OptElemAO.oelem\<^sub>f) (\<lambda>(obj_opt,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 OptElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 OptElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>9). HOL.Let (deep_opt_freeObj (ex, obj_opt)) (\<lambda>ex. Let\<^sub>d\<^sub>s (deserialise_Obj_crc (ex, buf, offs)) (\<lambda>ds\<^sub>1\<^sub>0. case_R (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). (LoopResult.Break ((Option.None () :: (unit,  Obj\<^sub>T) Option), (R.Error ((88 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times> 32 word) R)) :: ((unit,  Obj\<^sub>T) Option \<times> (32 word \<times>  SysState,  SysState \<times> 32 word) R, (unit,  Obj\<^sub>T) Option \<times>  SysState \<times> 32 word) LoopResult)))) (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>6). HOL.Let (Obj.trans\<^sub>f obj) (\<lambda>trans. HOL.If ((=) trans (2 :: 8 word)) (LoopResult.Break ((Option.Some obj :: (unit,  Obj\<^sub>T) Option), (R.Success (ex, offs) :: (32 word \<times>  SysState,  SysState \<times> 32 word) R)) :: ((unit,  Obj\<^sub>T) Option \<times> (32 word \<times>  SysState,  SysState \<times> 32 word) R, (unit,  Obj\<^sub>T) Option \<times>  SysState \<times> 32 word) LoopResult) (HOL.If ((>=) offs (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st))) (HOL.Let (deep_freeObj (ex, obj)) (\<lambda>ex. (LoopResult.Break ((Option.None () :: (unit,  Obj\<^sub>T) Option), (R.Error ((22 :: 32 word), ex) :: (32 word \<times>  SysState,  SysState \<times> 32 word) R)) :: ((unit,  Obj\<^sub>T) Option \<times> (32 word \<times>  SysState,  SysState \<times> 32 word) R, (unit,  Obj\<^sub>T) Option \<times>  SysState \<times> 32 word) LoopResult))) (LoopResult.Iterate ((Option.Some obj :: (unit,  Obj\<^sub>T) Option), (ex, offs)) :: ((unit,  Obj\<^sub>T) Option \<times> (32 word \<times>  SysState,  SysState \<times> 32 word) R, (unit,  Obj\<^sub>T) Option \<times>  SysState \<times> 32 word) LoopResult))))))) ds\<^sub>1\<^sub>0)))))))))"

definition
  ostore_get_trans_size :: " Obj\<^sub>T Array \<Rightarrow> 32 word"
where
  "ostore_get_trans_size ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>arr. HOL.Let (0 :: 32 word) (\<lambda>trans_size. array_fold_no_break (ArrayFoldP.make arr trans_size_loop_body trans_size ())))"

definition
  serialise_size_Array_ObjDentry :: " ObjDentry\<^sub>T Array \<Rightarrow> 32 word"
where
  "serialise_size_Array_ObjDentry ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>arr. array_fold_no_break (ArrayFoldP.make arr serialise_size_Arr_ObjDentry_f (0 :: 32 word) ()))"

definition
  serialise_size_ObjDentarr :: " ObjDentarr\<^sub>T \<Rightarrow> 32 word"
where
  "serialise_size_ObjDentarr ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>dentarr. (+) (12 :: 32 word) (serialise_size_Array_ObjDentry (ObjDentarr.entries\<^sub>f dentarr)))"

definition
  obj_dentarr_or_del_new :: " SysState \<times>  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<Rightarrow> (32 word \<times>  SysState,  SysState \<times>  Obj\<^sub>T) R"
where
  "obj_dentarr_or_del_new ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(odent,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(dent,ds\<^sub>3). HOL.Let (array_nb_elem (ObjDentarr.entries\<^sub>f dent)) (\<lambda>len. HOL.If ((>) len (0 :: 32 word)) (HOL.Let ((+) (24 :: 32 word) (serialise_size_ObjDentarr dent)) (\<lambda>len. (R.Success (ex, Obj.otype\<^sub>f_update (\<lambda>_. (2 :: 8 word)) (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr dent ::  ObjUnion\<^sub>T)) (Obj.len\<^sub>f_update (\<lambda>_. len) odent))) :: (32 word \<times>  SysState,  SysState \<times>  Obj\<^sub>T) R))) (HOL.Let (ObjDel.make (ObjDentarr.id\<^sub>f dent)) (\<lambda>odel. HOL.Let ((+) (24 :: 32 word) (serialise_size_ObjDel odel)) (\<lambda>len. HOL.Let (deep_freeObjDentarr (ex, dent)) (\<lambda>ex. (R.Success (ex, Obj.otype\<^sub>f_update (\<lambda>_. (3 :: 8 word)) (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDel odel ::  ObjUnion\<^sub>T)) (Obj.len\<^sub>f_update (\<lambda>_. len) odent))) :: (32 word \<times>  SysState,  SysState \<times>  Obj\<^sub>T) R)))))))))"

definition
  serialise_size_ObjUnion :: " ObjUnion\<^sub>T \<Rightarrow> 32 word"
where
  "serialise_size_ObjUnion ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>ounion. case_ObjUnion (\<lambda>obj. serialise_size_ObjData obj) (\<lambda>obj. serialise_size_ObjDel obj) (\<lambda>obj. serialise_size_ObjDentarr obj) (\<lambda>obj. serialise_size_ObjInode obj) (\<lambda>obj. (0 :: 32 word)) (\<lambda>obj. serialise_size_ObjSummary (ObjSummary.nb_sum_entry\<^sub>f obj)) (\<lambda>obj. serialise_size_ObjSuper obj) ounion)"

definition
  serialise_size_Obj :: " Obj\<^sub>T \<Rightarrow> 32 word"
where
  "serialise_size_Obj ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>obj. (+) (24 :: 32 word) (serialise_size_ObjUnion (Obj.ounion\<^sub>f obj)))"

definition
  dentarr_calculate_sz_change :: "bool \<times>  Obj\<^sub>T \<Rightarrow>  Obj\<^sub>T \<times> (32 word, 32 word) R"
where
  "dentarr_calculate_sz_change ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(created,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(objdent,ds\<^sub>2). HOL.Let (serialise_size_Obj objdent) (\<lambda>sz. HOL.If (HOL.Not created) (Let\<^sub>d\<^sub>s (safe_sub32 (sz, Obj.len\<^sub>f objdent)) (\<lambda>ds\<^sub>3. case_R (\<lambda>ds\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>4 (\<lambda>ds\<^sub>6. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>7. (objdent, (R.Error (75 :: 32 word) :: (32 word, 32 word) R))))) (\<lambda>sz_change. (Obj.len\<^sub>f_update (\<lambda>_. sz) objdent, (R.Success sz_change :: (32 word, 32 word) R))) ds\<^sub>3)) (Obj.len\<^sub>f_update (\<lambda>_. sz) objdent, (R.Success sz :: (32 word, 32 word) R)))))"

definition
  dentarr_del_calculate_sz_change :: " SysState \<times>  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<Rightarrow> ( SysState \<times>  Obj\<^sub>T) \<times> (32 word, 32 word) R"
where
  "dentarr_del_calculate_sz_change ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(dentarr,ds\<^sub>3). HOL.Let ((=) (array_nb_elem (ObjDentarr.entries\<^sub>f dentarr)) (0 :: 32 word)) (\<lambda>is_del. HOL.Let (ObjDentarr.id\<^sub>f dentarr) (\<lambda>id. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (HOL.If is_del (deep_freeObjDentarr (ex, dentarr), HOL.Let (ObjDel.make id) (\<lambda>v. (ObjUnion.TObjDel v ::  ObjUnion\<^sub>T))) (ex, (ObjUnion.TObjDentarr dentarr ::  ObjUnion\<^sub>T))) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p2\<^sub>f) (\<lambda>(ounion,ds\<^sub>5). HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. ounion) obj) (\<lambda>obj. HOL.Let (serialise_size_Obj obj) (\<lambda>len. Let\<^sub>d\<^sub>s (safe_sub32 (Obj.len\<^sub>f obj, len)) (\<lambda>ds\<^sub>6. case_R (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s ds\<^sub>7 (\<lambda>ds\<^sub>9. ((ex, obj), (R.Error (75 :: 32 word) :: (32 word, 32 word) R)))) (\<lambda>sz_change. ((ex, Obj.len\<^sub>f_update (\<lambda>_. len) obj), (R.Success sz_change :: (32 word, 32 word) R))) ds\<^sub>6))))))))))"

definition
  obj_del_new :: " SysState \<times> 64 word \<Rightarrow>  SysState \<times> (32 word,  Obj\<^sub>T) R"
where
  "obj_del_new ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(id,ds\<^sub>2). Let\<^sub>d\<^sub>s (newObj ex) (\<lambda>ds\<^sub>3. case_R (\<lambda>ex. (ex, (R.Error (12 :: 32 word) :: (32 word,  Obj\<^sub>T) R))) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>7). HOL.Let (obj_init_default (obj, (3 :: 8 word))) (\<lambda>obj. HOL.Let (ObjDel.make id) (\<lambda>del. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDel del ::  ObjUnion\<^sub>T)) obj) (\<lambda>obj. HOL.Let (serialise_size_Obj obj) (\<lambda>len. HOL.Let (Obj.len\<^sub>f_update (\<lambda>_. len) obj) (\<lambda>obj. (ex, (R.Success obj :: (32 word,  Obj\<^sub>T) R)))))))))) ds\<^sub>3)))"

definition
  obj_inode_new :: " SysState \<times>  VfsInode\<^sub>T \<Rightarrow>  SysState \<times> (32 word,  Obj\<^sub>T) R"
where
  "obj_inode_new ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(vnode,ds\<^sub>2). Let\<^sub>d\<^sub>s (newObj ex) (\<lambda>ds\<^sub>3. case_R (\<lambda>ex. (ex, (R.Error (12 :: 32 word) :: (32 word,  Obj\<^sub>T) R))) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>7). Let\<^sub>d\<^sub>s (newObjInode ex) (\<lambda>ds\<^sub>8. case_R (\<lambda>ex. HOL.Let (freeObj (ex, obj)) (\<lambda>ex. (ex, (R.Error (12 :: 32 word) :: (32 word,  Obj\<^sub>T) R)))) (\<lambda>ds\<^sub>1\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(inode,ds\<^sub>1\<^sub>2). HOL.Let (obj_init_default (obj, (0 :: 8 word))) (\<lambda>obj. HOL.Let (obj_id_inode_mk (vfs_inode_get_ino vnode)) (\<lambda>id. HOL.Let (vfs_inode_get_size vnode) (\<lambda>size. HOL.Let (vfs_inode_get_mtime vnode) (\<lambda>mtime. HOL.Let (vfs_inode_get_ctime vnode) (\<lambda>ctime. HOL.Let (ucast (OSTimeSpec.tv_sec\<^sub>f mtime) :: 64 word) (\<lambda>atime_sec. HOL.Let (ucast (OSTimeSpec.tv_sec\<^sub>f ctime) :: 64 word) (\<lambda>ctime_sec. HOL.Let (ucast (OSTimeSpec.tv_sec\<^sub>f mtime) :: 64 word) (\<lambda>mtime_sec. HOL.Let (vfs_inode_get_nlink vnode) (\<lambda>nlink. HOL.Let (vfs_inode_get_uid vnode) (\<lambda>uid. HOL.Let (vfs_inode_get_gid vnode) (\<lambda>gid. HOL.Let (vfs_inode_get_mode vnode) (\<lambda>mode. HOL.Let (vfs_inode_get_flags vnode) (\<lambda>flags. HOL.Let (ObjInode.flags\<^sub>f_update (\<lambda>_. flags) (ObjInode.mode\<^sub>f_update (\<lambda>_. mode) (ObjInode.gid\<^sub>f_update (\<lambda>_. gid) (ObjInode.uid\<^sub>f_update (\<lambda>_. uid) (ObjInode.nlink\<^sub>f_update (\<lambda>_. nlink) (ObjInode.mtime_sec\<^sub>f_update (\<lambda>_. mtime_sec) (ObjInode.ctime_sec\<^sub>f_update (\<lambda>_. ctime_sec) (ObjInode.atime_sec\<^sub>f_update (\<lambda>_. atime_sec) (ObjInode.size\<^sub>f_update (\<lambda>_. size) (ObjInode.id\<^sub>f_update (\<lambda>_. id) inode)))))))))) (\<lambda>inode. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjInode inode ::  ObjUnion\<^sub>T)) obj) (\<lambda>obj. HOL.Let (serialise_size_Obj obj) (\<lambda>len. HOL.Let (Obj.len\<^sub>f_update (\<lambda>_. len) obj) (\<lambda>obj. (ex, (R.Success obj :: (32 word,  Obj\<^sub>T) R)))))))))))))))))))))) ds\<^sub>8)))) ds\<^sub>3)))"

definition
  arrayobj_create2 :: " SysState \<times>  Obj\<^sub>T \<times>  Obj\<^sub>T \<Rightarrow> ( SysState \<times>  Obj\<^sub>T,  SysState \<times>  Obj\<^sub>T Array) R"
where
  "arrayobj_create2 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(o1,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(o2,ds\<^sub>3). Let\<^sub>d\<^sub>s (array_create (ex, (2 :: 32 word))) (\<lambda>ds\<^sub>4. case_R (\<lambda>ex. HOL.Let (deep_freeObj (ex, o1)) (\<lambda>ex. (R.Error (ex, o2) :: ( SysState \<times>  Obj\<^sub>T,  SysState \<times>  Obj\<^sub>T Array) R))) (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (array_modify (ArrayModifyP.make arr (0 :: 32 word) set_obj (ex, (Option.Some o1 :: (unit,  Obj\<^sub>T) Option)))) ArrA.arr\<^sub>f) (\<lambda>(arr,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 ArrA.acc\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>1,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(opt1,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (array_modify (ArrayModifyP.make arr (1 :: 32 word) set_obj (ex, (Option.Some o2 :: (unit,  Obj\<^sub>T) Option)))) ArrA.arr\<^sub>f) (\<lambda>(arr,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 ArrA.acc\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>6,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(opt2,ds\<^sub>1\<^sub>8). HOL.Let (free_opt_obj (ex, opt1)) (\<lambda>ex. HOL.Let (free_opt_obj (ex, opt2)) (\<lambda>ex. (R.Success (ex, arr) :: ( SysState \<times>  Obj\<^sub>T,  SysState \<times>  Obj\<^sub>T Array) R)))))))))))))) ds\<^sub>4))))"

definition
  dentarr_add_dentry :: " SysState \<times>  ObjDentarr\<^sub>T \<times>  VfsInode\<^sub>T \<times> 8 word WordArray \<times> 8 word \<Rightarrow> ( SysState \<times>  ObjDentarr\<^sub>T) \<times> (32 word, unit) R"
where
  "dentarr_add_dentry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P5_p2\<^sub>f) (\<lambda>(odent,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p3\<^sub>f) (\<lambda>(vnode,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p4\<^sub>f) (\<lambda>(name,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p5\<^sub>f) (\<lambda>(dtype,ds\<^sub>5). HOL.Let (ObjDentarr.nb_dentry\<^sub>f odent) (\<lambda>nb_dentry. HOL.Let (wordarray_length name) (\<lambda>name_len. HOL.If ((>) ((+) nb_dentry (1 :: 32 word)) (16 :: 32 word) \<or> (>) name_len ((+) (255 :: 32 word) (1 :: 32 word))) ((ex, odent), (R.Error (36 :: 32 word) :: (32 word, unit) R)) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (obj_dentry_new_init (ex, vfs_inode_get_ino vnode, name, dtype)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>7). case_R (\<lambda>e. ((ex, odent), (R.Error e :: (32 word, unit) R))) (\<lambda>newentry. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t odent ObjDentarr.id\<^sub>f) (\<lambda>(id,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 ObjDentarr.entries\<^sub>f) (\<lambda>(entries,odent). HOL.Let ((-) (array_length entries) (1 :: 32 word)) (\<lambda>last_index. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (array_modify (ArrayModifyP.make entries last_index add_dentry_modifier (ex, (Option.Some newentry :: (unit,  ObjDentry\<^sub>T) Option)))) ArrA.arr\<^sub>f) (\<lambda>(entries,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 ArrA.acc\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>2,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(opt_entry,ds\<^sub>1\<^sub>4). HOL.Let ((+) nb_dentry (1 :: 32 word)) (\<lambda>nb_dentry. HOL.Let (free_opt_ObjDentry (ex, opt_entry)) (\<lambda>ex. ((ex, ObjDentarr.entries\<^sub>f_update (\<lambda>_. entries) (ObjDentarr.nb_dentry\<^sub>f_update (\<lambda>_. nb_dentry) (ObjDentarr.id\<^sub>f_update (\<lambda>_. id) odent))), (R.Success () :: (32 word, unit) R)))))))))))) r))))))))))"

definition
  truncate_arrayobj_create :: " SysState \<times> (unit,  Obj\<^sub>T) Option \<times> (unit,  Obj\<^sub>T) Option \<times>  Obj\<^sub>T \<Rightarrow> ( SysState,  SysState \<times>  Obj\<^sub>T Array) R"
where
  "truncate_arrayobj_create ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(o1,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(o2,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(o3,ds\<^sub>4). Let\<^sub>d\<^sub>s (array_create (ex, (3 :: 32 word))) (\<lambda>ds\<^sub>5. case_R (\<lambda>ex. HOL.Let (free_opt_obj (ex, o1)) (\<lambda>ex. HOL.Let (free_opt_obj (ex, o2)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, o3)) (\<lambda>ex. (R.Error ex :: ( SysState,  SysState \<times>  Obj\<^sub>T Array) R))))) (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (array_modify (ArrayModifyP.make arr (0 :: 32 word) set_obj (ex, o1))) ArrA.arr\<^sub>f) (\<lambda>(arr,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 ArrA.acc\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>2,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(opt1,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (array_modify (ArrayModifyP.make arr (1 :: 32 word) set_obj (ex, o2))) ArrA.arr\<^sub>f) (\<lambda>(arr,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 ArrA.acc\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>7,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(opt2,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (array_modify (ArrayModifyP.make arr (2 :: 32 word) set_obj (ex, (Option.Some o3 :: (unit,  Obj\<^sub>T) Option)))) ArrA.arr\<^sub>f) (\<lambda>(arr,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 ArrA.acc\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>2,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p2\<^sub>f) (\<lambda>(opt3,ds\<^sub>2\<^sub>4). HOL.Let (free_opt_obj (ex, opt1)) (\<lambda>ex. HOL.Let (free_opt_obj (ex, opt2)) (\<lambda>ex. HOL.Let (free_opt_obj (ex, opt3)) (\<lambda>ex. (R.Success (ex, arr) :: ( SysState,  SysState \<times>  Obj\<^sub>T Array) R))))))))))))))))))) ds\<^sub>5)))))"

definition
  fsm_mark_ebnum_dirty :: " FsmState\<^sub>T \<times> 32 word \<times> 32 word \<Rightarrow>  FsmState\<^sub>T"
where
  "fsm_mark_ebnum_dirty ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p2\<^sub>f) (\<lambda>(ebnum,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P3_p3\<^sub>f) (\<lambda>(len,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 FsmState.dirty_space\<^sub>f) (\<lambda>(dirty_space,fsm_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (wordarray_modify (ArrayUseValueP.make dirty_space ebnum mark_dirty_modifier () len)) ArrA.arr\<^sub>f) (\<lambda>(dirty_space,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 ArrA.acc\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>5). Let\<^sub>d\<^sub>s ds\<^sub>7 (\<lambda>ds\<^sub>8. FsmState.dirty_space\<^sub>f_update (\<lambda>_. dirty_space) fsm_st)))))))"

definition
  fsm_mark_dirty_recycle :: " SysState \<times>  MountState\<^sub>T \<times>  FsmState\<^sub>T \<times> 64 word \<times>  ObjAddr\<^sub>T \<times> (64 word,  GimNode\<^sub>T) RbtNode \<Rightarrow>  SysState \<times>  FsmState\<^sub>T"
where
  "fsm_mark_dirty_recycle ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P6_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P6_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P6_p3\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P6_p4\<^sub>f) (\<lambda>(oid,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P6_p5\<^sub>f) (\<lambda>(oaddr,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P6_p6\<^sub>f) (\<lambda>(node,ds\<^sub>6). HOL.Let (fsm_mark_ebnum_dirty (fsm_st, ObjAddr.ebnum\<^sub>f oaddr, ObjAddr.len\<^sub>f oaddr)) (\<lambda>fsm_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fsm_st FsmState.gim\<^sub>f) (\<lambda>(gim,fsm_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (rbt_modify (RbtModifyP.make gim oid gim_modifier node () (oid, ObjAddr.sqnum\<^sub>f oaddr, (1 :: 16 word)))) RbtModifyR.rbt\<^sub>f) (\<lambda>(gim,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 RbtModifyR.optnode\<^sub>f) (\<lambda>(optnode,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 RbtModifyR.acc\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>0,ds\<^sub>7). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>0 (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (freeOptRbtNode (ex, optnode)) (\<lambda>ex. (ex, FsmState.gim\<^sub>f_update (\<lambda>_. gim) fsm_st))))))))))))))"

definition
  fsm_mark_used :: " MountState\<^sub>T \<times>  FsmState\<^sub>T \<times> 32 word \<Rightarrow>  FsmState\<^sub>T"
where
  "fsm_mark_used ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P3_p3\<^sub>f) (\<lambda>(ebnum,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 FsmState.used_eb\<^sub>f) (\<lambda>(used_eb,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsmState.nb_free_eb\<^sub>f) (\<lambda>(nb_free_eb,fsm_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (wordarray_modify (ArrayUseValueP.make used_eb ebnum mark_used_modifier nb_free_eb ())) ArrA.arr\<^sub>f) (\<lambda>(used_eb,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 ArrA.acc\<^sub>f) (\<lambda>(nb_free_eb,ds\<^sub>6). FsmState.nb_free_eb\<^sub>f_update (\<lambda>_. nb_free_eb) (FsmState.used_eb\<^sub>f_update (\<lambda>_. used_eb) fsm_st))))))))"

definition
  fsm_alloc_eb :: " MountState\<^sub>T \<times>  FsmState\<^sub>T \<times> 32 word \<Rightarrow>  FsmState\<^sub>T \<times> (32 word, 32 word) R"
where
  "fsm_alloc_eb ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(osw_flags,ds\<^sub>3). Let\<^sub>d\<^sub>s (fsm_check_free_space (mount_st, fsm_st, osw_flags)) (\<lambda>ds\<^sub>4. case_R (\<lambda>err. (fsm_st, (R.Error err :: (32 word, 32 word) R))) (\<lambda>ds\<^sub>6. Let\<^sub>d\<^sub>s ds\<^sub>6 (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. Let\<^sub>d\<^sub>s (wordarray_fold (ArrayMapP.make (FsmState.used_eb\<^sub>f fsm_st) (2 :: 32 word) (ObjSuper.nb_eb\<^sub>f (MountState.super\<^sub>f mount_st)) fsm_alloc_eb_loop_body (2 :: 32 word) fsm_st)) (\<lambda>ds\<^sub>9. case_LoopResult (\<lambda>ebnum. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (fsm_mark_used (mount_st, fsm_st, ebnum)) (\<lambda>fsm_st. (fsm_st, (R.Success ebnum :: (32 word, 32 word) R))))) (\<lambda>ds\<^sub>1\<^sub>0. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>0 (\<lambda>ds\<^sub>1\<^sub>2. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>3. (fsm_st, (R.Error (28 :: 32 word) :: (32 word, 32 word) R))))) ds\<^sub>9)))) ds\<^sub>4))))"

definition
  serialise_u8 :: " Buffer\<^sub>T \<times> 32 word \<times> 8 word \<Rightarrow>  Buffer\<^sub>T"
where
  "serialise_u8 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P3_p3\<^sub>f) (\<lambda>(val,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 Buffer.bound\<^sub>f) (\<lambda>(bound,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 Buffer.data\<^sub>f) (\<lambda>(data,buf). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (wordarray_modify (ArrayUseValueP.make data offs setu8 () val)) ArrA.arr\<^sub>f) (\<lambda>(data,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 ArrA.acc\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>6). Let\<^sub>d\<^sub>s ds\<^sub>8 (\<lambda>ds\<^sub>9. Buffer.data\<^sub>f_update (\<lambda>_. data) (Buffer.bound\<^sub>f_update (\<lambda>_. bound) buf)))))))))"

definition
  serialise_le16 :: " Buffer\<^sub>T \<times> 32 word \<times> 16 word \<Rightarrow>  Buffer\<^sub>T"
where
  "serialise_le16 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(val,ds\<^sub>3). HOL.Let (serialise_u8 (buf, offs, u16_to_u8 val)) (\<lambda>buf. serialise_u8 (buf, (+) offs (1 :: 32 word), u16_to_u8 (checked_shift shiftr val (8 :: 16 word)))))))"

definition
  serialise_le32 :: " Buffer\<^sub>T \<times> 32 word \<times> 32 word \<Rightarrow>  Buffer\<^sub>T"
where
  "serialise_le32 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(val,ds\<^sub>3). HOL.Let (serialise_u8 (buf, offs, u32_to_u8 val)) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (1 :: 32 word), u32_to_u8 (checked_shift shiftr val (8 :: 32 word)))) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (2 :: 32 word), u32_to_u8 (checked_shift shiftr val (16 :: 32 word)))) (\<lambda>buf. serialise_u8 (buf, (+) offs (3 :: 32 word), u32_to_u8 (checked_shift shiftr val (24 :: 32 word)))))))))"

definition
  serialise_ObjDentry :: " Buffer\<^sub>T \<times> 32 word \<times>  ObjDentry\<^sub>T \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjDentry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(dentry,ds\<^sub>3). Let\<^sub>d\<^sub>s (print_ObjDentry dentry) (\<lambda>ds\<^sub>4. HOL.Let (serialise_le32 (buf, offs, ObjDentry.ino\<^sub>f dentry)) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (4 :: 32 word), ObjDentry.dtype\<^sub>f dentry)) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (5 :: 32 word), (66 :: 8 word))) (\<lambda>buf. HOL.Let (serialise_le16 (buf, (+) offs (6 :: 32 word), ObjDentry.nlen\<^sub>f dentry)) (\<lambda>buf. HOL.Let (serialise_wordarray_U8 (buf, (+) offs (8 :: 32 word), ObjDentry.name\<^sub>f dentry)) (\<lambda>buf. (buf, (+) ((+) offs (8 :: 32 word)) (wordarray_length (ObjDentry.name\<^sub>f dentry))))))))))))"

definition
  serialise_Arr_ObjDentry_f :: "( ObjDentry\<^sub>T,  Buffer\<^sub>T \<times> 32 word, unit) ElemAO \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_Arr_ObjDentry_f ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(dentry,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>1). Let\<^sub>d\<^sub>s ds\<^sub>7 (\<lambda>ds\<^sub>8. serialise_ObjDentry (buf, offs, dentry)))))))"

definition
  serialise_Array_ObjDentry :: " Buffer\<^sub>T \<times> 32 word \<times>  ObjDentry\<^sub>T Array \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_Array_ObjDentry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>3). array_fold_no_break (ArrayFoldP.make arr serialise_Arr_ObjDentry_f (buf, offs) ()))))"

definition
  serialise_le64 :: " Buffer\<^sub>T \<times> 32 word \<times> 64 word \<Rightarrow>  Buffer\<^sub>T"
where
  "serialise_le64 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(val,ds\<^sub>3). HOL.Let (serialise_u8 (buf, offs, u64_to_u8 val)) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (1 :: 32 word), u64_to_u8 (checked_shift shiftr val (8 :: 64 word)))) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (2 :: 32 word), u64_to_u8 (checked_shift shiftr val (16 :: 64 word)))) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (3 :: 32 word), u64_to_u8 (checked_shift shiftr val (24 :: 64 word)))) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (4 :: 32 word), u64_to_u8 (checked_shift shiftr val (32 :: 64 word)))) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (5 :: 32 word), u64_to_u8 (checked_shift shiftr val (40 :: 64 word)))) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (6 :: 32 word), u64_to_u8 (checked_shift shiftr val (48 :: 64 word)))) (\<lambda>buf. serialise_u8 (buf, (+) offs (7 :: 32 word), u64_to_u8 (checked_shift shiftr val (56 :: 64 word)))))))))))))"

definition
  serialise_ObjData :: " Buffer\<^sub>T \<times> 32 word \<times>  ObjData\<^sub>T \<times> 32 word \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjData ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(od,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(olen,ds\<^sub>4). HOL.Let ((-) ((-) olen (24 :: 32 word)) (8 :: 32 word)) (\<lambda>arrlen. HOL.Let (serialise_le64 (buf, offs, ObjData.id\<^sub>f od)) (\<lambda>buf. HOL.Let (Buffer.bound\<^sub>f buf) (\<lambda>bound. HOL.Let (Buffer.bound\<^sub>f_update (\<lambda>_. (+) ((+) offs (8 :: 32 word)) arrlen) buf) (\<lambda>buf. HOL.Let (serialise_wordarray_U8 (buf, (+) offs (8 :: 32 word), ObjData.odata\<^sub>f od)) (\<lambda>buf. HOL.Let (Buffer.bound\<^sub>f buf) (\<lambda>offs. HOL.Let (Buffer.bound\<^sub>f_update (\<lambda>_. bound) buf) (\<lambda>buf. (buf, offs))))))))))))"

definition
  serialise_ObjDel :: " Buffer\<^sub>T \<times> 32 word \<times>  ObjDel\<^sub>T \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjDel ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(od,ds\<^sub>3). HOL.Let (serialise_le64 (buf, offs, ObjDel.id\<^sub>f od)) (\<lambda>buf. (buf, (+) offs (8 :: 32 word))))))"

definition
  serialise_ObjDentarr :: " Buffer\<^sub>T \<times> 32 word \<times>  ObjDentarr\<^sub>T \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjDentarr ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(dentarr,ds\<^sub>3). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. HOL.Let (serialise_le64 (buf, offs, ObjDentarr.id\<^sub>f dentarr)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (8 :: 32 word), ObjDentarr.nb_dentry\<^sub>f dentarr)) (\<lambda>buf. serialise_Array_ObjDentry (buf, (+) offs (12 :: 32 word), ObjDentarr.entries\<^sub>f dentarr)))))))"

definition
  serialise_ObjHeader :: " Buffer\<^sub>T \<times> 32 word \<times>  Obj\<^sub>T \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjHeader ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(obj,ds\<^sub>3). HOL.Let (serialise_le32 (buf, offs, Obj.magic\<^sub>f obj)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (4 :: 32 word), Obj.crc\<^sub>f obj)) (\<lambda>buf. HOL.Let (serialise_le64 (buf, (+) offs (8 :: 32 word), Obj.sqnum\<^sub>f obj)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (16 :: 32 word), Obj.len\<^sub>f obj)) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (20 :: 32 word), (66 :: 8 word))) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (21 :: 32 word), (66 :: 8 word))) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (22 :: 32 word), Obj.trans\<^sub>f obj)) (\<lambda>buf. HOL.Let (serialise_u8 (buf, (+) offs (23 :: 32 word), Obj.otype\<^sub>f obj)) (\<lambda>buf. (buf, (+) offs (24 :: 32 word)))))))))))))"

definition
  serialise_ObjInode :: " Buffer\<^sub>T \<times> 32 word \<times>  ObjInode\<^sub>T \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjInode ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(oi,ds\<^sub>3). HOL.Let (serialise_le64 (buf, offs, ObjInode.id\<^sub>f oi)) (\<lambda>buf. HOL.Let (serialise_le64 (buf, (+) offs (8 :: 32 word), ObjInode.size\<^sub>f oi)) (\<lambda>buf. HOL.Let (serialise_le64 (buf, (+) offs (16 :: 32 word), ObjInode.atime_sec\<^sub>f oi)) (\<lambda>buf. HOL.Let (serialise_le64 (buf, (+) offs (24 :: 32 word), ObjInode.ctime_sec\<^sub>f oi)) (\<lambda>buf. HOL.Let (serialise_le64 (buf, (+) offs (32 :: 32 word), ObjInode.mtime_sec\<^sub>f oi)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (40 :: 32 word), ObjInode.nlink\<^sub>f oi)) (\<lambda>buf. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>6. HOL.Let (serialise_le32 (buf, (+) offs (44 :: 32 word), ObjInode.uid\<^sub>f oi)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (48 :: 32 word), ObjInode.gid\<^sub>f oi)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (52 :: 32 word), ObjInode.mode\<^sub>f oi)) (\<lambda>buf. (serialise_le32 (buf, (+) offs (56 :: 32 word), ObjInode.flags\<^sub>f oi), (+) offs (60 :: 32 word)))))))))))))))))"

definition
  serialise_ObjSumEntry :: " Buffer\<^sub>T \<times> 32 word \<times>  ObjSumEntry\<^sub>T \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjSumEntry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(sumentry,ds\<^sub>3). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. HOL.Let (serialise_le64 (buf, offs, ObjSumEntry.id\<^sub>f sumentry)) (\<lambda>buf. HOL.Let (serialise_le64 (buf, (+) offs (8 :: 32 word), ObjSumEntry.sqnum\<^sub>f sumentry)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (16 :: 32 word), ObjSumEntry.len\<^sub>f sumentry)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (20 :: 32 word), ObjSumEntry.del_flags_and_offs\<^sub>f sumentry)) (\<lambda>buf. HOL.Let (serialise_le16 (buf, (+) offs (24 :: 32 word), ObjSumEntry.count\<^sub>f sumentry)) (\<lambda>buf. (buf, (+) offs (26 :: 32 word)))))))))))"

definition
  serialise_ObjSumEntry_f :: "( ObjSumEntry\<^sub>T,  Buffer\<^sub>T \<times> 32 word, unit) ElemAO \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjSumEntry_f ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(sumentry,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(obsv,ds\<^sub>1). serialise_ObjSumEntry (buf, offs, sumentry))))))"

definition
  serialise_wordarray_ObjSumEntry :: " Buffer\<^sub>T \<times> 32 word \<times>  ObjSumEntry\<^sub>T WordArray \<times> 32 word \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_wordarray_ObjSumEntry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(entries,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(nb_sum_entry,ds\<^sub>4). HOL.Let ((*) (26 :: 32 word) nb_sum_entry) (\<lambda>arrsz. HOL.Let (HOL.If ((>) ((+) offs arrsz) (Buffer.bound\<^sub>f buf)) (Buffer.bound\<^sub>f buf) ((+) offs arrsz)) (\<lambda>end. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>6. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. wordarray_fold_no_break (ArrayMapP.make entries (0 :: 32 word) nb_sum_entry serialise_ObjSumEntry_f (buf, offs) ()))))))))))))"

definition
  serialise_ObjSummary :: " Buffer\<^sub>T \<times> 32 word \<times>  ObjSummary\<^sub>T \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjSummary ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(sum,ds\<^sub>3). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. HOL.Let (serialise_le32 (buf, offs, ObjSummary.nb_sum_entry\<^sub>f sum)) (\<lambda>buf. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (serialise_wordarray_ObjSumEntry (buf, (+) offs (4 :: 32 word), ObjSummary.entries\<^sub>f sum, ObjSummary.nb_sum_entry\<^sub>f sum)) P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>6). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>0. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (serialise_le32 (buf, offs, ObjSummary.sum_offs\<^sub>f sum)) (\<lambda>buf. (buf, (+) offs (4 :: 32 word)))))))))))))))"

definition
  serialise_ObjSummary_crc :: " Buffer\<^sub>T \<times> 32 word \<times>  Obj\<^sub>T \<times>  ObjSummary\<^sub>T \<Rightarrow>  Obj\<^sub>T \<times>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjSummary_crc ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(sum_obj,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(sum,ds\<^sub>4). Let\<^sub>d\<^sub>s (serialise_ObjHeader (buf, offs, sum_obj)) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(offs',ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (serialise_ObjSummary (buf, offs', sum)) P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(offs',ds\<^sub>9). HOL.Let (crc32_buf (Crc32bufP.make buf ((+) offs (8 :: 32 word)) offs')) (\<lambda>crc. HOL.Let (Obj.crc\<^sub>f_update (\<lambda>_. crc) sum_obj) (\<lambda>sum_obj. HOL.Let (serialise_le32 (buf, (+) offs (4 :: 32 word), crc)) (\<lambda>buf. (sum_obj, buf, offs')))))))))))))"

definition
  serialise_ObjSuper :: " Buffer\<^sub>T \<times> 32 word \<times>  ObjSuper\<^sub>T \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjSuper ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(os,ds\<^sub>3). HOL.Let (serialise_le32 (buf, offs, ObjSuper.nb_eb\<^sub>f os)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (4 :: 32 word), ObjSuper.eb_size\<^sub>f os)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (8 :: 32 word), ObjSuper.io_size\<^sub>f os)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (12 :: 32 word), ObjSuper.nb_reserved_gc\<^sub>f os)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (16 :: 32 word), ObjSuper.nb_reserved_del\<^sub>f os)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (20 :: 32 word), ObjSuper.cur_eb\<^sub>f os)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (24 :: 32 word), ObjSuper.cur_offs\<^sub>f os)) (\<lambda>buf. HOL.Let (serialise_le32 (buf, (+) offs (28 :: 32 word), ObjSuper.last_inum\<^sub>f os)) (\<lambda>buf. HOL.Let (serialise_le64 (buf, (+) offs (32 :: 32 word), ObjSuper.next_sqnum\<^sub>f os)) (\<lambda>buf. (buf, (+) offs (40 :: 32 word))))))))))))))"

definition
  serialise_ObjUnion :: " Buffer\<^sub>T \<times> 32 word \<times>  ObjUnion\<^sub>T \<times> 32 word \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_ObjUnion ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ou,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(olen,ds\<^sub>4). case_ObjUnion (\<lambda>obj. serialise_ObjData (buf, offs, obj, olen)) (\<lambda>obj. serialise_ObjDel (buf, offs, obj)) (\<lambda>obj. serialise_ObjDentarr (buf, offs, obj)) (\<lambda>obj. serialise_ObjInode (buf, offs, obj)) (\<lambda>ds\<^sub>1\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>1 (\<lambda>ds\<^sub>1\<^sub>2. serialise_ObjPad (buf, offs, olen))) (\<lambda>obj. serialise_ObjSummary (buf, offs, obj)) (\<lambda>obj. serialise_ObjSuper (buf, offs, obj)) ou))))"

definition
  serialise_Obj :: " Buffer\<^sub>T \<times> 32 word \<times>  Obj\<^sub>T \<Rightarrow>  Buffer\<^sub>T \<times> 32 word"
where
  "serialise_Obj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(obj,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (serialise_ObjHeader (buf, offs, obj)) P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>5). serialise_ObjUnion (buf, offs, Obj.ounion\<^sub>f obj, Obj.len\<^sub>f obj))))))"

definition
  serialise_Obj_crc :: " Buffer\<^sub>T \<times> 32 word \<times>  Obj\<^sub>T \<Rightarrow>  Buffer\<^sub>T \<times> 32 word \<times>  Obj\<^sub>T"
where
  "serialise_Obj_crc ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(obj,ds\<^sub>3). Let\<^sub>d\<^sub>s (serialise_Obj (buf, offs, obj)) (\<lambda>ds\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(offs',ds\<^sub>6). HOL.Let (crc32_buf (Crc32bufP.make buf ((+) offs (8 :: 32 word)) offs')) (\<lambda>crc. HOL.Let (Obj.offs\<^sub>f_update (\<lambda>_. offs) (Obj.crc\<^sub>f_update (\<lambda>_. crc) obj)) (\<lambda>obj. HOL.Let (serialise_le32 (buf, (+) offs (4 :: 32 word), crc)) (\<lambda>buf. (buf, offs', obj))))))))))"

definition
  write_objects_loop_body :: "( Obj\<^sub>T,  Buffer\<^sub>T \<times> 32 word \<times> 64 word \<times> 32 word, 32 word) ElemAO \<Rightarrow> (( Obj\<^sub>T, 32 word \<times>  Buffer\<^sub>T) ElemB, ( Obj\<^sub>T,  Buffer\<^sub>T \<times> 32 word \<times> 64 word \<times> 32 word) ElemA) LoopResult"
where
  "write_objects_loop_body ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(obj,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P4_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P4_p2\<^sub>f) (\<lambda>(used,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P4_p3\<^sub>f) (\<lambda>(sqnum,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P4_p4\<^sub>f) (\<lambda>(i,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(nb_objs,ds\<^sub>1). HOL.If ((<) ((+) sqnum (1 :: 64 word)) sqnum) (LoopResult.Break (ElemB.make obj ((75 :: 32 word), buf)) :: (( Obj\<^sub>T, 32 word \<times>  Buffer\<^sub>T) ElemB, ( Obj\<^sub>T,  Buffer\<^sub>T \<times> 32 word \<times> 64 word \<times> 32 word) ElemA) LoopResult) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.sqnum\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>0,ds\<^sub>9). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>0 (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 Obj.offs\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 Obj.trans\<^sub>f) (\<lambda>(trans,obj). HOL.Let (get_obj_trans (i, nb_objs)) (\<lambda>trans. HOL.Let (Obj.trans\<^sub>f_update (\<lambda>_. trans) (Obj.offs\<^sub>f_update (\<lambda>_. used) (Obj.sqnum\<^sub>f_update (\<lambda>_. sqnum) obj))) (\<lambda>obj. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (serialise_Obj_crc (buf, used, obj)) P3_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p3\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.ounion\<^sub>f) (\<lambda>(ounion,obj). Let\<^sub>d\<^sub>s (print_ObjHeader obj) (\<lambda>ds\<^sub>1\<^sub>6. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>6 (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. ounion) obj) (\<lambda>obj. (LoopResult.Iterate (ElemA.make obj (buf, offs, (+) sqnum (1 :: 64 word), (+) i (1 :: 32 word))) :: (( Obj\<^sub>T, 32 word \<times>  Buffer\<^sub>T) ElemB, ( Obj\<^sub>T,  Buffer\<^sub>T \<times> 32 word \<times> 64 word \<times> 32 word) ElemA) LoopResult))))))))))))))))))))))"

definition
  write_objects :: " Buffer\<^sub>T \<times> 32 word \<times> 64 word \<times>  Obj\<^sub>T Array \<Rightarrow> ( Buffer\<^sub>T \<times>  Obj\<^sub>T Array \<times> 32 word) \<times> (unit, 64 word) R"
where
  "write_objects ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(used,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(next_sqnum,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(arr,ds\<^sub>4). HOL.Let (0 :: 32 word) (\<lambda>i. HOL.Let (array_length arr) (\<lambda>nb_objs. Let\<^sub>d\<^sub>s (array_map_ex (ArrayMapP.make arr (0 :: 32 word) nb_objs write_objects_loop_body (buf, used, next_sqnum, i) nb_objs)) (\<lambda>ds\<^sub>5. case_LoopResult (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 ArrB.arr\<^sub>f) (\<lambda>(arr,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 ArrB.rbrk\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>0,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>1\<^sub>2). ((buf, arr, e), (R.Error () :: (unit, 64 word) R))))))) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 ArrA.arr\<^sub>f) (\<lambda>(arr,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 ArrA.acc\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>1,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P4_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P4_p2\<^sub>f) (\<lambda>(used,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P4_p3\<^sub>f) (\<lambda>(next_sqnum,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P4_p4\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>2,ds\<^sub>1\<^sub>6). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>2 (\<lambda>ds\<^sub>1\<^sub>7. ((buf, arr, used), (R.Success next_sqnum :: (unit, 64 word) R)))))))))) ds\<^sub>5)))))))"

definition
  serialise_Obj_Super_crc :: " SysState \<times>  Buffer\<^sub>T \<times> 32 word \<times>  Obj\<^sub>T \<times>  ObjSuper\<^sub>T \<Rightarrow>  SysState \<times>  Buffer\<^sub>T \<times> 32 word \<times>  Obj\<^sub>T"
where
  "serialise_Obj_Super_crc ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P5_p2\<^sub>f) (\<lambda>(buf,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p4\<^sub>f) (\<lambda>(obj,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p5\<^sub>f) (\<lambda>(sup,ds\<^sub>5). HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjPad () ::  ObjUnion\<^sub>T)) obj) (\<lambda>obj. Let\<^sub>d\<^sub>s (serialise_ObjHeader (buf, offs, obj)) (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(offs',ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.ounion\<^sub>f) (\<lambda>(ounion,obj). HOL.Let (deep_freeObjUnion (ex, ounion)) (\<lambda>ex. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (serialise_ObjSuper (buf, offs', sup)) P2_p1\<^sub>f) (\<lambda>(buf,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(offs',ds\<^sub>1\<^sub>0). HOL.Let (crc32_buf (Crc32bufP.make buf ((+) offs (8 :: 32 word)) offs')) (\<lambda>crc. HOL.Let (Obj.crc\<^sub>f_update (\<lambda>_. crc) obj) (\<lambda>obj. HOL.Let (serialise_le32 (buf, (+) offs (4 :: 32 word), crc)) (\<lambda>buf. (ex, buf, offs', obj)))))))))))))))))"

definition
  fsop_getattr :: " FsopGetattrP\<^sub>T \<Rightarrow>  FsopGetattrR\<^sub>T"
where
  "fsop_getattr ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopGetattrP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopGetattrP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopGetattrP.stat\<^sub>f) (\<lambda>(stat,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopGetattrP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1). HOL.Let (vfs_stat_set_ino (stat, vfs_inode_get_ino vnode)) (\<lambda>stat. HOL.Let (vfs_stat_set_nlink (stat, vfs_inode_get_nlink vnode)) (\<lambda>stat. HOL.Let (vfs_inode_get_size vnode) (\<lambda>size. HOL.Let (vfs_stat_set_size (stat, size)) (\<lambda>stat. HOL.Let (vfs_stat_set_atime (stat, vfs_inode_get_ctime vnode)) (\<lambda>stat. HOL.Let (vfs_stat_set_ctime (stat, vfs_inode_get_ctime vnode)) (\<lambda>stat. HOL.Let (vfs_stat_set_mtime (stat, vfs_inode_get_mtime vnode)) (\<lambda>stat. HOL.Let (vfs_stat_set_mode (stat, vfs_inode_get_mode vnode)) (\<lambda>stat. HOL.Let (vfs_stat_set_uid (stat, vfs_inode_get_uid vnode)) (\<lambda>stat. HOL.Let (vfs_stat_set_gid (stat, vfs_inode_get_gid vnode)) (\<lambda>stat. HOL.Let (vfs_stat_set_blksize (stat, (4096 :: 32 word))) (\<lambda>stat. HOL.Let (align64 (size, (4096 :: 64 word))) (\<lambda>size. HOL.Let (HOL.If (vmode_is_dir (vfs_inode_get_mode vnode)) (0 :: 64 word) (checked_div size (512 :: 64 word))) (\<lambda>blocks. HOL.Let (vfs_stat_set_blocks (stat, blocks)) (\<lambda>stat. FsopGetattrR.make ex fs_st stat))))))))))))))))))"

definition
  truncate_deletion_obj :: " FsopTruncateP\<^sub>T \<Rightarrow>  FsopVfsInodeP\<^sub>T \<times> (32 word, (unit,  Obj\<^sub>T) Option) R"
where
  "truncate_deletion_obj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopTruncateP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopTruncateP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopTruncateP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopTruncateP.newsize\<^sub>f) (\<lambda>(newsize,ds\<^sub>1). HOL.Let (vfs_inode_get_size vnode) (\<lambda>oldsize. HOL.Let (align64 (newsize, (4096 :: 64 word))) (\<lambda>newsize_aligned. HOL.If ((<) newsize_aligned oldsize) (HOL.Let (checked_shift shiftr newsize_aligned (12 :: 64 word)) (\<lambda>block. HOL.Let (obj_id_data_mk (vfs_inode_get_ino vnode, u64_to_u32 block)) (\<lambda>oid. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (obj_del_new (ex, oid)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>6). case_R (\<lambda>err. (FsopIgetRR.make ex fs_st vnode, (R.Error err :: (32 word, (unit,  Obj\<^sub>T) Option) R))) (\<lambda>obj. (FsopIgetRR.make ex fs_st vnode, (R.Success (Option.Some obj :: (unit,  Obj\<^sub>T) Option) :: (32 word, (unit,  Obj\<^sub>T) Option) R))) r))))) (FsopIgetRR.make ex fs_st vnode, (R.Success (Option.None () :: (unit,  Obj\<^sub>T) Option) :: (32 word, (unit,  Obj\<^sub>T) Option) R))))))))"

definition
  fsop_test_is_mount :: " FsState'Taken\<^sub>T \<times>  FsState'Taken\<^sub>T \<Rightarrow> bool"
where
  "fsop_test_is_mount ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(fs_st1,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P2_p2\<^sub>f) (\<lambda>(fs_st2,ds\<^sub>2). (=) (wubi_vol_cdev (MountState.vol\<^sub>f (FsState.mount_st\<^sub>f fs_st1))) (wubi_vol_cdev (MountState.vol\<^sub>f (FsState.mount_st\<^sub>f fs_st2)))))"

definition
  mount_read_super :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<Rightarrow> ( SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "mount_read_super ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P3_p3\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.rbuf\<^sub>f) (\<lambda>(rbuf,ostore_st). Let\<^sub>d\<^sub>s (wbuf_read_leb (ex, mount_st, OstoreState.ubi_vol\<^sub>f ostore_st, rbuf, (0 :: 32 word))) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(rbuf,ds\<^sub>1\<^sub>0). case_R (\<lambda>err. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>2. ((ex, mount_st, OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st), (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>1\<^sub>2. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>2 (\<lambda>ds\<^sub>1\<^sub>3. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>4. Let\<^sub>d\<^sub>s (deserialise_Obj_crc (ex, rbuf, (0 :: 32 word))) (\<lambda>ds\<^sub>1\<^sub>5. case_R (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>9). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>0. ((ex, mount_st, OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st), (R.Error err :: (32 word, unit) R)))))) (\<lambda>ds\<^sub>1\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>2\<^sub>1). HOL.Let (OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st) (\<lambda>ostore_st. HOL.Let (checked_div (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) (24 :: 32 word)) (\<lambda>max_nb_trans. Let\<^sub>d\<^sub>s (seq32 (Seq32Param.make (0 :: 32 word) ((+) max_nb_trans (1 :: 32 word)) (1 :: 32 word) read_super_loop (ex, obj, offs) (mount_st, OstoreState.rbuf\<^sub>f ostore_st))) (\<lambda>ds\<^sub>2\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>3,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>2\<^sub>8). case_LoopResult (\<lambda>ds\<^sub>3\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>1 (\<lambda>ds\<^sub>3\<^sub>2. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>3\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.ounion\<^sub>f) (\<lambda>(ounion,obj). Let\<^sub>d\<^sub>s (print_ObjHeader obj) (\<lambda>ds\<^sub>3\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>4 (\<lambda>ds\<^sub>3\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.offs\<^sub>f) (\<lambda>(offs,obj). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.crc\<^sub>f) (\<lambda>(crc,ds\<^sub>3\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 Obj.magic\<^sub>f) (\<lambda>(magic,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 Obj.sqnum\<^sub>f) (\<lambda>(sqnum,ds\<^sub>3\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>8 Obj.len\<^sub>f) (\<lambda>(len,ds\<^sub>3\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>9 Obj.trans\<^sub>f) (\<lambda>(trans,ds\<^sub>4\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>0 Obj.otype\<^sub>f) (\<lambda>(otype,obj). HOL.Let (freeObj (ex, obj)) (\<lambda>ex. Let\<^sub>d\<^sub>s (extract_super_from_union (ex, ounion)) (\<lambda>ds\<^sub>4\<^sub>1. case_R (\<lambda>ex. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4\<^sub>3. ((ex, mount_st, ostore_st), (R.Error (22 :: 32 word) :: (32 word, unit) R)))) (\<lambda>ds\<^sub>4\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>4 P2_p2\<^sub>f) (\<lambda>(super',ds\<^sub>4\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t mount_st MountState.super\<^sub>f) (\<lambda>(super,ds\<^sub>4\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>6 MountState.super_offs\<^sub>f) (\<lambda>(ds\<^sub>4\<^sub>7,mount_st). Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>7 (\<lambda>ds\<^sub>4\<^sub>8. HOL.Let (deep_freeObjSuper (ex, super)) (\<lambda>ex. HOL.Let (HOL.If ((=) offs (ObjSuper.eb_size\<^sub>f super')) (0 :: 32 word) offs) (\<lambda>super_offs. Let\<^sub>d\<^sub>s (print_ObjSuper super') (\<lambda>ds\<^sub>4\<^sub>9. Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>9 (\<lambda>ds\<^sub>5\<^sub>0. HOL.Let (MountState.super_offs\<^sub>f_update (\<lambda>_. super_offs) (MountState.super\<^sub>f_update (\<lambda>_. super') mount_st)) (\<lambda>mount_st. HOL.Let (OstoreState.next_inum\<^sub>f_update (\<lambda>_. (+) (ObjSuper.last_inum\<^sub>f (MountState.super\<^sub>f mount_st)) (1 :: 32 word)) (OstoreState.next_sqnum\<^sub>f_update (\<lambda>_. ObjSuper.next_sqnum\<^sub>f (MountState.super\<^sub>f mount_st)) ostore_st)) (\<lambda>ostore_st. ((ex, mount_st, ostore_st), (R.Success () :: (32 word, unit) R)))))))))))))) ds\<^sub>4\<^sub>1))))))))))))))) (\<lambda>ds\<^sub>2\<^sub>9. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>9 (\<lambda>ds\<^sub>3\<^sub>1. Let\<^sub>d\<^sub>s (cogent_assert False) (\<lambda>ds\<^sub>3\<^sub>2. HOL.Let (deep_freeObj (ex, obj)) (\<lambda>ex. ((ex, mount_st, ostore_st), (R.Error (22 :: 32 word) :: (32 word, unit) R)))))) r)))))))))))) ds\<^sub>1\<^sub>5)))) r)))))))))"

definition
  ostore_alloc_inode :: " OstoreState\<^sub>T \<Rightarrow>  OstoreState\<^sub>T \<times> (32 word, 32 word) R"
where
  "ostore_alloc_inode ds\<^sub>0 \<equiv> HOL.Let ds\<^sub>0 (\<lambda>ostore_st. HOL.Let (OstoreState.next_inum\<^sub>f ostore_st) (\<lambda>inum. HOL.If ((<) inum (4294967295 :: 32 word)) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.next_inum\<^sub>f) (\<lambda>(next_inum,ostore_st). HOL.Let ((+) next_inum (1 :: 32 word)) (\<lambda>next_inum. (OstoreState.next_inum\<^sub>f_update (\<lambda>_. next_inum) ostore_st, (R.Success inum :: (32 word, 32 word) R))))) (ostore_st, (R.Error (23 :: 32 word) :: (32 word, 32 word) R))))"

definition
  init_vnode :: " SysState \<times>  OstoreState\<^sub>T \<times>  VfsInode\<^sub>T \<times>  VfsInode\<^sub>T \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T \<times>  VfsInode\<^sub>T) \<times> (32 word, unit) R"
where
  "init_vnode ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P5_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p3\<^sub>f) (\<lambda>(vdir,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p4\<^sub>f) (\<lambda>(vnode,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p5\<^sub>f) (\<lambda>(mode,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_alloc_inode ostore_st) P2_p1\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>7). case_R (\<lambda>err. ((ex, ostore_st, vnode), (R.Error err :: (32 word, unit) R))) (\<lambda>v_ino. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. HOL.Let (VfsInode.fs\<^sub>f_update (\<lambda>_. FsInode.make (0 :: 32 word)) vnode) (\<lambda>vnode. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (vnode_init_perm (ex, vdir, vnode, mode)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(vnode,ds\<^sub>1\<^sub>1). HOL.Let (0 :: 32 word) (\<lambda>v_flags. HOL.Let ((OR) v_flags (0 :: 32 word)) (\<lambda>v_flags. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>1\<^sub>3). HOL.Let (1 :: 32 word) (\<lambda>v_nlink. HOL.Let (0 :: 64 word) (\<lambda>v_size. HOL.Let (vfs_inode_set_ino (vnode, v_ino)) (\<lambda>vnode. HOL.Let (vfs_inode_set_flags (vnode, v_flags)) (\<lambda>vnode. HOL.Let (vfs_inode_set_ctime (vnode, time)) (\<lambda>vnode. HOL.Let (vfs_inode_set_mtime (vnode, time)) (\<lambda>vnode. HOL.Let (vfs_inode_set_nlink (vnode, v_nlink)) (\<lambda>vnode. HOL.Let (vfs_inode_set_size (vnode, v_size)) (\<lambda>vnode. ((ex, ostore_st, vnode), (R.Success () :: (32 word, unit) R))))))))))))))))))) r)))))))"

definition
  ostore_new_wbuf :: " MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 32 word \<Rightarrow>  OstoreState\<^sub>T \<times> (32 word, unit) R"
where
  "ostore_new_wbuf ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P3_p3\<^sub>f) (\<lambda>(osw_flags,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.fsm_st\<^sub>f) (\<lambda>(fsm_st,ostore_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsm_alloc_eb (mount_st, fsm_st, osw_flags)) P2_p1\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>6). case_R (\<lambda>err. Let\<^sub>d\<^sub>s (cogent_assert False) (\<lambda>ds\<^sub>8. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. (OstoreState.fsm_st\<^sub>f_update (\<lambda>_. fsm_st) ostore_st, (R.Error err :: (32 word, unit) R))))) (\<lambda>wbuf_eb. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (OstoreState.fsm_st\<^sub>f_update (\<lambda>_. fsm_st) ostore_st) OstoreState.used\<^sub>f) (\<lambda>(used,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 OstoreState.sync_offs\<^sub>f) (\<lambda>(sync_offs,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 OstoreState.wbuf\<^sub>f) (\<lambda>(wbuf,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 OstoreState.wbuf_eb\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>3,ds\<^sub>1\<^sub>2). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>3 (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 OstoreState.summary\<^sub>f) (\<lambda>(summary,ostore_st). HOL.Let (reinit_summary summary) (\<lambda>summary. HOL.Let (OstoreState.summary\<^sub>f_update (\<lambda>_. summary) (OstoreState.wbuf_eb\<^sub>f_update (\<lambda>_. wbuf_eb) (OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) (OstoreState.sync_offs\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (OstoreState.used\<^sub>f_update (\<lambda>_. (0 :: 32 word)) ostore_st))))) (\<lambda>ostore_st. (ostore_st, (R.Success () :: (32 word, unit) R)))))))))))) r))))))"

definition
  ostore_next_obj_id :: " MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 64 word \<Rightarrow> (unit, 64 word) R"
where
  "ostore_next_obj_id ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(oid,ds\<^sub>3). Let\<^sub>d\<^sub>s (rbt_next (IndexState.addrs\<^sub>f (OstoreState.index_st\<^sub>f ostore_st), oid)) (\<lambda>ds\<^sub>4. case_R (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>5 (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. (R.Error () :: (unit, 64 word) R)))) (\<lambda>next_oid. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>7. HOL.If ((=) (inum_from_obj_id oid) (inum_from_obj_id next_oid)) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. (R.Success next_oid :: (unit, 64 word) R))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. (R.Error () :: (unit, 64 word) R))))) ds\<^sub>4))))"

definition
  check_dir_empty :: "( MountState\<^sub>T,  OstoreState\<^sub>T,  VfsInode\<^sub>T) T0 \<Rightarrow> bool"
where
  "check_dir_empty ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 T0.mount_st\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 T0.ostore_st\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 T0.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>1). HOL.Let (vmode_is_dir (vfs_inode_get_mode vdir)) (\<lambda>is_dir. HOL.If (HOL.Not is_dir) True (HOL.Let (obj_id_inode_mk (vfs_inode_get_ino vdir)) (\<lambda>id. Let\<^sub>d\<^sub>s (ostore_next_obj_id (mount_st, ostore_st, id)) (\<lambda>ds\<^sub>4. case_R (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>5 (\<lambda>ds\<^sub>7. True)) (\<lambda>nxt. HOL.Not (obj_id_is_dentarr nxt)) ds\<^sub>4)))))))"

definition
  ostore_read :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 64 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word,  Obj\<^sub>T) R"
where
  "ostore_read ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(oid,ds\<^sub>4). Let\<^sub>d\<^sub>s (index_get_addr (OstoreState.index_st\<^sub>f ostore_st, oid)) (\<lambda>ds\<^sub>5. case_R (\<lambda>err. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>7. ((ex, ostore_st), error err))) (\<lambda>addr. HOL.Let (OstoreState.wbuf_eb\<^sub>f ostore_st) (\<lambda>wbuf_eb. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (HOL.If ((=) (ObjAddr.ebnum\<^sub>f addr) wbuf_eb) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.wbuf\<^sub>f) (\<lambda>(wbuf,ostore_st). HOL.Let (Buffer.bound\<^sub>f_update (\<lambda>_. OstoreState.used\<^sub>f ostore_st) wbuf) (\<lambda>wbuf. Let\<^sub>d\<^sub>s (deserialise_Obj (ex, wbuf, ObjAddr.offs\<^sub>f addr)) (\<lambda>ds\<^sub>8. case_R (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (Buffer.bound\<^sub>f_update (\<lambda>_. ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) wbuf) (\<lambda>wbuf. ((ex, OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) ostore_st), error e)))))) (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p3\<^sub>f) (\<lambda>(sz,ds\<^sub>1\<^sub>4). HOL.Let (Buffer.bound\<^sub>f_update (\<lambda>_. ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) wbuf) (\<lambda>wbuf. ((ex, OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) ostore_st), success obj)))))) ds\<^sub>8)))) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.rbuf\<^sub>f) (\<lambda>(rbuf,ostore_st). Let\<^sub>d\<^sub>s (read_obj_pages_in_buf (ex, mount_st, OstoreState.ubi_vol\<^sub>f ostore_st, rbuf, addr)) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>9,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(rbuf,ds\<^sub>1\<^sub>3). case_R (\<lambda>e. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>5. ((ex, OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st), error e))) (\<lambda>ds\<^sub>1\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>5 (\<lambda>ds\<^sub>1\<^sub>6. Let\<^sub>d\<^sub>s (deserialise_Obj (ex, rbuf, ObjAddr.offs\<^sub>f addr)) (\<lambda>ds\<^sub>1\<^sub>7. case_R (\<lambda>ds\<^sub>1\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p1\<^sub>f) (\<lambda>(e,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>2. ((ex, OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st), error e))))) (\<lambda>ds\<^sub>2\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P3_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P3_p3\<^sub>f) (\<lambda>(sz,ds\<^sub>2\<^sub>3). ((ex, OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st), success obj))))) ds\<^sub>1\<^sub>7))) r)))))))) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>1). case_R (\<lambda>e. ((ex, ostore_st), (R.Error e :: (32 word,  Obj\<^sub>T) R))) (\<lambda>obj. HOL.Let (get_obj_oid obj) (\<lambda>oid'. HOL.If ((=) oid oid') ((ex, ostore_st), (R.Success obj :: (32 word,  Obj\<^sub>T) R)) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>3. Let\<^sub>d\<^sub>s (cogent_assert False) (\<lambda>ds\<^sub>1\<^sub>4. ((deep_freeObj (ex, obj), ostore_st), (R.Error (30 :: 32 word) :: (32 word,  Obj\<^sub>T) R))))))) r)))))) ds\<^sub>5)))))"

definition
  dentarr_read_and_del :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  VfsInode\<^sub>T \<times> 8 word WordArray \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word, 64 word \<times>  Obj\<^sub>T) R"
where
  "dentarr_read_and_del ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p4\<^sub>f) (\<lambda>(vdir,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p5\<^sub>f) (\<lambda>(name,ds\<^sub>5). HOL.Let (obj_id_dentarr_mk (vfs_inode_get_ino vdir, name)) (\<lambda>oid. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_read (ex, mount_st, ostore_st, oid)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>0). case_R (\<lambda>e. ((ex, ostore_st), (R.Error e :: (32 word, 64 word \<times>  Obj\<^sub>T) R))) (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 Obj.ounion\<^sub>f) (\<lambda>(ounion,dentarr_obj). Let\<^sub>d\<^sub>s (extract_dentarr_from_union (ex, ounion)) (\<lambda>ds\<^sub>1\<^sub>3. case_R (\<lambda>ex. Let\<^sub>d\<^sub>s (cogent_assert False) (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (freeObj (ex, dentarr_obj)) (\<lambda>ex. ((ex, ostore_st), (R.Error (22 :: 32 word) :: (32 word, 64 word \<times>  Obj\<^sub>T) R))))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_del_dentry (ex, dentarr, name)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_del_calculate_sz_change (ex, dentarr_obj, dentarr)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>0,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p2\<^sub>f) (\<lambda>(dentarr_obj,ds\<^sub>2\<^sub>4). case_R (\<lambda>e. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t dentarr_obj Obj.ounion\<^sub>f) (\<lambda>(ounion,dentarr_obj). HOL.Let (deep_freeObjUnion (ex, ounion)) (\<lambda>ex. HOL.Let (freeObj (ex, dentarr_obj)) (\<lambda>ex. ((ex, ostore_st), (R.Error e :: (32 word, 64 word \<times>  Obj\<^sub>T) R))))))) (\<lambda>sz_change. Let\<^sub>d\<^sub>s (safe_sub64 (vfs_inode_get_size vdir, (ucast sz_change :: 64 word))) (\<lambda>ds\<^sub>2\<^sub>6. case_R (\<lambda>ds\<^sub>2\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>8 (\<lambda>ds\<^sub>2\<^sub>9. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>3\<^sub>0. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. ((ex, ostore_st), (R.Error (75 :: 32 word) :: (32 word, 64 word \<times>  Obj\<^sub>T) R)))))) (\<lambda>new_v_size. ((ex, ostore_st), (R.Success (new_v_size, dentarr_obj) :: (32 word, 64 word \<times>  Obj\<^sub>T) R))) ds\<^sub>2\<^sub>6)) r))))))))) ds\<^sub>1\<^sub>3))) r))))))))))"

definition
  fsop_iget :: " FsopIgetP\<^sub>T \<Rightarrow>  FsopVfsInodeP\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_iget ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopIgetP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopIgetP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopIgetP.inum\<^sub>f) (\<lambda>(inum,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopIgetP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1). HOL.Let (obj_id_inode_mk inum) (\<lambda>oid. Let\<^sub>d\<^sub>s (ostore_read (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, oid)) (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>1). case_R (\<lambda>e. (FsopIgetRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vnode, (R.Error e :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 Obj.ounion\<^sub>f) (\<lambda>(ounion,obj). HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. Let\<^sub>d\<^sub>s (extract_inode_from_union (ex, ounion)) (\<lambda>ds\<^sub>1\<^sub>4. case_R (\<lambda>ex. Let\<^sub>d\<^sub>s (cogent_assert False) (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (freeObj (ex, obj)) (\<lambda>ex. (FsopIgetRR.make ex fs_st vnode, (R.Error (22 :: 32 word) :: (32 word, unit) R))))) (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(oi,ds\<^sub>1\<^sub>8). HOL.Let (vfs_inode_set_ino (vnode, inum_from_obj_id (ObjInode.id\<^sub>f oi))) (\<lambda>vnode. HOL.Let (vfs_inode_set_nlink (vnode, ObjInode.nlink\<^sub>f oi)) (\<lambda>vnode. HOL.Let (vfs_inode_set_size (vnode, ObjInode.size\<^sub>f oi)) (\<lambda>vnode. HOL.Let (vfs_inode_set_mtime (vnode, u64_to_TimeSpec (ObjInode.mtime_sec\<^sub>f oi))) (\<lambda>vnode. HOL.Let (vfs_inode_set_ctime (vnode, u64_to_TimeSpec (ObjInode.ctime_sec\<^sub>f oi))) (\<lambda>vnode. HOL.Let (vfs_inode_set_uid (vnode, ObjInode.uid\<^sub>f oi)) (\<lambda>vnode. HOL.Let (vfs_inode_set_gid (vnode, ObjInode.gid\<^sub>f oi)) (\<lambda>vnode. HOL.Let (vfs_inode_set_mode (vnode, ObjInode.mode\<^sub>f oi)) (\<lambda>vnode. HOL.Let (vfs_inode_set_flags (vnode, ObjInode.flags\<^sub>f oi)) (\<lambda>vnode. HOL.Let (deep_freeObj (ex, Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjInode oi ::  ObjUnion\<^sub>T)) obj)) (\<lambda>ex. (FsopIgetRR.make ex fs_st vnode, (R.Success () :: (32 word, unit) R))))))))))))))) ds\<^sub>1\<^sub>4)))) r)))))))))))"

definition
  fsop_lookup :: " FsopLookupP\<^sub>T \<Rightarrow>  FsopLookupRR\<^sub>T \<times> (32 word, 32 word) R"
where
  "fsop_lookup ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopLookupP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopLookupP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.mount_st\<^sub>f) (\<lambda>(mount_st,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopLookupP.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopLookupP.name\<^sub>f) (\<lambda>(name,ds\<^sub>1). HOL.If ((>) (wordarray_length name) ((+) (255 :: 32 word) (1 :: 32 word))) (FsopLookupRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) fs_st)) vdir, (R.Error (36 :: 32 word) :: (32 word, 32 word) R)) (HOL.Let (vfs_inode_get_ino vdir) (\<lambda>dir_inum. HOL.Let (obj_id_dentarr_mk (dir_inum, name)) (\<lambda>oid. Let\<^sub>d\<^sub>s (ostore_read (ex, mount_st, ostore_st, oid)) (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>2). case_R (\<lambda>err. (FsopLookupRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) fs_st)) vdir, (R.Error err :: (32 word, 32 word) R))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 Obj.crc\<^sub>f) (\<lambda>(crc,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 Obj.magic\<^sub>f) (\<lambda>(magic,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 Obj.sqnum\<^sub>f) (\<lambda>(sqnum,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 Obj.offs\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 Obj.len\<^sub>f) (\<lambda>(len,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 Obj.trans\<^sub>f) (\<lambda>(trans,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 Obj.otype\<^sub>f) (\<lambda>(otype,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 Obj.ounion\<^sub>f) (\<lambda>(ounion,obj). HOL.Let (freeObj (ex, obj)) (\<lambda>ex. Let\<^sub>d\<^sub>s (extract_dentarr_from_union (ex, ounion)) (\<lambda>ds\<^sub>2\<^sub>2. case_R (\<lambda>ex. (FsopLookupRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) fs_st)) vdir, (R.Error (30 :: 32 word) :: (32 word, 32 word) R))) (\<lambda>ds\<^sub>2\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>2\<^sub>6). HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) fs_st)) (\<lambda>fs_st. Let\<^sub>d\<^sub>s (array_fold (ArrayFoldP.make (ObjDentarr.entries\<^sub>f dentarr) find_name () name)) (\<lambda>ds\<^sub>2\<^sub>7. case_LoopResult (\<lambda>inum. HOL.Let (deep_freeObjDentarr (ex, dentarr)) (\<lambda>ex. (FsopLookupRR.make ex fs_st vdir, (R.Success inum :: (32 word, 32 word) R)))) (\<lambda>ds\<^sub>2\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>8 (\<lambda>ds\<^sub>3\<^sub>0. HOL.Let (deep_freeObjDentarr (ex, dentarr)) (\<lambda>ex. (FsopLookupRR.make ex fs_st vdir, (R.Error (2 :: 32 word) :: (32 word, 32 word) R))))) ds\<^sub>2\<^sub>7))))) ds\<^sub>2\<^sub>2))))))))))) r))))))))))))))"

definition
  read_block :: " SysState \<times>  FsState'Taken\<^sub>T \<times>  VfsInode\<^sub>T \<times>  Buffer\<^sub>T \<times> 64 word \<Rightarrow> ( SysState \<times>  FsState'Taken\<^sub>T \<times>  Buffer\<^sub>T) \<times> (32 word, unit) R"
where
  "read_block ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p3\<^sub>f) (\<lambda>(vnode,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p4\<^sub>f) (\<lambda>(buf,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P5_p5\<^sub>f) (\<lambda>(block,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (obj_id_data_mk (vfs_inode_get_ino vnode, u64_to_u32 block)) (\<lambda>oid. Let\<^sub>d\<^sub>s (ostore_read (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, oid)) (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>2). HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. case_R (\<lambda>e. HOL.If ((=) e (2 :: 32 word)) (HOL.Let (buf_memset (buf, (0 :: 32 word), (4096 :: 32 word), (0 :: 8 word))) (\<lambda>buf. ((ex, fs_st, buf), (R.Success () :: (32 word, unit) R)))) ((ex, fs_st, buf), (R.Error e :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 Obj.ounion\<^sub>f) (\<lambda>(ounion,obj). Let\<^sub>d\<^sub>s (extract_data_from_union (ex, ounion)) (\<lambda>ds\<^sub>1\<^sub>5. case_R (\<lambda>ex. Let\<^sub>d\<^sub>s (cogent_assert False) (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (freeObj (ex, obj)) (\<lambda>ex. ((ex, fs_st, buf), (R.Error (22 :: 32 word) :: (32 word, unit) R))))) (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(od,ds\<^sub>1\<^sub>9). HOL.Let (freeObj (ex, obj)) (\<lambda>ex. HOL.Let (wordarray_length (ObjData.odata\<^sub>f od)) (\<lambda>size. HOL.If ((>) size (4096 :: 32 word)) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>0. HOL.Let (deep_freeObjData (ex, od)) (\<lambda>ex. ((ex, fs_st, buf), (R.Error (22 :: 32 word) :: (32 word, unit) R))))) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t buf Buffer.data\<^sub>f) (\<lambda>(data,buf). HOL.Let (wordarray_copy (data, ObjData.odata\<^sub>f od, (0 :: 32 word), (0 :: 32 word), size)) (\<lambda>data. HOL.Let (Buffer.data\<^sub>f_update (\<lambda>_. data) buf) (\<lambda>buf. HOL.Let (buf_memset (buf, size, (-) (4096 :: 32 word) size, (0 :: 8 word))) (\<lambda>buf. HOL.Let (deep_freeObjData (ex, od)) (\<lambda>ex. ((ex, fs_st, buf), (R.Success () :: (32 word, unit) R))))))))))))) ds\<^sub>1\<^sub>5))) r)))))))))))))"

definition
  fsop_follow_link :: " FsopFollowLinkP\<^sub>T \<Rightarrow>  FsopFollowLinkP\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_follow_link ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopFollowLinkP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopFollowLinkP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopFollowLinkP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopFollowLinkP.path\<^sub>f) (\<lambda>(path,ds\<^sub>1). Let\<^sub>d\<^sub>s (read_block (ex, fs_st, vnode, path, (0 :: 64 word))) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p2\<^sub>f) (\<lambda>(fs_st,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P3_p3\<^sub>f) (\<lambda>(path,ds\<^sub>1\<^sub>1). case_R (\<lambda>err. (FsopFollowLinkP.make ex fs_st vnode path, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>3 (\<lambda>ds\<^sub>1\<^sub>4. (FsopFollowLinkP.make ex fs_st vnode path, (R.Success () :: (32 word, unit) R)))) r))))))))))"

definition
  fsop_readpage :: " FsopReadPageP\<^sub>T \<Rightarrow>  FsopWriteRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_readpage ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopReadPageP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopReadPageP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopReadPageP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopReadPageP.block\<^sub>f) (\<lambda>(block,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopReadPageP.addr\<^sub>f) (\<lambda>(addr,ds\<^sub>1). HOL.Let (vfs_inode_get_size vnode) (\<lambda>size. HOL.Let (checked_shift shiftr size (12 :: 64 word)) (\<lambda>limit. HOL.If ((>) block limit) (HOL.Let (buf_memset (addr, (0 :: 32 word), (4096 :: 32 word), (0 :: 8 word))) (\<lambda>addr. (FsopWriteRR.make ex fs_st vnode addr, (R.Error (2 :: 32 word) :: (32 word, unit) R)))) (HOL.If ((=) block limit \<and> (=) (checked_mod size (4096 :: 64 word)) (0 :: 64 word)) (FsopWriteRR.make ex fs_st vnode addr, (R.Success () :: (32 word, unit) R)) (Let\<^sub>d\<^sub>s (read_block (ex, fs_st, vnode, addr, block)) (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P3_p2\<^sub>f) (\<lambda>(fs_st,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P3_p3\<^sub>f) (\<lambda>(addr,ds\<^sub>1\<^sub>2). (FsopWriteRR.make ex fs_st vnode addr, r))))))))))))))))"

definition
  fsop_write_begin :: " FsopWriteP\<^sub>T \<Rightarrow>  FsopWriteRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_write_begin ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopWriteP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopWriteP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopWriteP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopWriteP.pos\<^sub>f) (\<lambda>(pos,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopWriteP.len\<^sub>f) (\<lambda>(len,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopWriteP.addr\<^sub>f) (\<lambda>(addr,ds\<^sub>1). HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.If is_ro (FsopWriteRR.make ex fs_st vnode addr, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsop_readpage (FsopReadPageP.make ex fs_st vnode (checked_shift shiftr pos (12 :: 64 word)) addr)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 FsopWriteRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 FsopWriteRR.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 FsopWriteRR.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 FsopWriteRR.addr\<^sub>f) (\<lambda>(addr,ds\<^sub>1\<^sub>0). case_R (\<lambda>err. HOL.If ((=) err (2 :: 32 word)) (FsopWriteRR.make ex fs_st vnode addr, (R.Success () :: (32 word, unit) R)) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>5. (FsopWriteRR.make ex fs_st vnode addr, (R.Error err :: (32 word, unit) R))))) (\<lambda>ds\<^sub>1\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>5 (\<lambda>ds\<^sub>1\<^sub>6. (FsopWriteRR.make ex fs_st vnode addr, (R.Success () :: (32 word, unit) R)))) r))))))))))))))"

definition
  truncate_last_block :: " FsopTruncateP\<^sub>T \<Rightarrow>  FsopVfsInodeP\<^sub>T \<times> (32 word, (unit,  Obj\<^sub>T) Option) R"
where
  "truncate_last_block ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopTruncateP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopTruncateP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopTruncateP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopTruncateP.newsize\<^sub>f) (\<lambda>(newsize,ds\<^sub>1). HOL.Let (vfs_inode_get_size vnode) (\<lambda>oldsize. HOL.Let (align64 (newsize, (4096 :: 64 word))) (\<lambda>newsize_aligned. HOL.If ((~=) newsize newsize_aligned \<and> (<) newsize oldsize) (HOL.Let (checked_shift shiftr newsize (12 :: 64 word)) (\<lambda>block. HOL.Let (obj_id_data_mk (vfs_inode_get_ino vnode, u64_to_u32 block)) (\<lambda>oid. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). Let\<^sub>d\<^sub>s (ostore_read (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, oid)) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>0). case_R (\<lambda>err. (FsopIgetRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vnode, (R.Error err :: (32 word, (unit,  Obj\<^sub>T) Option) R))) (\<lambda>obj. HOL.Let (u64_to_u32 ((-) newsize ((-) newsize_aligned (4096 :: 64 word)))) (\<lambda>szdata. HOL.Let ((+) ((+) (24 :: 32 word) (8 :: 32 word)) szdata) (\<lambda>len. HOL.Let (Obj.len\<^sub>f_update (\<lambda>_. len) obj) (\<lambda>obj. (FsopIgetRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vnode, (R.Success (Option.Some obj :: (unit,  Obj\<^sub>T) Option) :: (32 word, (unit,  Obj\<^sub>T) Option) R)))))) r))))))))) (FsopIgetRR.make ex fs_st vnode, (R.Success (Option.None () :: (unit,  Obj\<^sub>T) Option) :: (32 word, (unit,  Obj\<^sub>T) Option) R))))))))"

definition
  ostore_read_sum_extra_pages :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 32 word \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "ostore_read_sum_extra_pages ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p3\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p4\<^sub>f) (\<lambda>(ebnum,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P5_p5\<^sub>f) (\<lambda>(sum_offs,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.rbuf\<^sub>f) (\<lambda>(rbuf,ostore_st). HOL.Let (ObjSuper.io_size\<^sub>f (MountState.super\<^sub>f mount_st)) (\<lambda>io_size. HOL.Let ((-) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) io_size) (\<lambda>offs. HOL.If ((>) sum_offs (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) \<or> (<) sum_offs io_size) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>7. ((ex, OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st), (R.Error (22 :: 32 word) :: (32 word, unit) R)))) (HOL.If ((<) sum_offs offs) (HOL.Let ((-) sum_offs (checked_mod sum_offs io_size)) (\<lambda>offs. HOL.Let ((-) (checked_div ((-) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) offs) io_size) (1 :: 32 word)) (\<lambda>nb_pages. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>0. Let\<^sub>d\<^sub>s (seq32 (Seq32Param.make (0 :: 32 word) nb_pages (1 :: 32 word) ostore_read_sum_f (ex, rbuf, offs) (ebnum, io_size, OstoreState.ubi_vol\<^sub>f ostore_st))) (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>2,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P3_p2\<^sub>f) (\<lambda>(rbuf,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p3\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>5,ds\<^sub>1\<^sub>8). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>5 (\<lambda>ds\<^sub>1\<^sub>9. case_LoopResult (\<lambda>e. ((ex, OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st), (R.Error e :: (32 word, unit) R))) (\<lambda>ds\<^sub>2\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>1 (\<lambda>ds\<^sub>2\<^sub>2. ((ex, OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st), (R.Success () :: (32 word, unit) R)))) r))))))))))))) ((ex, OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st), (R.Success () :: (32 word, unit) R)))))))))))"

definition
  ostore_read_sum :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word, 32 word) R"
where
  "ostore_read_sum ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p3\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P4_p4\<^sub>f) (\<lambda>(ebnum,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.rbuf\<^sub>f) (\<lambda>(rbuf,ostore_st). HOL.Let ((-) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) (ObjSuper.io_size\<^sub>f (MountState.super\<^sub>f mount_st))) (\<lambda>offs. HOL.Let (ObjSuper.io_size\<^sub>f (MountState.super\<^sub>f mount_st)) (\<lambda>io_size. Let\<^sub>d\<^sub>s (wubi_leb_read (WubiLebReadP.make ex (OstoreState.ubi_vol\<^sub>f ostore_st) ebnum rbuf offs io_size)) (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(rbuf,ds\<^sub>1\<^sub>1). case_R (\<lambda>e. ((ex, OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st), (R.Error e :: (32 word, 32 word) R))) (\<lambda>ds\<^sub>1\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>3 (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (deserialise_le32 (rbuf, (-) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) (4 :: 32 word))) (\<lambda>sum_offs. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>5. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>6. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_read_sum_extra_pages (ex, mount_st, OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st, ebnum, sum_offs)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>8,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>2). case_R (\<lambda>e. ((ex, ostore_st), (R.Error e :: (32 word, 32 word) R))) (\<lambda>ds\<^sub>2\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>4 (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.sum_obj\<^sub>f) (\<lambda>(sum_obj,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 OstoreState.summary\<^sub>f) (\<lambda>(summary,ostore_st). Let\<^sub>d\<^sub>s (deserialise_ObjSummary_crc (ex, OstoreState.rbuf\<^sub>f ostore_st, sum_offs, sum_obj, summary)) (\<lambda>ds\<^sub>2\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>8,ds\<^sub>2\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P3_p2\<^sub>f) (\<lambda>(sum_obj,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P3_p3\<^sub>f) (\<lambda>(summary,ds\<^sub>3\<^sub>3). HOL.Let (OstoreState.summary\<^sub>f_update (\<lambda>_. summary) (OstoreState.sum_obj\<^sub>f_update (\<lambda>_. sum_obj) ostore_st)) (\<lambda>ostore_st. case_R (\<lambda>e. ((ex, ostore_st), (R.Error e :: (32 word, 32 word) R))) (\<lambda>ds\<^sub>3\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>5 (\<lambda>ds\<^sub>3\<^sub>6. ((ex, ostore_st), (R.Success sum_offs :: (32 word, 32 word) R)))) r))))))))))) r)))))))))) r))))))))))))"

definition
  ostore_sync_summary_if_eb_new :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "ostore_sync_summary_if_eb_new ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(osw_flags,ds\<^sub>4). HOL.Let (OstoreState.used\<^sub>f ostore_st) (\<lambda>used. HOL.Let (OstoreState.next_sqnum\<^sub>f ostore_st) (\<lambda>sqnum. HOL.If (HOL.Not (MountState.no_summary\<^sub>f mount_st) \<and> is_set (osw_flags, (4 :: 32 word)) \<and> (~=) used (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st))) (HOL.If ((<) ((+) sqnum (1 :: 64 word)) sqnum) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. ((ex, ostore_st), (R.Error (75 :: 32 word) :: (32 word, unit) R)))) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.wbuf\<^sub>f) (\<lambda>(wbuf,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 OstoreState.sum_obj\<^sub>f) (\<lambda>(sum_obj,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 OstoreState.used\<^sub>f) (\<lambda>(used,ostore_st). HOL.Let (serialise_size_summary_Obj_with_extra (OstoreState.summary\<^sub>f ostore_st, (0 :: 32 word))) (\<lambda>len. HOL.Let (Obj.len\<^sub>f_update (\<lambda>_. len) (Obj.trans\<^sub>f_update (\<lambda>_. (2 :: 8 word)) (Obj.offs\<^sub>f_update (\<lambda>_. used) (Obj.sqnum\<^sub>f_update (\<lambda>_. sqnum) sum_obj)))) (\<lambda>sum_obj. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.summary\<^sub>f) (\<lambda>(summary,ostore_st). HOL.Let (ObjSummary.sum_offs\<^sub>f_update (\<lambda>_. used) summary) (\<lambda>summary. Let\<^sub>d\<^sub>s (serialise_ObjSummary_crc (wbuf, used, sum_obj, summary)) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P3_p1\<^sub>f) (\<lambda>(sum_obj,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p2\<^sub>f) (\<lambda>(wbuf,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P3_p3\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>1). Let\<^sub>d\<^sub>s (cogent_assert ((=) ((+) used len) offs)) (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (OstoreState.summary\<^sub>f_update (\<lambda>_. summary) (OstoreState.sum_obj\<^sub>f_update (\<lambda>_. sum_obj) (OstoreState.used\<^sub>f_update (\<lambda>_. (+) used len) (OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) (OstoreState.next_sqnum\<^sub>f_update (\<lambda>_. (+) sqnum (1 :: 64 word)) ostore_st))))) (\<lambda>ostore_st. ((ex, ostore_st), (R.Success () :: (32 word, unit) R))))))))))))))))) ((ex, ostore_st), (R.Success () :: (32 word, unit) R))))))))"

definition
  ostore_write_buf :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 32 word \<times> 32 word \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "ostore_write_buf ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P6_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P6_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P6_p3\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P6_p4\<^sub>f) (\<lambda>(sync_offs,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P6_p5\<^sub>f) (\<lambda>(nb_bytes,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P6_p6\<^sub>f) (\<lambda>(osw_flags,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.ubi_vol\<^sub>f) (\<lambda>(ubi_vol,ostore_st). HOL.If ((>) nb_bytes (0 :: 32 word)) (Let\<^sub>d\<^sub>s (HOL.If (HOL.Not (is_set (osw_flags, (8 :: 32 word)))) (wubi_leb_write (WubiLebWriteP.make ex ubi_vol (OstoreState.wbuf_eb\<^sub>f ostore_st) (OstoreState.wbuf\<^sub>f ostore_st) sync_offs nb_bytes)) (wubi_leb_change (WubiLebChangeP.make ex ubi_vol (OstoreState.wbuf_eb\<^sub>f ostore_st) (OstoreState.wbuf\<^sub>f ostore_st) nb_bytes))) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>9,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ubi_vol,ds\<^sub>1\<^sub>3). ((ex, OstoreState.ubi_vol\<^sub>f_update (\<lambda>_. ubi_vol) ostore_st), r))))))) ((ex, OstoreState.ubi_vol\<^sub>f_update (\<lambda>_. ubi_vol) ostore_st), (R.Success () :: (32 word, unit) R)))))))))"

definition
  padding_to :: " MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 32 word \<Rightarrow> 32 word"
where
  "padding_to ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(osw_flags,ds\<^sub>3). HOL.If (is_set (osw_flags, (4 :: 32 word))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. HOL.If (HOL.Not (MountState.no_summary\<^sub>f mount_st) \<and> (~=) (OstoreState.used\<^sub>f ostore_st) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st))) ((-) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) (serialise_size_summary_Obj_with_extra (OstoreState.summary\<^sub>f ostore_st, (0 :: 32 word)))) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)))) (align32 (OstoreState.used\<^sub>f ostore_st, ObjSuper.io_size\<^sub>f (MountState.super\<^sub>f mount_st))))))"

definition
  proc_obj_sum :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  Obj\<^sub>T \<Rightarrow>  SysState \<times>  OstoreState\<^sub>T"
where
  "proc_obj_sum ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(obj,ds\<^sub>4). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>6. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. HOL.Let (get_obj_oid obj) (\<lambda>id. HOL.If ((=) id (18446744073709551615 :: 64 word)) (ex, ostore_st) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (Obj.sqnum\<^sub>f obj, Obj.otype\<^sub>f obj) P2_p1\<^sub>f) (\<lambda>(sqnum,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(otype,ds\<^sub>1\<^sub>1). Let\<^sub>d\<^sub>s (find_sum_entry (OstoreState.summary\<^sub>f ostore_st, id, sqnum, otype)) (\<lambda>ds\<^sub>1\<^sub>2. case_R (\<lambda>ds\<^sub>1\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>3 (\<lambda>ds\<^sub>1\<^sub>5. (ex, ostore_st))) (\<lambda>ds\<^sub>1\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p1\<^sub>f) (\<lambda>(idx_entry,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p2\<^sub>f) (\<lambda>(count,ds\<^sub>1\<^sub>7). HOL.Let (Obj.len\<^sub>f obj) (\<lambda>len. HOL.Let (HOL.If ((=) otype (3 :: 8 word)) (2147483648 :: 32 word) (0 :: 32 word)) (\<lambda>del_flags_and_offs. HOL.Let ((OR) del_flags_and_offs (Obj.offs\<^sub>f obj)) (\<lambda>del_flags_and_offs. HOL.Let (ObjSumEntry.make id sqnum len del_flags_and_offs ((+) count (1 :: 16 word))) (\<lambda>sum_entry. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.summary\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>8,ostore_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 ObjSummary.entries\<^sub>f) (\<lambda>(entries,summary). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (wordarray_modify (ArrayUseValueP.make entries idx_entry proc_obj_sum_f () sum_entry)) ArrA.arr\<^sub>f) (\<lambda>(entries,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 ArrA.acc\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>1,ds\<^sub>1\<^sub>9). Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>1 (\<lambda>ds\<^sub>2\<^sub>2. HOL.Let (ObjSummary.nb_sum_entry\<^sub>f summary) (\<lambda>nb_sum_entry. HOL.Let (HOL.If ((=) idx_entry nb_sum_entry) ((+) nb_sum_entry (1 :: 32 word)) nb_sum_entry) (\<lambda>nb_sum_entry. HOL.Let (ObjSummary.entries\<^sub>f_update (\<lambda>_. entries) (ObjSummary.nb_sum_entry\<^sub>f_update (\<lambda>_. nb_sum_entry) summary)) (\<lambda>summary. (ex, OstoreState.summary\<^sub>f_update (\<lambda>_. summary) ostore_st)))))))))))))))) ds\<^sub>1\<^sub>2))))))))))))))"

definition
  read_next_dentry :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  BilbyFsReaddirContext\<^sub>T \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T \<times>  BilbyFsReaddirContext\<^sub>T) \<times> (32 word, bool) R"
where
  "read_next_dentry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(rdctx,ds\<^sub>4). HOL.Let (BilbyFsReaddirContext.cur_dentry\<^sub>f rdctx) (\<lambda>cur_dentry. HOL.Let (array_nb_elem (ObjDentarr.entries\<^sub>f (BilbyFsReaddirContext.dentarr\<^sub>f rdctx))) (\<lambda>len_dentarr. HOL.Let (ObjDentarr.id\<^sub>f (BilbyFsReaddirContext.dentarr\<^sub>f rdctx)) (\<lambda>did. HOL.If ((>=) ((+) cur_dentry (1 :: 32 word)) len_dentarr) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s (ostore_next_obj_id (mount_st, ostore_st, ObjDentarr.id\<^sub>f (BilbyFsReaddirContext.dentarr\<^sub>f rdctx))) (\<lambda>ds\<^sub>6. case_R (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s ds\<^sub>7 (\<lambda>ds\<^sub>9. ((ex, ostore_st, rdctx), (R.Success True :: (32 word, bool) R)))) (\<lambda>nxt. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_read (ex, mount_st, ostore_st, nxt)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>9,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>3). case_R (\<lambda>err. ((ex, ostore_st, rdctx), (R.Error err :: (32 word, bool) R))) (\<lambda>ds\<^sub>1\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 Obj.crc\<^sub>f) (\<lambda>(crc,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 Obj.magic\<^sub>f) (\<lambda>(magic,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 Obj.sqnum\<^sub>f) (\<lambda>(sqnum,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 Obj.offs\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 Obj.len\<^sub>f) (\<lambda>(len,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 Obj.trans\<^sub>f) (\<lambda>(trans,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 Obj.otype\<^sub>f) (\<lambda>(otype,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 Obj.ounion\<^sub>f) (\<lambda>(ounion,obj). HOL.Let (freeObj (ex, obj)) (\<lambda>ex. Let\<^sub>d\<^sub>s (extract_dentarr_from_union (ex, ounion)) (\<lambda>ds\<^sub>2\<^sub>3. case_R (\<lambda>ex. ((ex, ostore_st, rdctx), (R.Error (30 :: 32 word) :: (32 word, bool) R))) (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t rdctx BilbyFsReaddirContext.dentarr\<^sub>f) (\<lambda>(dentarr',ds\<^sub>2\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 BilbyFsReaddirContext.cur_dentry\<^sub>f) (\<lambda>(cur_dentry,rdctx). HOL.Let (deep_freeObjDentarr (ex, dentarr')) (\<lambda>ex. HOL.Let (BilbyFsReaddirContext.cur_dentry\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (BilbyFsReaddirContext.dentarr\<^sub>f_update (\<lambda>_. dentarr) rdctx)) (\<lambda>rdctx. ((ex, ostore_st, rdctx), (R.Success False :: (32 word, bool) R))))))))) ds\<^sub>2\<^sub>3))))))))))) r))))) ds\<^sub>6))) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t rdctx BilbyFsReaddirContext.cur_dentry\<^sub>f) (\<lambda>(cur_dentry,rdctx). HOL.Let (BilbyFsReaddirContext.cur_dentry\<^sub>f_update (\<lambda>_. (+) cur_dentry (1 :: 32 word)) rdctx) (\<lambda>rdctx. ((ex, ostore_st, rdctx), (R.Success False :: (32 word, bool) R))))))))))))"

definition
  readdir_loop :: "( SysState \<times>  OstoreState\<^sub>T \<times>  VfsDirContext\<^sub>T \<times>  BilbyFsReaddirContext\<^sub>T,  MountState\<^sub>T, 64 word) Seq32_bodyParam \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T \<times>  VfsDirContext\<^sub>T \<times>  BilbyFsReaddirContext\<^sub>T) \<times> ((32 word, bool) R, unit) LoopResult"
where
  "readdir_loop ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 Seq32_bodyParam.acc\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P4_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P4_p3\<^sub>f) (\<lambda>(vctx,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P4_p4\<^sub>f) (\<lambda>(rdctx,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 Seq32_bodyParam.obsv\<^sub>f) (\<lambda>(mount_st,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 Seq32_bodyParam.idx\<^sub>f) (\<lambda>(idx,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (read_next_dentry (ex, mount_st, ostore_st, rdctx)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>0,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p3\<^sub>f) (\<lambda>(rdctx,ds\<^sub>1\<^sub>5). case_R (\<lambda>err. ((ex, ostore_st, vctx, rdctx), (LoopResult.Break (R.Error err :: (32 word, bool) R) :: ((32 word, bool) R, unit) LoopResult))) (\<lambda>no_more_dentry. HOL.If no_more_dentry (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t vctx VfsDirContext.pos\<^sub>f) (\<lambda>(pos,vctx). HOL.Let (VfsDirContext.pos\<^sub>f_update (\<lambda>_. (2 :: 64 word)) vctx) (\<lambda>vctx. ((ex, ostore_st, vctx, rdctx), (LoopResult.Break (R.Success no_more_dentry :: (32 word, bool) R) :: ((32 word, bool) R, unit) LoopResult)))))) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t vctx VfsDirContext.pos\<^sub>f) (\<lambda>(pos,vctx). HOL.Let (VfsDirContext.pos\<^sub>f_update (\<lambda>_. (+) pos (1 :: 64 word)) vctx) (\<lambda>vctx. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>8. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>9. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>0. Let\<^sub>d\<^sub>s (array_use_value (ArrayUseValueP.make (ObjDentarr.entries\<^sub>f (BilbyFsReaddirContext.dentarr\<^sub>f rdctx)) (BilbyFsReaddirContext.cur_dentry\<^sub>f rdctx) emit_dir (vctx, False) ())) (\<lambda>ds\<^sub>2\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p1\<^sub>f) (\<lambda>(vctx,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p2\<^sub>f) (\<lambda>(over,ds\<^sub>2\<^sub>3). HOL.If over (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>4. ((ex, ostore_st, vctx, rdctx), (LoopResult.Break (R.Success no_more_dentry :: (32 word, bool) R) :: ((32 word, bool) R, unit) LoopResult)))) ((ex, ostore_st, vctx, rdctx), (LoopResult.Iterate () :: ((32 word, bool) R, unit) LoopResult)))))))))))) r)))))))))))))"

definition
  fsop_readdir :: " ReadDirParams\<^sub>T \<times>  VfsInode\<^sub>T \<Rightarrow>  ReadDirParams\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_readdir ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P2_p2\<^sub>f) (\<lambda>(vdir,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 ReadDirParams.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 ReadDirParams.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 ReadDirParams.vctx\<^sub>f) (\<lambda>(vctx,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 ReadDirParams.opt_rdctx\<^sub>f) (\<lambda>(opt_rdctx,ds\<^sub>4). Let\<^sub>d\<^sub>s (get_rdctx (ex, opt_rdctx, vdir)) (\<lambda>ds\<^sub>8. case_R (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). (ReadDirParams.make ex fs_st vctx (Option.None () :: (unit,  BilbyFsReaddirContext\<^sub>T) Option), (R.Error err :: (32 word, unit) R))))) (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(rdctx,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (ObjDentarr.id\<^sub>f (BilbyFsReaddirContext.dentarr\<^sub>f rdctx)) (\<lambda>oid. Let\<^sub>d\<^sub>s (seq64 (Seq32Param.make oid (next_inode_id (obj_id_inode_mk (vfs_inode_get_ino vdir))) (1 :: 64 word) readdir_loop (ex, ostore_st, vctx, rdctx) (FsState.mount_st\<^sub>f fs_st))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>5,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P4_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P4_p3\<^sub>f) (\<lambda>(vctx,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P4_p4\<^sub>f) (\<lambda>(rdctx,ds\<^sub>2\<^sub>1). case_LoopResult (\<lambda>res. case_R (\<lambda>err. HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. (ReadDirParams.make ex fs_st vctx (Option.Some rdctx :: (unit,  BilbyFsReaddirContext\<^sub>T) Option), (R.Error err :: (32 word, unit) R)))) (\<lambda>no_more. HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. (ReadDirParams.make ex fs_st vctx (Option.Some rdctx :: (unit,  BilbyFsReaddirContext\<^sub>T) Option), (R.Success () :: (32 word, unit) R)))) res) (\<lambda>ds\<^sub>2\<^sub>2. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>2 (\<lambda>ds\<^sub>2\<^sub>4. Let\<^sub>d\<^sub>s (cogent_assert False) (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. (ReadDirParams.make ex fs_st vctx (Option.Some rdctx :: (unit,  BilbyFsReaddirContext\<^sub>T) Option), (R.Error (22 :: 32 word) :: (32 word, unit) R)))))) r)))))))))))) ds\<^sub>8)))))))"

definition
  read_or_create_dentarr :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 64 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word,  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> bool) R"
where
  "read_or_create_dentarr ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(oid,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_read (ex, mount_st, ostore_st, oid)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>5,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>9). case_R (\<lambda>e. HOL.If ((~=) e (2 :: 32 word)) ((ex, ostore_st), (R.Error e :: (32 word,  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> bool) R)) (Let\<^sub>d\<^sub>s (newObj ex) (\<lambda>ds\<^sub>1\<^sub>1. case_R (\<lambda>ex. ((ex, ostore_st), (R.Error (12 :: 32 word) :: (32 word,  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> bool) R))) (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>5). Let\<^sub>d\<^sub>s (array_create (ex, (1 :: 32 word))) (\<lambda>ds\<^sub>1\<^sub>6. case_R (\<lambda>ex. HOL.Let (freeObj (ex, obj)) (\<lambda>ex. ((ex, ostore_st), (R.Error (12 :: 32 word) :: (32 word,  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> bool) R)))) (\<lambda>ds\<^sub>1\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p2\<^sub>f) (\<lambda>(entries,ds\<^sub>2\<^sub>0). Let\<^sub>d\<^sub>s (newObjDentarr ex) (\<lambda>ds\<^sub>2\<^sub>1. case_R (\<lambda>ex. HOL.Let (freeObj (ex, obj)) (\<lambda>ex. HOL.Let (array_free (ArrayFreeP.make entries deep_freeObjDentry ex)) (\<lambda>ex. ((ex, ostore_st), (R.Error (12 :: 32 word) :: (32 word,  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> bool) R))))) (\<lambda>ds\<^sub>2\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>2\<^sub>5). HOL.Let (0 :: 32 word) (\<lambda>nb_dentry. HOL.Let (ObjDentarr.entries\<^sub>f_update (\<lambda>_. entries) (ObjDentarr.nb_dentry\<^sub>f_update (\<lambda>_. nb_dentry) (ObjDentarr.id\<^sub>f_update (\<lambda>_. oid) dentarr))) (\<lambda>dentarr. HOL.Let (obj_init_default (obj, (2 :: 8 word))) (\<lambda>obj. HOL.Let (Obj.len\<^sub>f_update (\<lambda>_. (+) (24 :: 32 word) (12 :: 32 word)) obj) (\<lambda>obj. ((ex, ostore_st), (R.Success (obj, dentarr, True) :: (32 word,  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> bool) R))))))))) ds\<^sub>2\<^sub>1)))) ds\<^sub>1\<^sub>6)))) ds\<^sub>1\<^sub>1))) (\<lambda>obj. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.ounion\<^sub>f) (\<lambda>(ounion,obj). Let\<^sub>d\<^sub>s (extract_dentarr_from_union (ex, ounion)) (\<lambda>ds\<^sub>1\<^sub>1. case_R (\<lambda>ex. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t obj Obj.crc\<^sub>f) (\<lambda>(crc,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 Obj.magic\<^sub>f) (\<lambda>(magic,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 Obj.sqnum\<^sub>f) (\<lambda>(sqnum,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 Obj.offs\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 Obj.len\<^sub>f) (\<lambda>(len,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 Obj.trans\<^sub>f) (\<lambda>(trans,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 Obj.otype\<^sub>f) (\<lambda>(otype,obj). HOL.Let (freeObj (ex, obj)) (\<lambda>ex. ((ex, ostore_st), (R.Error (22 :: 32 word) :: (32 word,  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> bool) R))))))))))) (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>1\<^sub>5). ((ex, ostore_st), (R.Success (obj, dentarr, False) :: (32 word,  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> bool) R))))) ds\<^sub>1\<^sub>1))) r))))))))"

definition
  dentarr_read_and_add :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  VfsInode\<^sub>T \<times> 8 word WordArray \<times>  VfsInode\<^sub>T \<times> 8 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word, 64 word \<times>  Obj\<^sub>T) R"
where
  "dentarr_read_and_add ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P7_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P7_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P7_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P7_p4\<^sub>f) (\<lambda>(vdir,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P7_p5\<^sub>f) (\<lambda>(name,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P7_p6\<^sub>f) (\<lambda>(vnode,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P7_p7\<^sub>f) (\<lambda>(dt,ds\<^sub>7). HOL.Let (obj_id_dentarr_mk (vfs_inode_get_ino vdir, name)) (\<lambda>oid. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (read_or_create_dentarr (ex, mount_st, ostore_st, oid)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>2). case_R (\<lambda>err. ((ex, ostore_st), (R.Error err :: (32 word, 64 word \<times>  Obj\<^sub>T) R))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p1\<^sub>f) (\<lambda>(dentarr_obj,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P3_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P3_p3\<^sub>f) (\<lambda>(created,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_add_dentry (ex, dentarr, vnode, name, dt)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>8,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>2\<^sub>2). case_R (\<lambda>err. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr dentarr ::  ObjUnion\<^sub>T)) dentarr_obj) (\<lambda>dentarr_obj. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. ((ex, ostore_st), (R.Error err :: (32 word, 64 word \<times>  Obj\<^sub>T) R))))) (\<lambda>ds\<^sub>2\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>4 (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr dentarr ::  ObjUnion\<^sub>T)) dentarr_obj) (\<lambda>dentarr_obj. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_calculate_sz_change (created, dentarr_obj)) P2_p1\<^sub>f) (\<lambda>(dentarr_obj,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>7). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. ((ex, ostore_st), (R.Error err :: (32 word, 64 word \<times>  Obj\<^sub>T) R)))) (\<lambda>sz_change. Let\<^sub>d\<^sub>s (safe_add64 (vfs_inode_get_size vdir, (ucast sz_change :: 64 word))) (\<lambda>ds\<^sub>2\<^sub>9. case_R (\<lambda>ds\<^sub>3\<^sub>0. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>0 (\<lambda>ds\<^sub>3\<^sub>2. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>3\<^sub>3. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. ((ex, ostore_st), (R.Error (75 :: 32 word) :: (32 word, 64 word \<times>  Obj\<^sub>T) R)))))) (\<lambda>new_v_size. ((ex, ostore_st), (R.Success (new_v_size, dentarr_obj) :: (32 word, 64 word \<times>  Obj\<^sub>T) R))) ds\<^sub>2\<^sub>9)) r))))) r)))))))) r))))))))))))"

definition
  move_read_or_create_dentarrs :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  VfsInode\<^sub>T \<times>  VfsInode\<^sub>T \<times> 8 word WordArray \<times> 8 word WordArray \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word,  Obj\<^sub>T \<times>  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> 32 word \<times> 32 word) R"
where
  "move_read_or_create_dentarrs ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P7_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P7_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P7_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P7_p4\<^sub>f) (\<lambda>(old_vdir,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P7_p5\<^sub>f) (\<lambda>(new_vdir,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P7_p6\<^sub>f) (\<lambda>(old_name,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P7_p7\<^sub>f) (\<lambda>(new_name,ds\<^sub>7). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. HOL.Let (obj_id_dentarr_mk (vfs_inode_get_ino old_vdir, old_name)) (\<lambda>oldoid. HOL.Let (obj_id_dentarr_mk (vfs_inode_get_ino new_vdir, new_name)) (\<lambda>newoid. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (read_or_create_dentarr (ex, mount_st, ostore_st, oldoid)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>9,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>3). case_R (\<lambda>err. ((ex, ostore_st), (R.Error err :: (32 word,  Obj\<^sub>T \<times>  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> 32 word \<times> 32 word) R))) (\<lambda>ds\<^sub>1\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P3_p1\<^sub>f) (\<lambda>(old_o,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P3_p2\<^sub>f) (\<lambda>(old_dent,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p3\<^sub>f) (\<lambda>(created,ds\<^sub>1\<^sub>8). HOL.Let (HOL.If created (0 :: 32 word) (Obj.len\<^sub>f old_o)) (\<lambda>old_dent_size. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (read_or_create_dentarr (ex, mount_st, ostore_st, newoid)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>9,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>3). case_R (\<lambda>err. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr old_dent ::  ObjUnion\<^sub>T)) old_o) (\<lambda>old_o. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. ((ex, ostore_st), (R.Error err :: (32 word,  Obj\<^sub>T \<times>  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> 32 word \<times> 32 word) R))))) (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P3_p1\<^sub>f) (\<lambda>(new_o,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P3_p2\<^sub>f) (\<lambda>(new_dent,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P3_p3\<^sub>f) (\<lambda>(created,ds\<^sub>2\<^sub>8). HOL.Let (HOL.If created (0 :: 32 word) (Obj.len\<^sub>f new_o)) (\<lambda>new_dent_size. ((ex, ostore_st), (R.Success (old_o, new_o, old_dent, new_dent, old_dent_size, new_dent_size) :: (32 word,  Obj\<^sub>T \<times>  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> 32 word \<times> 32 word) R))))))) r))))))))) r))))))))))))))"

definition
  rename_read_or_create_dentarrs :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 64 word \<times> 64 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word,  Obj\<^sub>T \<times>  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> 32 word \<times> 32 word) R"
where
  "rename_read_or_create_dentarrs ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p4\<^sub>f) (\<lambda>(oldoid,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p5\<^sub>f) (\<lambda>(newoid,ds\<^sub>5). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (read_or_create_dentarr (ex, mount_st, ostore_st, oldoid)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>1). case_R (\<lambda>err. ((ex, ostore_st), (R.Error err :: (32 word,  Obj\<^sub>T \<times>  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> 32 word \<times> 32 word) R))) (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p1\<^sub>f) (\<lambda>(old_o,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p2\<^sub>f) (\<lambda>(old_dent,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P3_p3\<^sub>f) (\<lambda>(created,ds\<^sub>1\<^sub>6). HOL.Let (HOL.If created (0 :: 32 word) (Obj.len\<^sub>f old_o)) (\<lambda>old_dent_size. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (read_or_create_dentarr (ex, mount_st, ostore_st, newoid)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>7,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>1). case_R (\<lambda>err. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr old_dent ::  ObjUnion\<^sub>T)) old_o) (\<lambda>old_o. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. ((ex, ostore_st), (R.Error err :: (32 word,  Obj\<^sub>T \<times>  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> 32 word \<times> 32 word) R))))) (\<lambda>ds\<^sub>2\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P3_p1\<^sub>f) (\<lambda>(new_o,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P3_p2\<^sub>f) (\<lambda>(new_dent,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P3_p3\<^sub>f) (\<lambda>(created,ds\<^sub>2\<^sub>6). HOL.Let (HOL.If created (0 :: 32 word) (Obj.len\<^sub>f new_o)) (\<lambda>new_dent_size. ((ex, ostore_st), (R.Success (old_o, new_o, old_dent, new_dent, old_dent_size, new_dent_size) :: (32 word,  Obj\<^sub>T \<times>  Obj\<^sub>T \<times>  ObjDentarr\<^sub>T \<times>  ObjDentarr\<^sub>T \<times> 32 word \<times> 32 word) R))))))) r))))))))) r))))))))))"

definition
  delete_single_obj :: "((64 word,  ObjAddr\<^sub>T) RbtNode,  SysState \<times>  FsmState\<^sub>T \<times> (64 word,  GimNode\<^sub>T) RbtNode AllocPool,  MountState\<^sub>T \<times>  ObjAddr\<^sub>T) ElemAO \<Rightarrow>  SysState \<times>  FsmState\<^sub>T \<times> (64 word,  GimNode\<^sub>T) RbtNode AllocPool"
where
  "delete_single_obj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(node,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P3_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P3_p3\<^sub>f) (\<lambda>(gimpool,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(oaddr,ds\<^sub>1\<^sub>0). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (rbtnode_get_val node) (\<lambda>val. HOL.Let (rbtnode_get_key node) (\<lambda>oid. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>2. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsm_mark_dirty_recycle (ex, mount_st, fsm_st, oid, val, idx_to_gim_node node)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>1\<^sub>5). (ex, fsm_st, gimpool))))))))))))))))"

definition
  should_delete :: "((64 word,  ObjAddr\<^sub>T) RbtNode,  SysState \<times>  FsmState\<^sub>T \<times> (64 word,  GimNode\<^sub>T) RbtNode AllocPool,  MountState\<^sub>T \<times>  ObjAddr\<^sub>T) ElemAO \<Rightarrow> bool"
where
  "should_delete ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(node,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P3_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P3_p3\<^sub>f) (\<lambda>(gimpool,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(oaddr,ds\<^sub>1\<^sub>0). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (rbtnode_get_val node) (\<lambda>val. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>2. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>3. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>4. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>5. (<) (ObjAddr.sqnum\<^sub>f val) (ObjAddr.sqnum\<^sub>f oaddr)))))))))))))))"

definition
  ostore_free_pools :: " SysState \<times>  OstoreState\<^sub>T \<Rightarrow>  SysState \<times>  OstoreState\<^sub>T"
where
  "ostore_free_pools ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.pools\<^sub>f) (\<lambda>(pools,ostore_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t pools AllocPools.idx\<^sub>f) (\<lambda>(idx,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 AllocPools.gim\<^sub>f) (\<lambda>(gim,pools). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (allocpool_clean (ex, idx)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(idx,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (allocpool_clean (ex, gim)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(gim,ds\<^sub>8). HOL.Let (AllocPools.gim\<^sub>f_update (\<lambda>_. gim) (AllocPools.idx\<^sub>f_update (\<lambda>_. idx) pools)) (\<lambda>pools. (ex, OstoreState.pools\<^sub>f_update (\<lambda>_. pools) ostore_st)))))))))))"

definition
  ostore_clean :: " SysState \<times>  OstoreState\<^sub>T \<Rightarrow>  SysState"
where
  "ostore_clean ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.rbuf\<^sub>f) (\<lambda>(rbuf,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 OstoreState.wbuf\<^sub>f) (\<lambda>(wbuf,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 OstoreState.opad\<^sub>f) (\<lambda>(opad,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 OstoreState.pools\<^sub>f) (\<lambda>(pools,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 OstoreState.fsm_st\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 OstoreState.index_st\<^sub>f) (\<lambda>(index_st,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 OstoreState.ubi_vol\<^sub>f) (\<lambda>(ubi_vol,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 OstoreState.summary\<^sub>f) (\<lambda>(summary,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 OstoreState.sum_obj\<^sub>f) (\<lambda>(sum_obj,ostore_st). HOL.Let (buf_free (ex, rbuf)) (\<lambda>ex. HOL.Let (buf_free (ex, wbuf)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, opad)) (\<lambda>ex. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t pools AllocPools.idx\<^sub>f) (\<lambda>(idxpool,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 AllocPools.gim\<^sub>f) (\<lambda>(gimpool,pools). HOL.Let (allocpool_free (ex, idxpool)) (\<lambda>ex. HOL.Let (allocpool_free (ex, gimpool)) (\<lambda>ex. HOL.Let (fsm_clean (ex, fsm_st)) (\<lambda>ex. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t index_st IndexState.addrs\<^sub>f) (\<lambda>(addrs,index_st). HOL.Let (rbt_free (ex, addrs)) (\<lambda>ex. HOL.Let (wubi_close (ex, ubi_vol)) (\<lambda>ex. HOL.Let (summary_clean (ex, summary)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, sum_obj)) (\<lambda>ex. HOL.Let (freeOstoreState (ex, ostore_st)) (\<lambda>ex. ex)))))))))))))))))))))))))"

definition
  fsop_clean :: " FsopFs'P\<^sub>T \<Rightarrow>  SysState"
where
  "fsop_clean ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopFsP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopFsP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.fsop_st\<^sub>f) (\<lambda>(fsop_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsState.mount_st\<^sub>f) (\<lambda>(mount_st,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t mount_st MountState.vol\<^sub>f) (\<lambda>(vol,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 MountState.dev\<^sub>f) (\<lambda>(dev,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 MountState.obj_sup\<^sub>f) (\<lambda>(obj_sup,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 MountState.super\<^sub>f) (\<lambda>(super,mount_st). HOL.Let (deep_freeObjSuper (ex, super)) (\<lambda>ex. HOL.Let (freeObj (ex, obj_sup)) (\<lambda>ex. HOL.Let (freeUbiVolInfo (ex, vol)) (\<lambda>ex. HOL.Let (freeUbiDevInfo (ex, dev)) (\<lambda>ex. HOL.Let (freeMountState (ex, mount_st)) (\<lambda>ex. HOL.Let (ostore_clean (ex, ostore_st)) (\<lambda>ex. HOL.Let (freeFsopState (ex, fsop_st)) (\<lambda>ex. HOL.Let (freeFsState (ex, fs_st)) (\<lambda>ex. ex)))))))))))))))))"

definition
  ostore_init :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<Rightarrow> (32 word \<times>  SysState \<times>  OstoreState\<^sub>T,  SysState \<times>  OstoreState\<^sub>T) R"
where
  "ostore_init ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (24 :: 32 word) (\<lambda>next_inum. HOL.Let (0 :: 64 word) (\<lambda>next_sqnum. HOL.Let (2 :: 32 word) (\<lambda>wbuf_eb. HOL.Let (0 :: 32 word) (\<lambda>used. HOL.Let (0 :: 32 word) (\<lambda>sync_offs. HOL.Let (wubi_vol_usable_leb_size (MountState.vol\<^sub>f mount_st)) (\<lambda>leb_size. Let\<^sub>d\<^sub>s (buf_create (ex, leb_size)) (\<lambda>ds\<^sub>4. case_R (\<lambda>ex. (R.Error ((12 :: 32 word), ex, ostore_st) :: (32 word \<times>  SysState \<times>  OstoreState\<^sub>T,  SysState \<times>  OstoreState\<^sub>T) R)) (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(rbuf,ds\<^sub>8). Let\<^sub>d\<^sub>s (buf_create (ex, leb_size)) (\<lambda>ds\<^sub>9. case_R (\<lambda>ex. HOL.Let (buf_free (ex, rbuf)) (\<lambda>ex. (R.Error ((12 :: 32 word), ex, ostore_st) :: (32 word \<times>  SysState \<times>  OstoreState\<^sub>T,  SysState \<times>  OstoreState\<^sub>T) R))) (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(wbuf,ds\<^sub>1\<^sub>3). Let\<^sub>d\<^sub>s (newObj ex) (\<lambda>ds\<^sub>1\<^sub>4. case_R (\<lambda>ex. HOL.Let (buf_free (ex, rbuf)) (\<lambda>ex. HOL.Let (buf_free (ex, wbuf)) (\<lambda>ex. (R.Error ((12 :: 32 word), ex, ostore_st) :: (32 word \<times>  SysState \<times>  OstoreState\<^sub>T,  SysState \<times>  OstoreState\<^sub>T) R)))) (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(opad,ds\<^sub>1\<^sub>8). Let\<^sub>d\<^sub>s (allocpool_create ex) (\<lambda>ds\<^sub>1\<^sub>9. case_R (\<lambda>ex. HOL.Let (buf_free (ex, rbuf)) (\<lambda>ex. HOL.Let (buf_free (ex, wbuf)) (\<lambda>ex. HOL.Let (freeObj (ex, opad)) (\<lambda>ex. (R.Error ((12 :: 32 word), ex, ostore_st) :: (32 word \<times>  SysState \<times>  OstoreState\<^sub>T,  SysState \<times>  OstoreState\<^sub>T) R))))) (\<lambda>ds\<^sub>2\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p2\<^sub>f) (\<lambda>(idxpool,ds\<^sub>2\<^sub>3). Let\<^sub>d\<^sub>s (allocpool_create ex) (\<lambda>ds\<^sub>2\<^sub>4. case_R (\<lambda>ex. HOL.Let (buf_free (ex, rbuf)) (\<lambda>ex. HOL.Let (buf_free (ex, wbuf)) (\<lambda>ex. HOL.Let (freeObj (ex, opad)) (\<lambda>ex. HOL.Let (allocpool_free (ex, idxpool)) (\<lambda>ex. (R.Error ((12 :: 32 word), ex, ostore_st) :: (32 word \<times>  SysState \<times>  OstoreState\<^sub>T,  SysState \<times>  OstoreState\<^sub>T) R)))))) (\<lambda>ds\<^sub>2\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P2_p2\<^sub>f) (\<lambda>(gimpool,ds\<^sub>2\<^sub>8). Let\<^sub>d\<^sub>s (newFsmState ex) (\<lambda>ds\<^sub>2\<^sub>9. case_R (\<lambda>ex. HOL.Let (buf_free (ex, rbuf)) (\<lambda>ex. HOL.Let (buf_free (ex, wbuf)) (\<lambda>ex. HOL.Let (freeObj (ex, opad)) (\<lambda>ex. HOL.Let (allocpool_free (ex, idxpool)) (\<lambda>ex. HOL.Let (allocpool_free (ex, gimpool)) (\<lambda>ex. (R.Error ((12 :: 32 word), ex, ostore_st) :: (32 word \<times>  SysState \<times>  OstoreState\<^sub>T,  SysState \<times>  OstoreState\<^sub>T) R))))))) (\<lambda>ds\<^sub>3\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P2_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>3\<^sub>3). Let\<^sub>d\<^sub>s (rbt_create ex) (\<lambda>ds\<^sub>3\<^sub>4. case_R (\<lambda>ex. HOL.Let (buf_free (ex, rbuf)) (\<lambda>ex. HOL.Let (buf_free (ex, wbuf)) (\<lambda>ex. HOL.Let (freeObj (ex, opad)) (\<lambda>ex. HOL.Let (allocpool_free (ex, idxpool)) (\<lambda>ex. HOL.Let (allocpool_free (ex, gimpool)) (\<lambda>ex. HOL.Let (freeFsmState (ex, fsm_st)) (\<lambda>ex. (R.Error ((12 :: 32 word), ex, ostore_st) :: (32 word \<times>  SysState \<times>  OstoreState\<^sub>T,  SysState \<times>  OstoreState\<^sub>T) R)))))))) (\<lambda>ds\<^sub>3\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P2_p2\<^sub>f) (\<lambda>(addrs,ds\<^sub>3\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsm_init (ex, mount_st, fsm_st)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>4\<^sub>0). case_R (\<lambda>ds\<^sub>4\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>4\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>3 P2_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>4\<^sub>4). HOL.Let (buf_free (ex, rbuf)) (\<lambda>ex. HOL.Let (buf_free (ex, wbuf)) (\<lambda>ex. HOL.Let (freeObj (ex, opad)) (\<lambda>ex. HOL.Let (allocpool_free (ex, idxpool)) (\<lambda>ex. HOL.Let (allocpool_free (ex, gimpool)) (\<lambda>ex. HOL.Let (freeFsmState (ex, fsm_st)) (\<lambda>ex. HOL.Let (rbt_free (ex, addrs)) (\<lambda>ex. (R.Error (err, ex, ostore_st) :: (32 word \<times>  SysState \<times>  OstoreState\<^sub>T,  SysState \<times>  OstoreState\<^sub>T) R))))))))))) (\<lambda>fsm_st. HOL.Let (checked_div leb_size ((+) (24 :: 32 word) (8 :: 32 word))) (\<lambda>max_nb_sum_entry. HOL.Let (HOL.If (MountState.no_summary\<^sub>f mount_st) (1 :: 32 word) max_nb_sum_entry) (\<lambda>max_nb_sum_entry. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4\<^sub>3. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4\<^sub>4. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4\<^sub>5. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4\<^sub>6. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4\<^sub>7. Let\<^sub>d\<^sub>s (summary_init (ex, max_nb_sum_entry)) (\<lambda>ds\<^sub>4\<^sub>8. case_R (\<lambda>ex. HOL.Let (buf_free (ex, rbuf)) (\<lambda>ex. HOL.Let (buf_free (ex, wbuf)) (\<lambda>ex. HOL.Let (freeObj (ex, opad)) (\<lambda>ex. HOL.Let (allocpool_free (ex, idxpool)) (\<lambda>ex. HOL.Let (allocpool_free (ex, gimpool)) (\<lambda>ex. HOL.Let (fsm_clean (ex, fsm_st)) (\<lambda>ex. HOL.Let (rbt_free (ex, addrs)) (\<lambda>ex. (R.Error ((12 :: 32 word), ex, ostore_st) :: (32 word \<times>  SysState \<times>  OstoreState\<^sub>T,  SysState \<times>  OstoreState\<^sub>T) R))))))))) (\<lambda>ds\<^sub>5\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>1 P3_p2\<^sub>f) (\<lambda>(summary,ds\<^sub>5\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>2 P3_p3\<^sub>f) (\<lambda>(sum_obj,ds\<^sub>5\<^sub>3). HOL.Let (ObjAddr.make (0 :: 32 word) (0 :: 32 word) (0 :: 32 word) (0 :: 64 word)) (\<lambda>oaddr. HOL.Let (AllocPools.make idxpool gimpool) (\<lambda>pools. HOL.Let (obj_init_default (opad, (5 :: 8 word))) (\<lambda>opad. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjPad () ::  ObjUnion\<^sub>T)) opad) (\<lambda>opad. HOL.Let (IndexState.make addrs) (\<lambda>index_st. HOL.Let (OstoreState.sum_obj\<^sub>f_update (\<lambda>_. sum_obj) (OstoreState.summary\<^sub>f_update (\<lambda>_. summary) (OstoreState.index_st\<^sub>f_update (\<lambda>_. index_st) (OstoreState.fsm_st\<^sub>f_update (\<lambda>_. fsm_st) (OstoreState.oaddr\<^sub>f_update (\<lambda>_. oaddr) (OstoreState.pools\<^sub>f_update (\<lambda>_. pools) (OstoreState.opad\<^sub>f_update (\<lambda>_. opad) (OstoreState.sync_offs\<^sub>f_update (\<lambda>_. sync_offs) (OstoreState.used\<^sub>f_update (\<lambda>_. used) (OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) (OstoreState.wbuf_eb\<^sub>f_update (\<lambda>_. wbuf_eb) (OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) (OstoreState.next_sqnum\<^sub>f_update (\<lambda>_. next_sqnum) (OstoreState.next_inum\<^sub>f_update (\<lambda>_. next_inum) ostore_st)))))))))))))) (\<lambda>ostore_st. (R.Success (ex, ostore_st) :: (32 word \<times>  SysState \<times>  OstoreState\<^sub>T,  SysState \<times>  OstoreState\<^sub>T) R))))))))))) ds\<^sub>4\<^sub>8))))))))) r))))) ds\<^sub>3\<^sub>4)))) ds\<^sub>2\<^sub>9)))) ds\<^sub>2\<^sub>4)))) ds\<^sub>1\<^sub>9)))) ds\<^sub>1\<^sub>4)))) ds\<^sub>9)))) ds\<^sub>4))))))))))"

definition
  fsop_init :: " FsopInitP\<^sub>T \<Rightarrow> ( FsopFs'E\<^sub>T,  FsopFs'P\<^sub>T) R"
where
  "fsop_init ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopInitP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopInitP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopInitP.name\<^sub>f) (\<lambda>(name,ds\<^sub>1). Let\<^sub>d\<^sub>s (newMountState ex) (\<lambda>ds\<^sub>4. case_R (\<lambda>ex. (R.Error (FsopFs'E.make (12 :: 32 word) ex fs_st) :: ( FsopFs'E\<^sub>T,  FsopFs'P\<^sub>T) R)) (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>8). Let\<^sub>d\<^sub>s (newFsopState ex) (\<lambda>ds\<^sub>9. case_R (\<lambda>ex. HOL.Let (freeMountState (ex, mount_st)) (\<lambda>ex. (R.Error (FsopFs'E.make (12 :: 32 word) ex fs_st) :: ( FsopFs'E\<^sub>T,  FsopFs'P\<^sub>T) R))) (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(fsop_st,ds\<^sub>1\<^sub>3). Let\<^sub>d\<^sub>s (newOstoreState ex) (\<lambda>ds\<^sub>1\<^sub>4. case_R (\<lambda>ex. HOL.Let (freeMountState (ex, mount_st)) (\<lambda>ex. HOL.Let (freeFsopState (ex, fsop_st)) (\<lambda>ex. (R.Error (FsopFs'E.make (12 :: 32 word) ex fs_st) :: ( FsopFs'E\<^sub>T,  FsopFs'P\<^sub>T) R)))) (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>8). Let\<^sub>d\<^sub>s (newUbiVolInfo ex) (\<lambda>ds\<^sub>1\<^sub>9. case_R (\<lambda>ex. HOL.Let (freeMountState (ex, mount_st)) (\<lambda>ex. HOL.Let (freeFsopState (ex, fsop_st)) (\<lambda>ex. HOL.Let (freeOstoreState (ex, ostore_st)) (\<lambda>ex. (R.Error (FsopFs'E.make (22 :: 32 word) ex fs_st) :: ( FsopFs'E\<^sub>T,  FsopFs'P\<^sub>T) R))))) (\<lambda>ds\<^sub>2\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p2\<^sub>f) (\<lambda>(vol,ds\<^sub>2\<^sub>3). Let\<^sub>d\<^sub>s (newUbiDevInfo ex) (\<lambda>ds\<^sub>2\<^sub>4. case_R (\<lambda>ex. HOL.Let (freeMountState (ex, mount_st)) (\<lambda>ex. HOL.Let (freeFsopState (ex, fsop_st)) (\<lambda>ex. HOL.Let (freeOstoreState (ex, ostore_st)) (\<lambda>ex. HOL.Let (freeUbiVolInfo (ex, vol)) (\<lambda>ex. (R.Error (FsopFs'E.make (22 :: 32 word) ex fs_st) :: ( FsopFs'E\<^sub>T,  FsopFs'P\<^sub>T) R)))))) (\<lambda>ds\<^sub>2\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P2_p2\<^sub>f) (\<lambda>(dev,ds\<^sub>2\<^sub>8). Let\<^sub>d\<^sub>s (newObj ex) (\<lambda>ds\<^sub>2\<^sub>9. case_R (\<lambda>ex. HOL.Let (freeMountState (ex, mount_st)) (\<lambda>ex. HOL.Let (freeFsopState (ex, fsop_st)) (\<lambda>ex. HOL.Let (freeOstoreState (ex, ostore_st)) (\<lambda>ex. HOL.Let (freeUbiVolInfo (ex, vol)) (\<lambda>ex. HOL.Let (freeUbiDevInfo (ex, dev)) (\<lambda>ex. (R.Error (FsopFs'E.make (22 :: 32 word) ex fs_st) :: ( FsopFs'E\<^sub>T,  FsopFs'P\<^sub>T) R))))))) (\<lambda>ds\<^sub>3\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P2_p2\<^sub>f) (\<lambda>(obj_sup,ds\<^sub>3\<^sub>3). Let\<^sub>d\<^sub>s (wubi_open (WubiOpenP.make ex name (1 :: 32 word))) (\<lambda>ds\<^sub>3\<^sub>4. case_R (\<lambda>ex. HOL.Let (freeMountState (ex, mount_st)) (\<lambda>ex. HOL.Let (freeFsopState (ex, fsop_st)) (\<lambda>ex. HOL.Let (freeOstoreState (ex, ostore_st)) (\<lambda>ex. HOL.Let (freeUbiVolInfo (ex, vol)) (\<lambda>ex. HOL.Let (freeUbiDevInfo (ex, dev)) (\<lambda>ex. HOL.Let (freeObj (ex, obj_sup)) (\<lambda>ex. (R.Error (FsopFs'E.make (22 :: 32 word) ex fs_st) :: ( FsopFs'E\<^sub>T,  FsopFs'P\<^sub>T) R)))))))) (\<lambda>ds\<^sub>3\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P2_p2\<^sub>f) (\<lambda>(ubivol,ds\<^sub>3\<^sub>8). HOL.Let (wubi_get_vol_info (ubivol, vol)) (\<lambda>vol. HOL.Let (wubi_vol_ubi_num vol) (\<lambda>ubi_num. Let\<^sub>d\<^sub>s (wubi_get_dev_info (ubi_num, dev)) (\<lambda>ds\<^sub>3\<^sub>9. case_R (\<lambda>ds\<^sub>4\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>0 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>4\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>2 P2_p2\<^sub>f) (\<lambda>(dev,ds\<^sub>4\<^sub>3). HOL.Let (freeMountState (ex, mount_st)) (\<lambda>ex. HOL.Let (freeFsopState (ex, fsop_st)) (\<lambda>ex. HOL.Let (freeOstoreState (ex, ostore_st)) (\<lambda>ex. HOL.Let (freeUbiVolInfo (ex, vol)) (\<lambda>ex. HOL.Let (freeUbiDevInfo (ex, dev)) (\<lambda>ex. HOL.Let (freeObj (ex, obj_sup)) (\<lambda>ex. HOL.Let (wubi_close (ex, ubivol)) (\<lambda>ex. (R.Error (FsopFs'E.make (22 :: 32 word) ex fs_st) :: ( FsopFs'E\<^sub>T,  FsopFs'P\<^sub>T) R))))))))))) (\<lambda>dev. Let\<^sub>d\<^sub>s (newObjSuper ex) (\<lambda>ds\<^sub>4\<^sub>2. case_R (\<lambda>ex. HOL.Let (freeMountState (ex, mount_st)) (\<lambda>ex. HOL.Let (freeFsopState (ex, fsop_st)) (\<lambda>ex. HOL.Let (freeOstoreState (ex, ostore_st)) (\<lambda>ex. HOL.Let (freeUbiVolInfo (ex, vol)) (\<lambda>ex. HOL.Let (freeUbiDevInfo (ex, dev)) (\<lambda>ex. HOL.Let (freeObj (ex, obj_sup)) (\<lambda>ex. HOL.Let (wubi_close (ex, ubivol)) (\<lambda>ex. (R.Error (FsopFs'E.make (12 :: 32 word) ex fs_st) :: ( FsopFs'E\<^sub>T,  FsopFs'P\<^sub>T) R))))))))) (\<lambda>ds\<^sub>4\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>5 P2_p2\<^sub>f) (\<lambda>(super,ds\<^sub>4\<^sub>6). HOL.Let (mkObjSuper (super, vol, dev)) (\<lambda>super. HOL.Let (obj_init_default (obj_sup, (4 :: 8 word))) (\<lambda>obj_sup. HOL.Let (MountState.no_summary\<^sub>f_update (\<lambda>_. False) (MountState.super_offs\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (MountState.obj_sup\<^sub>f_update (\<lambda>_. obj_sup) (MountState.super\<^sub>f_update (\<lambda>_. super) (MountState.eb_recovery_offs\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (MountState.eb_recovery\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (MountState.dev\<^sub>f_update (\<lambda>_. dev) (MountState.vol\<^sub>f_update (\<lambda>_. vol) mount_st)))))))) (\<lambda>mount_st. HOL.Let (FsopState.is_ro\<^sub>f_update (\<lambda>_. True) fsop_st) (\<lambda>fsop_st. HOL.Let (wubi_close (ex, ubivol)) (\<lambda>ex. Let\<^sub>d\<^sub>s (ostore_init (ex, mount_st, ostore_st)) (\<lambda>ds\<^sub>4\<^sub>7. case_R (\<lambda>ds\<^sub>4\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>8 P3_p1\<^sub>f) (\<lambda>(err,ds\<^sub>5\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>0 P3_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>5\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>1 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>5\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t mount_st MountState.obj_sup\<^sub>f) (\<lambda>(obj_sup,ds\<^sub>5\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>3 MountState.vol\<^sub>f) (\<lambda>(vol,ds\<^sub>5\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>4 MountState.dev\<^sub>f) (\<lambda>(dev,ds\<^sub>5\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>5 MountState.super\<^sub>f) (\<lambda>(super,mount_st). HOL.Let (deep_freeObjSuper (ex, super)) (\<lambda>ex. HOL.Let (freeObj (ex, obj_sup)) (\<lambda>ex. HOL.Let (freeMountState (ex, mount_st)) (\<lambda>ex. HOL.Let (freeFsopState (ex, fsop_st)) (\<lambda>ex. HOL.Let (freeOstoreState (ex, ostore_st)) (\<lambda>ex. HOL.Let (freeUbiVolInfo (ex, vol)) (\<lambda>ex. HOL.Let (freeUbiDevInfo (ex, dev)) (\<lambda>ex. (R.Error (FsopFs'E.make err ex fs_st) :: ( FsopFs'E\<^sub>T,  FsopFs'P\<^sub>T) R)))))))))))))))) (\<lambda>ds\<^sub>5\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>5\<^sub>2). HOL.Let (FsState.fsop_st\<^sub>f_update (\<lambda>_. fsop_st) (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) fs_st))) (\<lambda>fs_st. (R.Success (FsopFsP.make ex fs_st) :: ( FsopFs'E\<^sub>T,  FsopFs'P\<^sub>T) R))))) ds\<^sub>4\<^sub>7))))))))) ds\<^sub>4\<^sub>2)) ds\<^sub>3\<^sub>9)))))) ds\<^sub>3\<^sub>4)))) ds\<^sub>2\<^sub>9)))) ds\<^sub>2\<^sub>4)))) ds\<^sub>1\<^sub>9)))) ds\<^sub>1\<^sub>4)))) ds\<^sub>9)))) ds\<^sub>4))))"

definition
  ostore_alloc_pools :: " SysState \<times>  OstoreState\<^sub>T \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "ostore_alloc_pools ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p2\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P3_p3\<^sub>f) (\<lambda>(nb_nodes,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.pools\<^sub>f) (\<lambda>(pools,ostore_st). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t pools AllocPools.idx\<^sub>f) (\<lambda>(idx,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 AllocPools.gim\<^sub>f) (\<lambda>(gim,pools). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (allocpool_prealloc (AllocPoolPreallocP.make ex idx nb_nodes)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(idx,ds\<^sub>1\<^sub>1). case_R (\<lambda>ds\<^sub>1\<^sub>2. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>2 (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (AllocPools.gim\<^sub>f_update (\<lambda>_. gim) (AllocPools.idx\<^sub>f_update (\<lambda>_. idx) pools)) (\<lambda>pools. ((ex, OstoreState.pools\<^sub>f_update (\<lambda>_. pools) ostore_st), (R.Error (12 :: 32 word) :: (32 word, unit) R))))) (\<lambda>ds\<^sub>1\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>4 (\<lambda>ds\<^sub>1\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (allocpool_prealloc (AllocPoolPreallocP.make ex gim nb_nodes)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>6,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p2\<^sub>f) (\<lambda>(gim,ds\<^sub>2\<^sub>0). case_R (\<lambda>ds\<^sub>2\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>1 (\<lambda>ds\<^sub>2\<^sub>3. HOL.Let (AllocPools.gim\<^sub>f_update (\<lambda>_. gim) (AllocPools.idx\<^sub>f_update (\<lambda>_. idx) pools)) (\<lambda>pools. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_free_pools (ex, OstoreState.pools\<^sub>f_update (\<lambda>_. pools) ostore_st)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>5). ((ex, ostore_st), (R.Error (12 :: 32 word) :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>2\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>3 (\<lambda>ds\<^sub>2\<^sub>4. HOL.Let (AllocPools.gim\<^sub>f_update (\<lambda>_. gim) (AllocPools.idx\<^sub>f_update (\<lambda>_. idx) pools)) (\<lambda>pools. ((ex, OstoreState.pools\<^sub>f_update (\<lambda>_. pools) ostore_st), (R.Success () :: (32 word, unit) R))))) r)))))) r)))))))))))"

definition
  fsm_mark_dirty :: " SysState \<times>  MountState\<^sub>T \<times>  FsmState\<^sub>T \<times> (64 word,  GimNode\<^sub>T) RbtNode AllocPool \<times> 64 word \<times>  ObjAddr\<^sub>T \<Rightarrow>  SysState \<times>  FsmState\<^sub>T \<times> (64 word,  GimNode\<^sub>T) RbtNode AllocPool"
where
  "fsm_mark_dirty ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P6_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P6_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P6_p3\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P6_p4\<^sub>f) (\<lambda>(gimpool,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P6_p5\<^sub>f) (\<lambda>(oid,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P6_p6\<^sub>f) (\<lambda>(oaddr,ds\<^sub>6). HOL.Let (fsm_mark_ebnum_dirty (fsm_st, ObjAddr.ebnum\<^sub>f oaddr, ObjAddr.len\<^sub>f oaddr)) (\<lambda>fsm_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fsm_st FsmState.gim\<^sub>f) (\<lambda>(gim,fsm_st). HOL.If ((~=) oid (18446744073709551615 :: 64 word)) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (allocpool_use (AllocPoolUseP.make gimpool fsm_mark_dirty_use (ex, gim) (oid, ObjAddr.sqnum\<^sub>f oaddr, (1 :: 16 word)))) P2_p1\<^sub>f) (\<lambda>(gimpool,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(gim,ds\<^sub>1\<^sub>1). (ex, FsmState.gim\<^sub>f_update (\<lambda>_. gim) fsm_st, gimpool)))))) (ex, FsmState.gim\<^sub>f_update (\<lambda>_. gim) fsm_st, gimpool)))))))))"

definition
  delete_obj :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 64 word \<times>  ObjAddr\<^sub>T \<Rightarrow>  SysState \<times>  OstoreState\<^sub>T"
where
  "delete_obj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p3\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p4\<^sub>f) (\<lambda>(oid,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P5_p5\<^sub>f) (\<lambda>(oaddr,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.index_st\<^sub>f) (\<lambda>(index_st,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 OstoreState.fsm_st\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 OstoreState.pools\<^sub>f) (\<lambda>(pools,ostore_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t index_st IndexState.addrs\<^sub>f) (\<lambda>(addrs,index_st). HOL.If (obj_id_is_dentarr oid) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t pools AllocPools.gim\<^sub>f) (\<lambda>(gim,pools). Let\<^sub>d\<^sub>s (rbt_cond_erase (RbtCondEraseP.make addrs oid should_delete delete_single_obj (ex, fsm_st, gim) (mount_st, oaddr))) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(addrs,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>0,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p3\<^sub>f) (\<lambda>(gim,ds\<^sub>1\<^sub>5). HOL.Let (AllocPools.gim\<^sub>f_update (\<lambda>_. gim) pools) (\<lambda>pools. HOL.Let (IndexState.addrs\<^sub>f_update (\<lambda>_. addrs) index_st) (\<lambda>index_st. (ex, OstoreState.oaddr\<^sub>f_update (\<lambda>_. oaddr) (OstoreState.pools\<^sub>f_update (\<lambda>_. pools) (OstoreState.fsm_st\<^sub>f_update (\<lambda>_. fsm_st) (OstoreState.index_st\<^sub>f_update (\<lambda>_. index_st) ostore_st)))))))))))))) (HOL.Let (inum_from_obj_id oid) (\<lambda>inum. HOL.Let (obj_id_end_mk inum) (\<lambda>oid_end. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t pools AllocPools.gim\<^sub>f) (\<lambda>(gim,pools). Let\<^sub>d\<^sub>s (fsm_mark_dirty (ex, mount_st, fsm_st, gim, oid, oaddr)) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P3_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P3_p3\<^sub>f) (\<lambda>(gim,ds\<^sub>1\<^sub>2). Let\<^sub>d\<^sub>s (rbt_filter (RbtFilterP.make addrs oid oid_end should_delete delete_single_obj (ex, fsm_st, gim) (mount_st, oaddr))) (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p1\<^sub>f) (\<lambda>(addrs,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>4,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P3_p3\<^sub>f) (\<lambda>(gim,ds\<^sub>1\<^sub>9). HOL.Let (AllocPools.gim\<^sub>f_update (\<lambda>_. gim) pools) (\<lambda>pools. HOL.Let (IndexState.addrs\<^sub>f_update (\<lambda>_. addrs) index_st) (\<lambda>index_st. (ex, OstoreState.oaddr\<^sub>f_update (\<lambda>_. oaddr) (OstoreState.pools\<^sub>f_update (\<lambda>_. pools) (OstoreState.fsm_st\<^sub>f_update (\<lambda>_. fsm_st) (OstoreState.index_st\<^sub>f_update (\<lambda>_. index_st) ostore_st)))))))))))))))))))))))))))))"

definition
  fold_delete_obj :: "( DelNode\<^sub>T ListNode,  SysState \<times>  OstoreState\<^sub>T,  MountState\<^sub>T) ElemAO \<Rightarrow>  SysState \<times>  OstoreState\<^sub>T"
where
  "fold_delete_obj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(delnode,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>5,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 OstoreState.oaddr\<^sub>f) (\<lambda>(oaddr,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 OstoreState.summary\<^sub>f) (\<lambda>(summary,ostore_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(mount_st,ds\<^sub>1). HOL.Let (listnode_get delnode) (\<lambda>node. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (delete_obj (ex, mount_st, ostore_st, DelNode.id\<^sub>f node, DelNode.oaddr\<^sub>f node)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>0). (ex, OstoreState.summary\<^sub>f_update (\<lambda>_. summary) (OstoreState.oaddr\<^sub>f_update (\<lambda>_. oaddr) ostore_st))))))))))))"

definition
  proc_objsdel :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List' \<Rightarrow>  SysState \<times>  OstoreState\<^sub>T"
where
  "proc_objsdel ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(objsdel,ds\<^sub>4). list_fold (ListFoldP.make objsdel fold_delete_obj (ex, ostore_st) mount_st)))))"

definition
  update_obj_pad :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  ObjAddr\<^sub>T \<Rightarrow>  SysState \<times>  OstoreState\<^sub>T"
where
  "update_obj_pad ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p3\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P4_p4\<^sub>f) (\<lambda>(oaddr,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.fsm_st\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 OstoreState.pools\<^sub>f) (\<lambda>(pools,ostore_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t pools AllocPools.gim\<^sub>f) (\<lambda>(gim,pools). Let\<^sub>d\<^sub>s (fsm_mark_dirty (ex, mount_st, fsm_st, gim, (18446744073709551615 :: 64 word), oaddr)) (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P3_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p3\<^sub>f) (\<lambda>(gim,ds\<^sub>1\<^sub>0). HOL.Let (AllocPools.gim\<^sub>f_update (\<lambda>_. gim) pools) (\<lambda>pools. HOL.Let (OstoreState.pools\<^sub>f_update (\<lambda>_. pools) (OstoreState.fsm_st\<^sub>f_update (\<lambda>_. fsm_st) ostore_st)) (\<lambda>ostore_st. (ex, OstoreState.oaddr\<^sub>f_update (\<lambda>_. oaddr) ostore_st))))))))))))))"

definition
  prepare_wbuf :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "prepare_wbuf ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p3\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P4_p4\<^sub>f) (\<lambda>(pad_to,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.wbuf\<^sub>f) (\<lambda>(wbuf,ostore_st). HOL.Let ((-) pad_to (OstoreState.used\<^sub>f ostore_st)) (\<lambda>pad_sz. HOL.If ((<) pad_sz (24 :: 32 word)) (HOL.Let (buf_memset (wbuf, OstoreState.used\<^sub>f ostore_st, pad_sz, (66 :: 8 word))) (\<lambda>wbuf. HOL.Let pad_to (\<lambda>used. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>6. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. ((ex, OstoreState.used\<^sub>f_update (\<lambda>_. used) (OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) ostore_st)), (R.Success () :: (32 word, unit) R)))))))) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.next_sqnum\<^sub>f) (\<lambda>(sqnum,ostore_st). Let\<^sub>d\<^sub>s (safe_add64 (sqnum, (1 :: 64 word))) (\<lambda>ds\<^sub>6. case_R (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s ds\<^sub>7 (\<lambda>ds\<^sub>9. ((ex, OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) (OstoreState.next_sqnum\<^sub>f_update (\<lambda>_. sqnum) ostore_st)), (R.Error (75 :: 32 word) :: (32 word, unit) R)))) (\<lambda>next_sqnum. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.opad\<^sub>f) (\<lambda>(opad,ostore_st). HOL.Let (ostore_update_padding_obj (opad, sqnum, (-) pad_sz (24 :: 32 word))) (\<lambda>opad. HOL.Let (OstoreState.used\<^sub>f ostore_st) (\<lambda>used. Let\<^sub>d\<^sub>s (serialise_Obj (wbuf, used, opad)) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(wbuf,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>2. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>3. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>4. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (OstoreState.next_sqnum\<^sub>f_update (\<lambda>_. next_sqnum) (OstoreState.used\<^sub>f_update (\<lambda>_. pad_to) (OstoreState.opad\<^sub>f_update (\<lambda>_. opad) (OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) ostore_st)))) OstoreState.summary\<^sub>f) (\<lambda>(summary,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 OstoreState.oaddr\<^sub>f) (\<lambda>(oaddr,ostore_st). HOL.Let (ObjAddr.sqnum\<^sub>f_update (\<lambda>_. sqnum) (ObjAddr.offs\<^sub>f_update (\<lambda>_. used) (ObjAddr.len\<^sub>f_update (\<lambda>_. pad_sz) (ObjAddr.ebnum\<^sub>f_update (\<lambda>_. OstoreState.wbuf_eb\<^sub>f ostore_st) oaddr)))) (\<lambda>oaddr. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (update_obj_pad (ex, mount_st, ostore_st, oaddr)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>8). HOL.Let (OstoreState.summary\<^sub>f_update (\<lambda>_. summary) ostore_st) (\<lambda>ostore_st. ((ex, ostore_st), (R.Success () :: (32 word, unit) R))))))))))))))))))) ds\<^sub>6)))))))))"

definition
  mount_recover :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<Rightarrow> ( SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T) \<times> (32 word, bool) R"
where
  "mount_recover ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (MountState.eb_recovery\<^sub>f mount_st) (\<lambda>eb_recovery. HOL.If ((=) eb_recovery (0 :: 32 word)) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. ((ex, mount_st, ostore_st), (R.Success True :: (32 word, bool) R)))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.used\<^sub>f) (\<lambda>(used,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 OstoreState.sync_offs\<^sub>f) (\<lambda>(sync_offs,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 OstoreState.wbuf\<^sub>f) (\<lambda>(wbuf,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 OstoreState.wbuf_eb\<^sub>f) (\<lambda>(ds\<^sub>9,ostore_st). Let\<^sub>d\<^sub>s ds\<^sub>9 (\<lambda>ds\<^sub>1\<^sub>0. HOL.Let (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) (\<lambda>eb_size. HOL.Let (Buffer.bound\<^sub>f_update (\<lambda>_. eb_size) wbuf) (\<lambda>wbuf. HOL.Let (MountState.eb_recovery\<^sub>f mount_st) (\<lambda>wbuf_eb. HOL.Let (MountState.eb_recovery_offs\<^sub>f mount_st) (\<lambda>offs. HOL.Let (OstoreState.wbuf_eb\<^sub>f_update (\<lambda>_. wbuf_eb) (OstoreState.sync_offs\<^sub>f_update (\<lambda>_. offs) (OstoreState.used\<^sub>f_update (\<lambda>_. offs) ostore_st))) (\<lambda>ostore_st. Let\<^sub>d\<^sub>s (wbuf_read_leb (ex, mount_st, OstoreState.ubi_vol\<^sub>f ostore_st, wbuf, wbuf_eb)) (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>2,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(wbuf,ds\<^sub>1\<^sub>6). case_R (\<lambda>err. ((ex, mount_st, OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) ostore_st), (R.Error err :: (32 word, bool) R))) (\<lambda>ds\<^sub>1\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>8 (\<lambda>ds\<^sub>1\<^sub>9. HOL.Let (eb_empty_pages_from (wbuf, used)) (\<lambda>has_empty_pages. HOL.If has_empty_pages (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t mount_st MountState.eb_recovery\<^sub>f) (\<lambda>(eb_recovery,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 MountState.eb_recovery_offs\<^sub>f) (\<lambda>(eb_recovery_offs,mount_st). HOL.Let (MountState.eb_recovery_offs\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (MountState.eb_recovery\<^sub>f_update (\<lambda>_. (0 :: 32 word)) mount_st)) (\<lambda>mount_st. ((ex, mount_st, OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) ostore_st), (R.Success False :: (32 word, bool) R))))))) (HOL.Let (OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) ostore_st) (\<lambda>ostore_st. HOL.Let (padding_to (mount_st, ostore_st, (0 :: 32 word))) (\<lambda>pad_to. Let\<^sub>d\<^sub>s (prepare_wbuf (ex, mount_st, ostore_st, pad_to)) (\<lambda>ds\<^sub>2\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>2,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>6). case_R (\<lambda>err. ((ex, mount_st, ostore_st), (R.Error err :: (32 word, bool) R))) (\<lambda>ds\<^sub>2\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>8 (\<lambda>ds\<^sub>2\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.ubi_vol\<^sub>f) (\<lambda>(ubi_vol,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 OstoreState.wbuf\<^sub>f) (\<lambda>(wbuf,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 OstoreState.used\<^sub>f) (\<lambda>(used,ostore_st). Let\<^sub>d\<^sub>s (wubi_leb_change (WubiLebChangeP.make ex ubi_vol wbuf_eb wbuf used)) (\<lambda>ds\<^sub>3\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>3,ds\<^sub>3\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P2_p2\<^sub>f) (\<lambda>(ubi_vol,ds\<^sub>3\<^sub>7). case_R (\<lambda>err. ((ex, mount_st, OstoreState.used\<^sub>f_update (\<lambda>_. used) (OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) (OstoreState.ubi_vol\<^sub>f_update (\<lambda>_. ubi_vol) ostore_st))), (R.Error err :: (32 word, bool) R))) (\<lambda>ds\<^sub>3\<^sub>9. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>9 (\<lambda>ds\<^sub>4\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t mount_st MountState.eb_recovery\<^sub>f) (\<lambda>(eb_recovery,ds\<^sub>4\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 MountState.eb_recovery_offs\<^sub>f) (\<lambda>(eb_recovery_offs,mount_st). HOL.Let (MountState.eb_recovery_offs\<^sub>f_update (\<lambda>_. (0 :: 32 word)) (MountState.eb_recovery\<^sub>f_update (\<lambda>_. (0 :: 32 word)) mount_st)) (\<lambda>mount_st. HOL.Let ((=) used (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st))) (\<lambda>allocneweb. ((ex, mount_st, OstoreState.sync_offs\<^sub>f_update (\<lambda>_. used) (OstoreState.used\<^sub>f_update (\<lambda>_. used) (OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) (OstoreState.ubi_vol\<^sub>f_update (\<lambda>_. ubi_vol) ostore_st)))), (R.Success allocneweb :: (32 word, bool) R)))))))) r)))))))))) r))))))))))) r)))))))))))))))))))))"

definition
  ostore_sync :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "ostore_sync ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(osw_flags,ds\<^sub>4). HOL.Let (OstoreState.sync_offs\<^sub>f ostore_st) (\<lambda>sync_offs. HOL.Let (OstoreState.used\<^sub>f ostore_st) (\<lambda>used. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>6. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>7. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>0. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>1. HOL.If ((=) sync_offs used \<and> HOL.Not (is_set (osw_flags, (4 :: 32 word)))) ((ex, ostore_st), (R.Success () :: (32 word, unit) R)) (HOL.Let (padding_to (mount_st, ostore_st, osw_flags)) (\<lambda>pad_to. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (prepare_wbuf (ex, mount_st, ostore_st, pad_to)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>2,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>6). case_R (\<lambda>e. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>8. ((ex, ostore_st), (R.Error e :: (32 word, unit) R)))) (\<lambda>ds\<^sub>1\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>8 (\<lambda>ds\<^sub>1\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_sync_summary_if_eb_new (ex, mount_st, ostore_st, osw_flags)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>0,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>4). Let\<^sub>d\<^sub>s (cogent_assert ((=) (align32 (OstoreState.used\<^sub>f ostore_st, ObjSuper.io_size\<^sub>f (MountState.super\<^sub>f mount_st))) (OstoreState.used\<^sub>f ostore_st))) (\<lambda>ds\<^sub>2\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>5 (\<lambda>ds\<^sub>2\<^sub>6. case_R (\<lambda>e. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>8. ((ex, ostore_st), (R.Error e :: (32 word, unit) R)))) (\<lambda>ds\<^sub>2\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>8 (\<lambda>ds\<^sub>2\<^sub>9. HOL.Let ((-) (OstoreState.used\<^sub>f ostore_st) sync_offs) (\<lambda>nb_bytes. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_write_buf (ex, mount_st, ostore_st, sync_offs, nb_bytes, osw_flags)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>0,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>4). case_R (\<lambda>e. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>3\<^sub>6. ((ex, ostore_st), (R.Error e :: (32 word, unit) R)))) (\<lambda>ds\<^sub>3\<^sub>6. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>6 (\<lambda>ds\<^sub>3\<^sub>7. HOL.Let (OstoreState.used\<^sub>f ostore_st) (\<lambda>used. HOL.Let (OstoreState.sync_offs\<^sub>f_update (\<lambda>_. used) ostore_st) (\<lambda>ostore_st. ((ex, ostore_st), (R.Success () :: (32 word, unit) R)))))) r))))))) r)))))))) r)))))))))))))))))))"

definition
  fsop_sync_fs :: " FsopFs'P\<^sub>T \<Rightarrow>  FsopFs'P\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_sync_fs ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopFsP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopFsP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>1). Let\<^sub>d\<^sub>s (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>ds\<^sub>3. HOL.If ds\<^sub>3 (FsopFsP.make ex fs_st, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.fsop_st\<^sub>f) (\<lambda>(fsop_st,fs_st). Let\<^sub>d\<^sub>s (ostore_sync (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, (0 :: 32 word))) (\<lambda>ds\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>0). case_R (\<lambda>err. (FsopFsP.make ex (FsState.fsop_st\<^sub>f_update (\<lambda>_. FsopState.is_ro\<^sub>f_update (\<lambda>_. (=) err (5 :: 32 word)) fsop_st) (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st)), (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>2. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>2 (\<lambda>ds\<^sub>1\<^sub>3. (FsopFsP.make ex (FsState.fsop_st\<^sub>f_update (\<lambda>_. fsop_st) (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st)), (R.Success () :: (32 word, unit) R)))) r)))))))))))"

definition
  ostore_sync_new_eb :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "ostore_sync_new_eb ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(osw_flags,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_sync (ex, mount_st, ostore_st, osw_flags)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>5,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>9). HOL.Let (OstoreState.used\<^sub>f ostore_st) (\<lambda>used. HOL.If ((=) used (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st))) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_new_wbuf (mount_st, ostore_st, osw_flags)) P2_p1\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>1). case_R (\<lambda>e. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>3. ((ex, ostore_st), (R.Error e :: (32 word, unit) R)))) (\<lambda>ds\<^sub>1\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>3 (\<lambda>ds\<^sub>1\<^sub>4. ((ex, ostore_st), (R.Success () :: (32 word, unit) R)))) r))) ((ex, ostore_st), (R.Success () :: (32 word, unit) R)))))))))))"

definition
  sync_if_trans_too_big :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 32 word \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "sync_if_trans_too_big ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p4\<^sub>f) (\<lambda>(osw_flags,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p5\<^sub>f) (\<lambda>(trans_size,ds\<^sub>5). HOL.Let (OstoreState.used\<^sub>f ostore_st) (\<lambda>used. HOL.Let (OstoreState.next_sqnum\<^sub>f ostore_st) (\<lambda>next_sqnum. HOL.If (MountState.no_summary\<^sub>f mount_st) (HOL.If ((>) trans_size (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>6. ((ex, ostore_st), (R.Error (22 :: 32 word) :: (32 word, unit) R)))) (HOL.If ((>) trans_size ((-) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) used) \<or> is_set (osw_flags, (16 :: 32 word))) (ostore_sync_new_eb (ex, mount_st, ostore_st, osw_flags)) ((ex, ostore_st), (R.Success () :: (32 word, unit) R)))) (HOL.Let (serialise_size_summary_Obj_with_extra (OstoreState.summary\<^sub>f ostore_st, (0 :: 32 word))) (\<lambda>sum_size. Let\<^sub>d\<^sub>s (cogent_assert ((<=) ((+) used sum_size) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)))) (\<lambda>ds\<^sub>7. HOL.If ((>) ((+) ((+) ((+) used trans_size) sum_size) (26 :: 32 word)) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st))) (ostore_sync_new_eb (ex, mount_st, ostore_st, (OR) osw_flags (4 :: 32 word))) (HOL.If (is_set (osw_flags, (16 :: 32 word))) (ostore_sync_new_eb (ex, mount_st, ostore_st, osw_flags)) ((ex, ostore_st), (R.Success () :: (32 word, unit) R)))))))))))))"

definition
  ostore_write_super :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<Rightarrow> ( SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "ostore_write_super ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). Let\<^sub>d\<^sub>s (ostore_sync (ex, mount_st, ostore_st, (0 :: 32 word))) (\<lambda>ds\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>5,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>9). case_R (\<lambda>err. ((ex, mount_st, ostore_st), (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>1 (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (OstoreState.next_sqnum\<^sub>f ostore_st) (\<lambda>next_sqnum. HOL.If ((<) ((+) next_sqnum (1 :: 64 word)) next_sqnum) ((ex, mount_st, ostore_st), (R.Error (75 :: 32 word) :: (32 word, unit) R)) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t mount_st MountState.super\<^sub>f) (\<lambda>(super,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 MountState.obj_sup\<^sub>f) (\<lambda>(obj,mount_st). HOL.Let (OstoreState.wbuf_eb\<^sub>f ostore_st) (\<lambda>cur_eb. HOL.Let (OstoreState.sync_offs\<^sub>f ostore_st) (\<lambda>cur_offs. HOL.Let ((-) (OstoreState.next_inum\<^sub>f ostore_st) (1 :: 32 word)) (\<lambda>last_inum. HOL.Let (ObjSuper.last_inum\<^sub>f_update (\<lambda>_. last_inum) (ObjSuper.next_sqnum\<^sub>f_update (\<lambda>_. (+) next_sqnum (1 :: 64 word)) (ObjSuper.cur_offs\<^sub>f_update (\<lambda>_. cur_offs) (ObjSuper.cur_eb\<^sub>f_update (\<lambda>_. cur_eb) super)))) (\<lambda>super. HOL.Let (OstoreState.sync_offs\<^sub>f_update (\<lambda>_. MountState.super_offs\<^sub>f mount_st) (OstoreState.used\<^sub>f_update (\<lambda>_. MountState.super_offs\<^sub>f mount_st) (OstoreState.wbuf_eb\<^sub>f_update (\<lambda>_. (0 :: 32 word)) ostore_st))) (\<lambda>ostore_st. HOL.Let (obj_init_super (obj, next_sqnum, MountState.super_offs\<^sub>f mount_st)) (\<lambda>obj. HOL.Let (OstoreState.next_sqnum\<^sub>f_update (\<lambda>_. (+) next_sqnum (1 :: 64 word)) ostore_st) (\<lambda>ostore_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.wbuf\<^sub>f) (\<lambda>(wbuf,ostore_st). Let\<^sub>d\<^sub>s (serialise_Obj_Super_crc (ex, wbuf, MountState.super_offs\<^sub>f mount_st, obj, super)) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P4_p2\<^sub>f) (\<lambda>(wbuf,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P4_p3\<^sub>f) (\<lambda>(used,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P4_p4\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>8). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>9. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>0. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>1. HOL.Let (OstoreState.used\<^sub>f_update (\<lambda>_. used) (OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) ostore_st)) (\<lambda>ostore_st. HOL.Let (MountState.obj_sup\<^sub>f_update (\<lambda>_. obj) (MountState.super\<^sub>f_update (\<lambda>_. super) mount_st)) (\<lambda>mount_st. HOL.Let (HOL.If ((=) (MountState.super_offs\<^sub>f mount_st) (0 :: 32 word)) (8 :: 32 word) (0 :: 32 word)) (\<lambda>oswf. Let\<^sub>d\<^sub>s (ostore_sync (ex, mount_st, ostore_st, oswf)) (\<lambda>ds\<^sub>2\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>3,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>7). HOL.Let (MountState.super_offs\<^sub>f_update (\<lambda>_. OstoreState.used\<^sub>f ostore_st) mount_st) (\<lambda>mount_st. case_R (\<lambda>err. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>9. ((ex, mount_st, ostore_st), (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>2\<^sub>9. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>9 (\<lambda>ds\<^sub>3\<^sub>0. ((ex, mount_st, ostore_st), (R.Success () :: (32 word, unit) R)))) r))))))))))))))))))))))))))))))) r))))))))"

definition
  ostore_umount :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<Rightarrow> ( SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "ostore_umount ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (OstoreState.next_sqnum\<^sub>f ostore_st) (\<lambda>sqnum. HOL.Let (ObjSuper.next_sqnum\<^sub>f (MountState.super\<^sub>f mount_st)) (\<lambda>sup_sqnum. HOL.If ((<) sup_sqnum sqnum) (Let\<^sub>d\<^sub>s (ostore_sync (ex, mount_st, ostore_st, (4 :: 32 word))) (\<lambda>ds\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>5,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>9). case_R (\<lambda>err. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>1. ((ex, mount_st, ostore_st), (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>1\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>1 (\<lambda>ds\<^sub>1\<^sub>2. ostore_write_super (ex, mount_st, ostore_st))) r)))))) ((ex, mount_st, ostore_st), (R.Success () :: (32 word, unit) R)))))))"

definition
  fsop_unmount :: " FsopFs'P\<^sub>T \<Rightarrow>  FsopFs'P\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_unmount ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopFsP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopFsP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>1). HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.If is_ro (FsopFsP.make ex fs_st, (R.Success () :: (32 word, unit) R)) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsState.mount_st\<^sub>f) (\<lambda>(mount_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_umount (ex, mount_st, ostore_st)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>9). case_R (\<lambda>err. (FsopFsP.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) fs_st)), (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>1 (\<lambda>ds\<^sub>1\<^sub>2. (FsopFsP.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) fs_st)), (R.Success () :: (32 word, unit) R)))) r)))))))))))"

definition
  sync_if_no_trans_fit :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "sync_if_no_trans_fit ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(osw_flags,ds\<^sub>4). HOL.Let (OstoreState.used\<^sub>f ostore_st) (\<lambda>used. HOL.Let ((+) (24 :: 32 word) (8 :: 32 word)) (\<lambda>min_useful_trans. HOL.If (MountState.no_summary\<^sub>f mount_st) (HOL.If ((>) ((+) used min_useful_trans) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st))) (ostore_sync (ex, mount_st, ostore_st, (OR) osw_flags (4 :: 32 word))) (HOL.If (is_set (osw_flags, (16 :: 32 word))) (ostore_sync (ex, mount_st, ostore_st, osw_flags)) ((ex, ostore_st), (R.Success () :: (32 word, unit) R)))) (HOL.Let (serialise_size_summary_Obj_with_extra (OstoreState.summary\<^sub>f ostore_st, (0 :: 32 word))) (\<lambda>sum_size. Let\<^sub>d\<^sub>s (cogent_assert ((<=) ((+) used sum_size) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)))) (\<lambda>ds\<^sub>5. HOL.If ((>) ((+) ((+) used min_useful_trans) sum_size) (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st))) (ostore_sync (ex, mount_st, ostore_st, (OR) osw_flags (4 :: 32 word))) (HOL.If (is_set (osw_flags, (16 :: 32 word))) (ostore_sync (ex, mount_st, ostore_st, osw_flags)) ((ex, ostore_st), (R.Success () :: (32 word, unit) R))))))))))))"

definition
  fsm_set_garbage :: " SysState \<times>  MountState\<^sub>T \<times>  FsmState\<^sub>T \<times> (64 word,  GimNode\<^sub>T) RbtNode AllocPool \<times> 64 word \<times> 64 word \<times> 16 word \<Rightarrow>  SysState \<times>  FsmState\<^sub>T \<times> (64 word,  GimNode\<^sub>T) RbtNode AllocPool"
where
  "fsm_set_garbage ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P7_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P7_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P7_p3\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P7_p4\<^sub>f) (\<lambda>(gimpool,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P7_p5\<^sub>f) (\<lambda>(oid,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P7_p6\<^sub>f) (\<lambda>(sqnum,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P7_p7\<^sub>f) (\<lambda>(count,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fsm_st FsmState.gim\<^sub>f) (\<lambda>(gim,fsm_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (allocpool_use (AllocPoolUseP.make gimpool fsm_mark_dirty_use (ex, gim) (oid, sqnum, count))) P2_p1\<^sub>f) (\<lambda>(gimpool,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(gim,ds\<^sub>1\<^sub>2). (ex, FsmState.gim\<^sub>f_update (\<lambda>_. gim) fsm_st, gimpool)))))))))))))"

definition
  update_obj_modifier :: "((64 word,  ObjAddr\<^sub>T) RbtNode, (64 word,  GimNode\<^sub>T) RbtNode AllocPool \<times>  FsmState\<^sub>T \<times>  SysState,  MountState\<^sub>T \<times> 64 word \<times>  ObjAddr\<^sub>T) ElemAO \<Rightarrow> (64 word,  ObjAddr\<^sub>T) RbtNode \<times> (64 word,  GimNode\<^sub>T) RbtNode AllocPool \<times>  FsmState\<^sub>T \<times>  SysState"
where
  "update_obj_modifier ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(oldnode,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P3_p1\<^sub>f) (\<lambda>(gimpool,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P3_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P3_p3\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P3_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p2\<^sub>f) (\<lambda>(oid,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P3_p3\<^sub>f) (\<lambda>(oaddr,ds\<^sub>1\<^sub>1). HOL.Let (rbtnode_get_val oldnode) (\<lambda>val. HOL.Let (ObjAddr.sqnum\<^sub>f val) (\<lambda>oldsqnum. HOL.If ((<) oldsqnum (ObjAddr.sqnum\<^sub>f oaddr)) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsm_mark_dirty (ex, mount_st, fsm_st, gimpool, oid, oaddr)) P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p3\<^sub>f) (\<lambda>(gimpool,ds\<^sub>1\<^sub>5). HOL.Let (set_node (oldnode, oid, oaddr)) (\<lambda>oldnode. (oldnode, (gimpool, fsm_st, ex)))))))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>3. (oldnode, (gimpool, fsm_st, ex)))))))))))))))"

definition
  update_obj_use :: "((64 word,  ObjAddr\<^sub>T) RbtNode, (64 word,  ObjAddr\<^sub>T) Rbt \<times> (64 word,  GimNode\<^sub>T) RbtNode AllocPool \<times>  FsmState\<^sub>T \<times>  SysState,  MountState\<^sub>T \<times> 64 word \<times>  ObjAddr\<^sub>T) ElemAO \<Rightarrow> (64 word,  ObjAddr\<^sub>T) Rbt \<times> (64 word,  GimNode\<^sub>T) RbtNode AllocPool \<times>  FsmState\<^sub>T \<times>  SysState"
where
  "update_obj_use ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(node,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P4_p1\<^sub>f) (\<lambda>(addrs,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P4_p2\<^sub>f) (\<lambda>(gimpool,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P4_p3\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P4_p4\<^sub>f) (\<lambda>(ex,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>9,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P3_p2\<^sub>f) (\<lambda>(oid,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P3_p3\<^sub>f) (\<lambda>(oaddr,ds\<^sub>1\<^sub>2). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (rbtnode_put_val (node, ObjAddr.make (0 :: 32 word) (0 :: 32 word) (0 :: 32 word) (0 :: 64 word))) (\<lambda>node. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (rbt_modify (RbtModifyP.make addrs oid update_obj_modifier node (gimpool, fsm_st, ex) (mount_st, oid, oaddr))) RbtModifyR.rbt\<^sub>f) (\<lambda>(addrs,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 RbtModifyR.optnode\<^sub>f) (\<lambda>(optnode,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 RbtModifyR.acc\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>7,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p1\<^sub>f) (\<lambda>(gimpool,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P3_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P3_p3\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>0). HOL.Let (freeOptRbtNode (ex, optnode)) (\<lambda>ex. (addrs, gimpool, fsm_st, ex))))))))))))))))))))"

definition
  update_obj :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times> 64 word \<times>  ObjAddr\<^sub>T \<Rightarrow>  SysState \<times>  OstoreState\<^sub>T"
where
  "update_obj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p3\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p4\<^sub>f) (\<lambda>(oid,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P5_p5\<^sub>f) (\<lambda>(oaddr,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.index_st\<^sub>f) (\<lambda>(index_st,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 OstoreState.fsm_st\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 OstoreState.pools\<^sub>f) (\<lambda>(pools,ostore_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t index_st IndexState.addrs\<^sub>f) (\<lambda>(addrs,index_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t pools AllocPools.idx\<^sub>f) (\<lambda>(idx,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 AllocPools.gim\<^sub>f) (\<lambda>(gim,pools). Let\<^sub>d\<^sub>s (allocpool_use (AllocPoolUseP.make idx update_obj_use (addrs, gim, fsm_st, ex) (mount_st, oid, oaddr))) (\<lambda>ds\<^sub>1\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p1\<^sub>f) (\<lambda>(idx,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>1,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P4_p1\<^sub>f) (\<lambda>(addrs,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P4_p2\<^sub>f) (\<lambda>(gim,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P4_p3\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P4_p4\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (AllocPools.gim\<^sub>f_update (\<lambda>_. gim) (AllocPools.idx\<^sub>f_update (\<lambda>_. idx) pools)) (\<lambda>pools. HOL.Let (IndexState.addrs\<^sub>f_update (\<lambda>_. addrs) index_st) (\<lambda>index_st. HOL.Let (OstoreState.pools\<^sub>f_update (\<lambda>_. pools) (OstoreState.fsm_st\<^sub>f_update (\<lambda>_. fsm_st) (OstoreState.index_st\<^sub>f_update (\<lambda>_. index_st) ostore_st))) (\<lambda>ostore_st. (ex, OstoreState.oaddr\<^sub>f_update (\<lambda>_. oaddr) ostore_st))))))))))))))))))))))"

definition
  proc_obj :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  Obj\<^sub>T \<times> 32 word \<Rightarrow>  SysState \<times>  OstoreState\<^sub>T"
where
  "proc_obj ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p3\<^sub>f) (\<lambda>(ds\<^sub>1,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p4\<^sub>f) (\<lambda>(obj,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P5_p5\<^sub>f) (\<lambda>(ebnum,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 OstoreState.oaddr\<^sub>f) (\<lambda>(oaddr,ostore_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t oaddr ObjAddr.ebnum\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>7). Let\<^sub>d\<^sub>s ds\<^sub>8 (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 ObjAddr.sqnum\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>1,ds\<^sub>1\<^sub>0). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>1 (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 ObjAddr.offs\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>4,ds\<^sub>1\<^sub>3). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>4 (\<lambda>ds\<^sub>1\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 ObjAddr.len\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>6,oaddr). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>6 (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (ObjAddr.len\<^sub>f_update (\<lambda>_. Obj.len\<^sub>f obj) (ObjAddr.offs\<^sub>f_update (\<lambda>_. Obj.offs\<^sub>f obj) (ObjAddr.sqnum\<^sub>f_update (\<lambda>_. Obj.sqnum\<^sub>f obj) (ObjAddr.ebnum\<^sub>f_update (\<lambda>_. ebnum) oaddr)))) (\<lambda>oaddr. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>8. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>9. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>0. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>1. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>2. Let\<^sub>d\<^sub>s (trimObjSuper (Obj.ounion\<^sub>f obj)) (\<lambda>ds\<^sub>2\<^sub>3. HOL.Let (\<lambda>ds\<^sub>2\<^sub>4. HOL.Let (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (\<lambda>ds\<^sub>2\<^sub>6. HOL.Let (\<lambda>ds\<^sub>2\<^sub>7. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>7 (\<lambda>ds\<^sub>2\<^sub>8. update_obj_pad (ex, mount_st, ostore_st, oaddr))) (\<lambda>ccase\<^sub>G\<^sub>1. case_ObjUnion (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjData v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v. delete_obj (ex, mount_st, ostore_st, ObjDel.id\<^sub>f v, oaddr)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjDentarr v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjInode v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjPad v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjSummary v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjSuper v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) ds\<^sub>2\<^sub>6)) (\<lambda>ccase\<^sub>G\<^sub>3. case_ObjUnion (\<lambda>v. update_obj (ex, mount_st, ostore_st, ObjData.id\<^sub>f v, oaddr)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjDel v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjDentarr v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjInode v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjPad v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjSummary v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>2. ccase\<^sub>G\<^sub>3 (ObjUnion.TObjSuper v\<^sub>G\<^sub>2 ::  ObjUnion\<^sub>T)) ds\<^sub>2\<^sub>5)) (\<lambda>ccase\<^sub>G\<^sub>5. case_ObjUnion (\<lambda>v\<^sub>G\<^sub>4. ccase\<^sub>G\<^sub>5 (ObjUnion.TObjData v\<^sub>G\<^sub>4 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>4. ccase\<^sub>G\<^sub>5 (ObjUnion.TObjDel v\<^sub>G\<^sub>4 ::  ObjUnion\<^sub>T)) (\<lambda>v. update_obj (ex, mount_st, ostore_st, ObjDentarr.id\<^sub>f v, oaddr)) (\<lambda>v\<^sub>G\<^sub>4. ccase\<^sub>G\<^sub>5 (ObjUnion.TObjInode v\<^sub>G\<^sub>4 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>4. ccase\<^sub>G\<^sub>5 (ObjUnion.TObjPad v\<^sub>G\<^sub>4 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>4. ccase\<^sub>G\<^sub>5 (ObjUnion.TObjSummary v\<^sub>G\<^sub>4 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>4. ccase\<^sub>G\<^sub>5 (ObjUnion.TObjSuper v\<^sub>G\<^sub>4 ::  ObjUnion\<^sub>T)) ds\<^sub>2\<^sub>4)) (\<lambda>ccase\<^sub>G\<^sub>7. case_ObjUnion (\<lambda>v\<^sub>G\<^sub>6. ccase\<^sub>G\<^sub>7 (ObjUnion.TObjData v\<^sub>G\<^sub>6 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>6. ccase\<^sub>G\<^sub>7 (ObjUnion.TObjDel v\<^sub>G\<^sub>6 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>6. ccase\<^sub>G\<^sub>7 (ObjUnion.TObjDentarr v\<^sub>G\<^sub>6 ::  ObjUnion\<^sub>T)) (\<lambda>v. update_obj (ex, mount_st, ostore_st, ObjInode.id\<^sub>f v, oaddr)) (\<lambda>v\<^sub>G\<^sub>6. ccase\<^sub>G\<^sub>7 (ObjUnion.TObjPad v\<^sub>G\<^sub>6 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>6. ccase\<^sub>G\<^sub>7 (ObjUnion.TObjSummary v\<^sub>G\<^sub>6 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>6. ccase\<^sub>G\<^sub>7 (ObjUnion.TObjSuper v\<^sub>G\<^sub>6 ::  ObjUnion\<^sub>T)) ds\<^sub>2\<^sub>3))))))))))))))))))))))"

definition
  ostore_update_loop_body :: "( Obj\<^sub>T,  SysState \<times>  OstoreState\<^sub>T,  MountState\<^sub>T) ElemAO \<Rightarrow>  SysState \<times>  OstoreState\<^sub>T"
where
  "ostore_update_loop_body ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(obj,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(mount_st,ds\<^sub>1). HOL.Let (OstoreState.wbuf_eb\<^sub>f ostore_st) (\<lambda>eb. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.summary\<^sub>f) (\<lambda>(summary,ostore_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (proc_obj (ex, mount_st, ostore_st, obj, eb)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (proc_obj_sum (ex, mount_st, OstoreState.summary\<^sub>f_update (\<lambda>_. summary) ostore_st, obj)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>0). (ex, ostore_st))))))))))))"

definition
  ostore_update :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  Obj\<^sub>T Array \<Rightarrow>  SysState \<times>  OstoreState\<^sub>T"
where
  "ostore_update ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p4\<^sub>f) (\<lambda>(arr,ds\<^sub>4). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. array_fold_no_break (ArrayFoldP.make arr ostore_update_loop_body (ex, ostore_st) mount_st))))))"

definition
  ostore_write :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  Obj\<^sub>T Array \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T \<times>  Obj\<^sub>T Array) \<times> (32 word, unit) R"
where
  "ostore_write ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p4\<^sub>f) (\<lambda>(arr,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p5\<^sub>f) (\<lambda>(osw_flags,ds\<^sub>5). HOL.Let (OstoreState.next_sqnum\<^sub>f ostore_st) (\<lambda>next_sqnum. HOL.Let (ostore_get_trans_size arr) (\<lambda>trans_size. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (sync_if_trans_too_big (ex, mount_st, ostore_st, osw_flags, trans_size)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>6,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>0). case_R (\<lambda>e. ((ex, ostore_st, arr), (R.Error e :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>2. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>2 (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.wbuf\<^sub>f) (\<lambda>(wbuf,ostore_st). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>4. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>5. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>6. Let\<^sub>d\<^sub>s (write_objects (wbuf, OstoreState.used\<^sub>f ostore_st, next_sqnum, arr)) (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>8,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P3_p1\<^sub>f) (\<lambda>(wbuf,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P3_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P3_p3\<^sub>f) (\<lambda>(used,ds\<^sub>2\<^sub>3). case_R (\<lambda>ds\<^sub>2\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>4 (\<lambda>ds\<^sub>2\<^sub>6. ((ex, OstoreState.next_sqnum\<^sub>f_update (\<lambda>_. next_sqnum) (OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) ostore_st), arr), (R.Error used :: (32 word, unit) R)))) (\<lambda>sqnum. HOL.Let (OstoreState.wbuf\<^sub>f_update (\<lambda>_. wbuf) ostore_st) (\<lambda>ostore_st. Let\<^sub>d\<^sub>s (ostore_alloc_pools (ex, ostore_st, array_nb_elem arr)) (\<lambda>ds\<^sub>2\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>7,ds\<^sub>2\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>1). case_R (\<lambda>e. ((ex, OstoreState.next_sqnum\<^sub>f_update (\<lambda>_. next_sqnum) ostore_st, arr), (R.Error e :: (32 word, unit) R))) (\<lambda>ds\<^sub>3\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>3 (\<lambda>ds\<^sub>3\<^sub>4. HOL.Let (OstoreState.next_sqnum\<^sub>f_update (\<lambda>_. sqnum) ostore_st) (\<lambda>ostore_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (sync_if_no_trans_fit (ex, mount_st, ostore_st, osw_flags)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>5,ds\<^sub>3\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>8 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>9). case_R (\<lambda>e. ((ex, OstoreState.next_sqnum\<^sub>f_update (\<lambda>_. next_sqnum) ostore_st, arr), (R.Error e :: (32 word, unit) R))) (\<lambda>ds\<^sub>4\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>1 (\<lambda>ds\<^sub>4\<^sub>2. Let\<^sub>d\<^sub>s (ostore_update (ex, mount_st, ostore_st, arr)) (\<lambda>ds\<^sub>4\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>4 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.used\<^sub>f) (\<lambda>(ds\<^sub>4\<^sub>6,ostore_st). Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>6 (\<lambda>ds\<^sub>4\<^sub>7. HOL.Let (OstoreState.used\<^sub>f_update (\<lambda>_. used) ostore_st) (\<lambda>ostore_st. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_free_pools (ex, ostore_st)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>9 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>5\<^sub>0). ((ex, ostore_st, arr), (R.Success () :: (32 word, unit) R))))))))))))) r))))))) r))))))) r)))))))))))) r)))))))))))"

definition
  fsop_create :: " FsopCreateP\<^sub>T \<Rightarrow>  FsopRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_create ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopCreateP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopCreateP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopCreateP.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopCreateP.name\<^sub>f) (\<lambda>(name,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopCreateP.mode\<^sub>f) (\<lambda>(mode,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 FsopCreateP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1). HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.If is_ro (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (Let\<^sub>d\<^sub>s (init_vnode (ex, ostore_st, vdir, vnode, (OR) mode (32768 :: 32 word))) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>9,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p3\<^sub>f) (\<lambda>(vnode,ds\<^sub>1\<^sub>4). case_R (\<lambda>err. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>5 (\<lambda>ds\<^sub>1\<^sub>7. Let\<^sub>d\<^sub>s (dentarr_read_and_add (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, vdir, name, vnode, (0 :: 8 word))) (\<lambda>ds\<^sub>1\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>9,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>3). case_R (\<lambda>err. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>2\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p1\<^sub>f) (\<lambda>(new_v_size,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(dentarr_obj,ds\<^sub>2\<^sub>7). Let\<^sub>d\<^sub>s (obj_inode_new (ex, vnode)) (\<lambda>ds\<^sub>2\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>0). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>inode. HOL.Let (vfs_inode_get_size vdir) (\<lambda>v_size'. HOL.Let (vfs_inode_get_mtime vdir) (\<lambda>v_mtime'. HOL.Let (vfs_inode_get_ctime vdir) (\<lambda>v_ctime'. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>3\<^sub>3). HOL.Let (vfs_inode_set_size (vdir, new_v_size)) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, time)) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, time)) (\<lambda>vdir. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vdir)) (\<lambda>ds\<^sub>3\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>6). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, inode)) (\<lambda>ex. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R)))))))) (\<lambda>dir. Let\<^sub>d\<^sub>s (arrayobj_create3 (ex, dentarr_obj, inode, dir)) (\<lambda>ds\<^sub>3\<^sub>8. case_R (\<lambda>ex. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R)))))) (\<lambda>ds\<^sub>3\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>4\<^sub>2). Let\<^sub>d\<^sub>s (ostore_write (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, arr, (0 :: 32 word))) (\<lambda>ds\<^sub>4\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>4\<^sub>4,ds\<^sub>4\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>4\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>4 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>7 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>8 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>4\<^sub>9). case_R (\<lambda>err. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>5\<^sub>0. Let\<^sub>d\<^sub>s ds\<^sub>5\<^sub>0 (\<lambda>ds\<^sub>5\<^sub>2. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Success () :: (32 word, unit) R))))) r))))))))) ds\<^sub>3\<^sub>8)) r)))))))))))) r)))))) r))))))) r)))))))))))))))"

definition
  fsop_do_move_helper :: " FsopDoMoveHelperP\<^sub>T \<Rightarrow>  FsopDoMoveHelperRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_do_move_helper ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopDoMoveHelperP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopDoMoveHelperP.mount_st\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopDoMoveHelperP.ostore_st\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopDoMoveHelperP.old_dent_size\<^sub>f) (\<lambda>(old_dent_size,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopDoMoveHelperP.new_dent_size\<^sub>f) (\<lambda>(new_dent_size,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopDoMoveHelperP.new_o\<^sub>f) (\<lambda>(new_o,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 FsopDoMoveHelperP.old_o\<^sub>f) (\<lambda>(old_o,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 FsopDoMoveHelperP.old_vdir\<^sub>f) (\<lambda>(old_vdir,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 FsopDoMoveHelperP.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 FsopDoMoveHelperP.new_vdir\<^sub>f) (\<lambda>(new_vdir,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 FsopDoMoveHelperP.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (serialise_size_Obj old_o) (\<lambda>old_dent_size'. HOL.Let (Obj.len\<^sub>f_update (\<lambda>_. old_dent_size') old_o) (\<lambda>old_o. HOL.Let (vfs_inode_get_size old_vdir) (\<lambda>old_vdir_size. HOL.Let (vfs_inode_set_size (old_vdir, (+) ((-) old_vdir_size (ucast old_dent_size :: 64 word)) (ucast old_dent_size' :: 64 word))) (\<lambda>old_vdir. HOL.Let (serialise_size_Obj new_o) (\<lambda>new_dent_size'. HOL.Let (Obj.len\<^sub>f_update (\<lambda>_. new_dent_size') new_o) (\<lambda>new_o. HOL.Let (vfs_inode_get_size new_vdir) (\<lambda>new_vdir_size. HOL.Let (vfs_inode_set_size (new_vdir, (+) ((-) new_vdir_size (ucast new_dent_size :: 64 word)) (ucast new_dent_size' :: 64 word))) (\<lambda>new_vdir. Let\<^sub>d\<^sub>s (obj_inode_new (ex, old_vnode)) (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>5). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. (FsopDoMoveHelperRR.make ex ostore_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Error err :: (32 word, unit) R))))) (\<lambda>obj_old_vnode. Let\<^sub>d\<^sub>s (obj_inode_new (ex, old_vdir)) (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>9). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, obj_old_vnode)) (\<lambda>ex. (FsopDoMoveHelperRR.make ex ostore_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Error err :: (32 word, unit) R)))))) (\<lambda>obj_old_vdir. Let\<^sub>d\<^sub>s (obj_inode_new (ex, new_vdir)) (\<lambda>ds\<^sub>2\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>3). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, obj_old_vnode)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, obj_old_vdir)) (\<lambda>ex. (FsopDoMoveHelperRR.make ex ostore_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Error err :: (32 word, unit) R))))))) (\<lambda>obj_new_vdir. case_Option (\<lambda>ds\<^sub>2\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>5 (\<lambda>ds\<^sub>2\<^sub>7. HOL.Let (Option.None () :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. Let\<^sub>d\<^sub>s (arrayobj_create5 (ex, old_o, obj_old_vdir, obj_old_vnode, new_o, obj_new_vdir)) (\<lambda>ds\<^sub>2\<^sub>8. case_R (\<lambda>ex. (FsopDoMoveHelperRR.make ex ostore_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R))) (\<lambda>ds\<^sub>3\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_write (ex, mount_st, ostore_st, arr, (0 :: 32 word))) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>3,ds\<^sub>3\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>8). case_R (\<lambda>err. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopDoMoveHelperRR.make ex ostore_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>4\<^sub>0. Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>0 (\<lambda>ds\<^sub>4\<^sub>1. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopDoMoveHelperRR.make ex ostore_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Success () :: (32 word, unit) R))))) r)))))))) ds\<^sub>2\<^sub>8)))) (\<lambda>new_vnode. Let\<^sub>d\<^sub>s (obj_inode_new (ex, new_vnode)) (\<lambda>ds\<^sub>2\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>9). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, obj_old_vnode)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, obj_old_vdir)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, obj_new_vdir)) (\<lambda>ex. (FsopDoMoveHelperRR.make ex ostore_st old_vdir old_vnode new_vdir (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option), (R.Error err :: (32 word, unit) R)))))))) (\<lambda>obj_new_vnode. HOL.Let (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. Let\<^sub>d\<^sub>s (arrayobj_create6 (ex, old_o, obj_old_vdir, obj_old_vnode, new_o, obj_new_vdir, obj_new_vnode)) (\<lambda>ds\<^sub>3\<^sub>1. case_R (\<lambda>ex. (FsopDoMoveHelperRR.make ex ostore_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R))) (\<lambda>ds\<^sub>3\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_write (ex, mount_st, ostore_st, arr, (0 :: 32 word))) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>6,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>9 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>0 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>4\<^sub>1). case_R (\<lambda>err. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopDoMoveHelperRR.make ex ostore_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>4\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>3 (\<lambda>ds\<^sub>4\<^sub>4. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopDoMoveHelperRR.make ex ostore_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Success () :: (32 word, unit) R))))) r)))))))) ds\<^sub>3\<^sub>1))) r)))) opt_new_vnode) r)))) r)))) r)))))))))))))))))))))))"

definition
  fsop_do_move :: " FsopDoMoveP\<^sub>T \<Rightarrow>  FsopDoMoveRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_do_move ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopDoMoveP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopDoMoveP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopDoMoveP.old_vdir\<^sub>f) (\<lambda>(old_vdir,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopDoMoveP.old_name\<^sub>f) (\<lambda>(old_name,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopDoMoveP.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 FsopDoMoveP.new_vdir\<^sub>f) (\<lambda>(new_vdir,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 FsopDoMoveP.new_name\<^sub>f) (\<lambda>(new_name,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. Let\<^sub>d\<^sub>s (move_read_or_create_dentarrs (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, old_vdir, new_vdir, old_name, new_name)) (\<lambda>ds\<^sub>1\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>1,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>5). case_R (\<lambda>err. (FsopDoMoveRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) old_vdir old_vnode new_vdir, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P6_p1\<^sub>f) (\<lambda>(old_o,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P6_p2\<^sub>f) (\<lambda>(new_o,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P6_p3\<^sub>f) (\<lambda>(old_dent,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P6_p4\<^sub>f) (\<lambda>(new_dent,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P6_p5\<^sub>f) (\<lambda>(old_dent_size,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P6_p6\<^sub>f) (\<lambda>(new_dent_size,ds\<^sub>2\<^sub>3). HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_del_dentry (ex, old_dent, old_name)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p2\<^sub>f) (\<lambda>(old_dent,ds\<^sub>2\<^sub>5). HOL.Let (vtype_to_dtype (vmode_to_vtype (vfs_inode_get_mode old_vnode))) (\<lambda>dtype. Let\<^sub>d\<^sub>s (dentarr_add_dentry (ex, new_dent, old_vnode, new_name, dtype)) (\<lambda>ds\<^sub>2\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>7,ds\<^sub>2\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P2_p2\<^sub>f) (\<lambda>(new_dent,ds\<^sub>3\<^sub>1). case_R (\<lambda>err. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr old_dent ::  ObjUnion\<^sub>T)) old_o) (\<lambda>old_o. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr new_dent ::  ObjUnion\<^sub>T)) new_o) (\<lambda>new_o. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. (FsopDoMoveRR.make ex fs_st old_vdir old_vnode new_vdir, (R.Error err :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>3\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>3 (\<lambda>ds\<^sub>3\<^sub>4. Let\<^sub>d\<^sub>s (obj_dentarr_or_del_new (ex, old_o, old_dent)) (\<lambda>ds\<^sub>3\<^sub>5. case_R (\<lambda>ds\<^sub>3\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>3\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>8 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>9). HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr new_dent ::  ObjUnion\<^sub>T)) new_o) (\<lambda>new_o. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. (FsopDoMoveRR.make ex fs_st old_vdir old_vnode new_vdir, (R.Error err :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>3\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>9 P2_p2\<^sub>f) (\<lambda>(old_o,ds\<^sub>4\<^sub>0). HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr new_dent ::  ObjUnion\<^sub>T)) new_o) (\<lambda>new_o. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (Option.None () :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. Let\<^sub>d\<^sub>s (fsop_do_move_helper (FsopDoMoveHelperP.make ex (FsState.mount_st\<^sub>f fs_st) ostore_st old_dent_size new_dent_size new_o old_o old_vdir old_vnode new_vdir opt_new_vnode)) (\<lambda>ds\<^sub>4\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>4\<^sub>2,ds\<^sub>4\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>4\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>2 FsopDoMoveHelperRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>6 FsopDoMoveHelperRR.ostore_st\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>7 FsopDoMoveHelperRR.old_vdir\<^sub>f) (\<lambda>(old_vdir,ds\<^sub>4\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>8 FsopDoMoveHelperRR.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>4\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>9 FsopDoMoveHelperRR.new_vdir\<^sub>f) (\<lambda>(new_vdir,ds\<^sub>5\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>0 FsopDoMoveHelperRR.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>4\<^sub>5). case_R (\<lambda>err. HOL.Let (free_opt_VfsInode (ex, opt_new_vnode)) (\<lambda>ex. (FsopDoMoveRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) old_vdir old_vnode new_vdir, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>5\<^sub>2. Let\<^sub>d\<^sub>s ds\<^sub>5\<^sub>2 (\<lambda>ds\<^sub>5\<^sub>3. HOL.Let (free_opt_VfsInode (ex, opt_new_vnode)) (\<lambda>ex. (FsopDoMoveRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) old_vdir old_vnode new_vdir, (R.Success () :: (32 word, unit) R))))) r))))))))))))))) ds\<^sub>3\<^sub>5))) r)))))))))))))))) r))))))))))))))"

definition
  fsop_do_move_del :: " FsopDoMoveDelP\<^sub>T \<Rightarrow>  FsopMoveRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_do_move_del ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopDoMoveDelP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopDoMoveDelP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopDoMoveDelP.old_vdir\<^sub>f) (\<lambda>(old_vdir,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopDoMoveDelP.old_name\<^sub>f) (\<lambda>(old_name,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopDoMoveDelP.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 FsopDoMoveDelP.new_vdir\<^sub>f) (\<lambda>(new_vdir,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 FsopDoMoveDelP.new_name\<^sub>f) (\<lambda>(new_name,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 FsopDoMoveDelP.new_vnode\<^sub>f) (\<lambda>(new_vnode,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>0. HOL.Let (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. Let\<^sub>d\<^sub>s (move_read_or_create_dentarrs (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, old_vdir, new_vdir, old_name, new_name)) (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>2,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>6). case_R (\<lambda>err. (FsopMoveRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) old_vdir old_vnode new_vdir opt_new_vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P6_p1\<^sub>f) (\<lambda>(old_o,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P6_p2\<^sub>f) (\<lambda>(new_o,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P6_p3\<^sub>f) (\<lambda>(old_dent,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P6_p4\<^sub>f) (\<lambda>(new_dent,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P6_p5\<^sub>f) (\<lambda>(old_dent_size,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P6_p6\<^sub>f) (\<lambda>(new_dent_size,ds\<^sub>2\<^sub>4). HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_del_dentry (ex, old_dent, old_name)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p2\<^sub>f) (\<lambda>(old_dent,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_del_dentry (ex, new_dent, new_name)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P2_p2\<^sub>f) (\<lambda>(new_dent,ds\<^sub>2\<^sub>8). HOL.Let (vtype_to_dtype (vmode_to_vtype (vfs_inode_get_mode old_vnode))) (\<lambda>dtype. Let\<^sub>d\<^sub>s (dentarr_add_dentry (ex, new_dent, old_vnode, new_name, dtype)) (\<lambda>ds\<^sub>2\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>0,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P2_p2\<^sub>f) (\<lambda>(new_dent,ds\<^sub>3\<^sub>4). case_R (\<lambda>err. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr old_dent ::  ObjUnion\<^sub>T)) old_o) (\<lambda>old_o. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr new_dent ::  ObjUnion\<^sub>T)) new_o) (\<lambda>new_o. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. (FsopMoveRR.make ex fs_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Error err :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>3\<^sub>6. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>6 (\<lambda>ds\<^sub>3\<^sub>7. Let\<^sub>d\<^sub>s (obj_dentarr_or_del_new (ex, old_o, old_dent)) (\<lambda>ds\<^sub>3\<^sub>8. case_R (\<lambda>ds\<^sub>3\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>9 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>4\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>2). HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr new_dent ::  ObjUnion\<^sub>T)) new_o) (\<lambda>new_o. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. (FsopMoveRR.make ex fs_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Error err :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>4\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>2 P2_p2\<^sub>f) (\<lambda>(old_o,ds\<^sub>4\<^sub>3). HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr new_dent ::  ObjUnion\<^sub>T)) new_o) (\<lambda>new_o. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). Let\<^sub>d\<^sub>s (fsop_do_move_helper (FsopDoMoveHelperP.make ex (FsState.mount_st\<^sub>f fs_st) ostore_st old_dent_size new_dent_size new_o old_o old_vdir old_vnode new_vdir opt_new_vnode)) (\<lambda>ds\<^sub>4\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>4\<^sub>5,ds\<^sub>4\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>4\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>5 FsopDoMoveHelperRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>9 FsopDoMoveHelperRR.ostore_st\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>5\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>0 FsopDoMoveHelperRR.old_vdir\<^sub>f) (\<lambda>(old_vdir,ds\<^sub>5\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>1 FsopDoMoveHelperRR.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>5\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>2 FsopDoMoveHelperRR.new_vdir\<^sub>f) (\<lambda>(new_vdir,ds\<^sub>5\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>3 FsopDoMoveHelperRR.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>4\<^sub>8). case_R (\<lambda>err. (FsopMoveRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) old_vdir old_vnode new_vdir opt_new_vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>5\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>5\<^sub>5 (\<lambda>ds\<^sub>5\<^sub>6. (FsopMoveRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) old_vdir old_vnode new_vdir opt_new_vnode, (R.Success () :: (32 word, unit) R)))) r)))))))))))))) ds\<^sub>3\<^sub>8))) r)))))))))))))))))) r))))))))))))))))"

definition
  fsop_move :: " FsopMoveP\<^sub>T \<Rightarrow>  FsopMoveRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_move ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopMoveP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopMoveP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopMoveP.old_vdir\<^sub>f) (\<lambda>(old_vdir,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopMoveP.old_name\<^sub>f) (\<lambda>(old_name,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopMoveP.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 FsopMoveP.new_vdir\<^sub>f) (\<lambda>(new_vdir,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 FsopMoveP.new_name\<^sub>f) (\<lambda>(new_name,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 FsopMoveP.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>0. HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.If is_ro (FsopMoveRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) old_vdir old_vnode new_vdir opt_new_vnode, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (HOL.Let (vmode_is_dir (vfs_inode_get_mode old_vnode)) (\<lambda>old_is_dir. HOL.Let (vfs_inode_get_nlink new_vdir) (\<lambda>new_vdir_nlink. HOL.Let (vfs_inode_get_nlink old_vnode) (\<lambda>old_vnode_nlink. HOL.Let (vfs_inode_get_ctime old_vnode) (\<lambda>old_vnode_ctime. HOL.Let (vfs_inode_get_mtime old_vdir) (\<lambda>old_vdir_mtime. HOL.Let (vfs_inode_get_ctime old_vdir) (\<lambda>old_vdir_ctime. HOL.Let (vfs_inode_get_size old_vdir) (\<lambda>old_vdir_size. HOL.Let (vfs_inode_get_size new_vdir) (\<lambda>new_vdir_size. case_Option (\<lambda>ds\<^sub>1\<^sub>2. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>2 (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (vfs_inode_set_nlink (old_vnode, HOL.If old_is_dir ((-) old_vnode_nlink (1 :: 32 word)) old_vnode_nlink)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_nlink (new_vdir, HOL.If old_is_dir ((+) new_vdir_nlink (1 :: 32 word)) new_vdir_nlink)) (\<lambda>new_vdir. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>1\<^sub>5). HOL.Let (vfs_inode_set_ctime (old_vnode, time)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_mtime (old_vdir, time)) (\<lambda>old_vdir. HOL.Let (vfs_inode_set_ctime (old_vdir, time)) (\<lambda>old_vdir. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsop_do_move (FsopDoMoveP.make ex fs_st old_vdir old_name old_vnode new_vdir new_name)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>6,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 FsopDoMoveRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 FsopDoMoveRR.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 FsopDoMoveRR.old_vdir\<^sub>f) (\<lambda>(old_vdir,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 FsopDoMoveRR.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 FsopDoMoveRR.new_vdir\<^sub>f) (\<lambda>(new_vdir,ds\<^sub>1\<^sub>9). case_R (\<lambda>err. HOL.Let (vfs_inode_set_nlink (old_vnode, old_vnode_nlink)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_ctime (old_vnode, old_vnode_ctime)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_nlink (new_vdir, new_vdir_nlink)) (\<lambda>new_vdir. HOL.Let (vfs_inode_set_size (new_vdir, new_vdir_size)) (\<lambda>new_vdir. HOL.Let (vfs_inode_set_mtime (old_vdir, old_vdir_mtime)) (\<lambda>old_vdir. HOL.Let (vfs_inode_set_ctime (old_vdir, old_vdir_ctime)) (\<lambda>old_vdir. HOL.Let (vfs_inode_set_size (old_vdir, old_vdir_size)) (\<lambda>old_vdir. HOL.Let (Option.None () :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. (FsopMoveRR.make ex fs_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Error err :: (32 word, unit) R))))))))))) (\<lambda>ds\<^sub>2\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>5 (\<lambda>ds\<^sub>2\<^sub>6. HOL.Let (Option.None () :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. (FsopMoveRR.make ex fs_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Success () :: (32 word, unit) R))))) r))))))))))))))))) (\<lambda>new_vnode. HOL.Let (vmode_is_dir (vfs_inode_get_mode new_vnode)) (\<lambda>new_is_dir. HOL.Let (check_dir_empty (T0.make (FsState.mount_st\<^sub>f fs_st) ostore_st new_vnode)) (\<lambda>is_empty. HOL.If (HOL.Not is_empty) (HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. (FsopMoveRR.make ex fs_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Error (39 :: 32 word) :: (32 word, unit) R))))) (HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (vfs_inode_get_nlink new_vnode) (\<lambda>new_vnode_nlink. HOL.Let (vfs_inode_set_nlink (new_vnode, HOL.If new_is_dir (0 :: 32 word) ((-) new_vnode_nlink (1 :: 32 word)))) (\<lambda>new_vnode. HOL.Let (vfs_inode_set_nlink (new_vdir, HOL.If new_is_dir ((-) new_vdir_nlink (1 :: 32 word)) new_vdir_nlink)) (\<lambda>new_vdir. HOL.Let (vfs_inode_set_nlink (old_vnode, HOL.If old_is_dir ((-) old_vnode_nlink (1 :: 32 word)) old_vnode_nlink)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_nlink (new_vdir, HOL.If old_is_dir ((+) new_vdir_nlink (1 :: 32 word)) new_vdir_nlink)) (\<lambda>new_vdir. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>1\<^sub>3). HOL.Let (vfs_inode_set_ctime (old_vnode, time)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_mtime (old_vdir, time)) (\<lambda>old_vdir. HOL.Let (vfs_inode_set_ctime (old_vdir, time)) (\<lambda>old_vdir. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsop_do_move_del (FsopDoMoveDelP.make ex fs_st old_vdir old_name old_vnode new_vdir new_name new_vnode)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>4,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 FsopMoveRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 FsopMoveRR.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 FsopMoveRR.old_vdir\<^sub>f) (\<lambda>(old_vdir,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 FsopMoveRR.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 FsopMoveRR.new_vdir\<^sub>f) (\<lambda>(new_vdir,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 FsopMoveRR.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>1\<^sub>7). case_R (\<lambda>err. HOL.Let (opt_vnode_set_nlink (opt_new_vnode, new_vnode_nlink)) (\<lambda>opt_new_vnode. HOL.Let (vfs_inode_set_nlink (old_vnode, old_vnode_nlink)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_ctime (old_vnode, old_vnode_ctime)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_nlink (new_vdir, new_vdir_nlink)) (\<lambda>new_vdir. HOL.Let (vfs_inode_set_size (new_vdir, new_vdir_size)) (\<lambda>new_vdir. HOL.Let (vfs_inode_set_mtime (old_vdir, old_vdir_mtime)) (\<lambda>old_vdir. HOL.Let (vfs_inode_set_ctime (old_vdir, old_vdir_ctime)) (\<lambda>old_vdir. HOL.Let (vfs_inode_set_size (old_vdir, old_vdir_size)) (\<lambda>old_vdir. (FsopMoveRR.make ex fs_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Error err :: (32 word, unit) R))))))))))) (\<lambda>ds\<^sub>2\<^sub>4. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>4 (\<lambda>ds\<^sub>2\<^sub>5. (FsopMoveRR.make ex fs_st old_vdir old_vnode new_vdir opt_new_vnode, (R.Success () :: (32 word, unit) R)))) r))))))))))))))))))))))) opt_new_vnode))))))))))))))))))))"

definition
  fsop_do_rename_helper :: " FsopDoRenameHelperP\<^sub>T \<Rightarrow>  FsopDoRenameHelperRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_do_rename_helper ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopDoRenameHelperP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopDoRenameHelperP.mount_st\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopDoRenameHelperP.ostore_st\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopDoRenameHelperP.old_dent_size\<^sub>f) (\<lambda>(old_dent_size,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopDoRenameHelperP.new_dent_size\<^sub>f) (\<lambda>(new_dent_size,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopDoRenameHelperP.new_o\<^sub>f) (\<lambda>(new_o,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 FsopDoRenameHelperP.old_o\<^sub>f) (\<lambda>(old_o,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 FsopDoRenameHelperP.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 FsopDoRenameHelperP.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 FsopDoRenameHelperP.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (serialise_size_Obj old_o) (\<lambda>old_dent_size'. HOL.Let (Obj.len\<^sub>f_update (\<lambda>_. old_dent_size') old_o) (\<lambda>old_o. HOL.Let (vfs_inode_get_size vdir) (\<lambda>vdir_size. HOL.Let (vfs_inode_set_size (vdir, (+) ((-) vdir_size (ucast old_dent_size :: 64 word)) (ucast old_dent_size' :: 64 word))) (\<lambda>vdir. HOL.Let (serialise_size_Obj new_o) (\<lambda>new_dent_size'. HOL.Let (Obj.len\<^sub>f_update (\<lambda>_. new_dent_size') new_o) (\<lambda>new_o. HOL.Let (vfs_inode_get_size vdir) (\<lambda>vdir_size. HOL.Let (vfs_inode_set_size (vdir, (+) ((-) vdir_size (ucast new_dent_size :: 64 word)) (ucast new_dent_size' :: 64 word))) (\<lambda>vdir. Let\<^sub>d\<^sub>s (obj_inode_new (ex, old_vnode)) (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>4). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R))))) (\<lambda>obj_old_vnode. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vdir)) (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>8). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, obj_old_vnode)) (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R)))))) (\<lambda>obj_vdir. case_Option (\<lambda>ds\<^sub>2\<^sub>0. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>0 (\<lambda>ds\<^sub>2\<^sub>2. HOL.Let (Option.None () :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. Let\<^sub>d\<^sub>s (arrayobj_create4 (ex, old_o, obj_vdir, obj_old_vnode, new_o)) (\<lambda>ds\<^sub>2\<^sub>3. case_R (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R))) (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_write (ex, mount_st, ostore_st, arr, (0 :: 32 word))) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>8,ds\<^sub>2\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>3). case_R (\<lambda>err. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>3\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>5 (\<lambda>ds\<^sub>3\<^sub>6. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Success () :: (32 word, unit) R))))) r)))))))) ds\<^sub>2\<^sub>3)))) (\<lambda>new_vnode. Let\<^sub>d\<^sub>s (obj_inode_new (ex, new_vnode)) (\<lambda>ds\<^sub>2\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>4). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, obj_old_vnode)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, obj_vdir)) (\<lambda>ex. HOL.Let (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R)))))))) (\<lambda>obj_new_vnode. HOL.Let (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. Let\<^sub>d\<^sub>s (arrayobj_create5 (ex, old_o, obj_vdir, obj_old_vnode, new_o, obj_new_vnode)) (\<lambda>ds\<^sub>2\<^sub>6. case_R (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R))) (\<lambda>ds\<^sub>2\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_write (ex, mount_st, ostore_st, arr, (0 :: 32 word))) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>1,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>5 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>6). case_R (\<lambda>err. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>3\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>8 (\<lambda>ds\<^sub>3\<^sub>9. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Success () :: (32 word, unit) R))))) r)))))))) ds\<^sub>2\<^sub>6))) r)))) opt_new_vnode) r)))) r))))))))))))))))))))))"

definition
  fsop_do_rename_helper1 :: " FsopDoRenameHelper1P\<^sub>T \<Rightarrow>  FsopDoRenameHelperRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_do_rename_helper1 ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopDoRenameHelper1P.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopDoRenameHelper1P.mount_st\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopDoRenameHelper1P.ostore_st\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopDoRenameHelper1P.dent_size\<^sub>f) (\<lambda>(dent_size,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopDoRenameHelper1P.obj\<^sub>f) (\<lambda>(obj,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopDoRenameHelper1P.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 FsopDoRenameHelper1P.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 FsopDoRenameHelper1P.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. HOL.Let (serialise_size_Obj obj) (\<lambda>dent_size'. HOL.Let (Obj.len\<^sub>f_update (\<lambda>_. dent_size') obj) (\<lambda>obj. HOL.Let (vfs_inode_get_size vdir) (\<lambda>vdir_size. HOL.Let (vfs_inode_set_size (vdir, (+) ((-) vdir_size (ucast dent_size :: 64 word)) (ucast dent_size' :: 64 word))) (\<lambda>vdir. Let\<^sub>d\<^sub>s (obj_inode_new (ex, old_vnode)) (\<lambda>ds\<^sub>1\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>2). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, obj)) (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>obj_old_vnode. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vdir)) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>6). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, obj)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, obj_old_vnode)) (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R))))) (\<lambda>obj_vdir. case_Option (\<lambda>ds\<^sub>1\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>8 (\<lambda>ds\<^sub>2\<^sub>0. HOL.Let (Option.None () :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. Let\<^sub>d\<^sub>s (arrayobj_create3 (ex, obj, obj_vdir, obj_old_vnode)) (\<lambda>ds\<^sub>2\<^sub>1. case_R (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R))) (\<lambda>ds\<^sub>2\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_write (ex, mount_st, ostore_st, arr, (0 :: 32 word))) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>6,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>1). case_R (\<lambda>err. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>3\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>3 (\<lambda>ds\<^sub>3\<^sub>4. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Success () :: (32 word, unit) R))))) r)))))))) ds\<^sub>2\<^sub>1)))) (\<lambda>new_vnode. Let\<^sub>d\<^sub>s (obj_inode_new (ex, new_vnode)) (\<lambda>ds\<^sub>2\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>2). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, obj)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, obj_vdir)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, obj_old_vnode)) (\<lambda>ex. HOL.Let (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R))))))) (\<lambda>obj_new_vnode. HOL.Let (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. Let\<^sub>d\<^sub>s (arrayobj_create4 (ex, obj, obj_vdir, obj_old_vnode, obj_new_vnode)) (\<lambda>ds\<^sub>2\<^sub>4. case_R (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R))) (\<lambda>ds\<^sub>2\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>2\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_write (ex, mount_st, ostore_st, arr, (0 :: 32 word))) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>9,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>4). case_R (\<lambda>err. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>3\<^sub>6. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>6 (\<lambda>ds\<^sub>3\<^sub>7. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopDoRenameHelper1R.make ex ostore_st vdir old_vnode opt_new_vnode, (R.Success () :: (32 word, unit) R))))) r)))))))) ds\<^sub>2\<^sub>4))) r)))) opt_new_vnode) r)))) r))))))))))))))))"

definition
  fsop_do_rename :: " FsopDoRenameP\<^sub>T \<Rightarrow>  FsopDoRenameRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_do_rename ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopDoRenameP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopDoRenameP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopDoRenameP.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopDoRenameP.old_name\<^sub>f) (\<lambda>(old_name,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopDoRenameP.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopDoRenameP.new_name\<^sub>f) (\<lambda>(new_name,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>7. HOL.Let (obj_id_dentarr_mk (vfs_inode_get_ino vdir, old_name)) (\<lambda>oldoid. HOL.Let (obj_id_dentarr_mk (vfs_inode_get_ino vdir, new_name)) (\<lambda>newoid. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.If ((=) oldoid newoid) (Let\<^sub>d\<^sub>s (read_or_create_dentarr (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, oldoid)) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>9,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>3). case_R (\<lambda>err. (FsopDoRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P3_p1\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P3_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p3\<^sub>f) (\<lambda>(created,ds\<^sub>1\<^sub>8). HOL.Let (HOL.If created (0 :: 32 word) (Obj.len\<^sub>f obj)) (\<lambda>dent_size. HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_del_dentry (ex, dentarr, old_name)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>2\<^sub>0). HOL.Let (vtype_to_dtype (vmode_to_vtype (vfs_inode_get_mode old_vnode))) (\<lambda>dtype. Let\<^sub>d\<^sub>s (dentarr_add_dentry (ex, dentarr, old_vnode, new_name, dtype)) (\<lambda>ds\<^sub>2\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>2,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>2\<^sub>6). case_R (\<lambda>err. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr dentarr ::  ObjUnion\<^sub>T)) obj) (\<lambda>obj. HOL.Let (deep_freeObj (ex, obj)) (\<lambda>ex. (FsopDoRenameRR.make ex fs_st vdir old_vnode, (R.Error err :: (32 word, unit) R))))) (\<lambda>ds\<^sub>2\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>8 (\<lambda>ds\<^sub>2\<^sub>9. Let\<^sub>d\<^sub>s (obj_dentarr_or_del_new (ex, obj, dentarr)) (\<lambda>ds\<^sub>3\<^sub>0. case_R (\<lambda>ds\<^sub>3\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>3\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>4). (FsopDoRenameRR.make ex fs_st vdir old_vnode, (R.Error err :: (32 word, unit) R))))) (\<lambda>ds\<^sub>3\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P2_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (Option.None () :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. Let\<^sub>d\<^sub>s (fsop_do_rename_helper1 (FsopDoRenameHelper1P.make ex (FsState.mount_st\<^sub>f fs_st) ostore_st dent_size obj vdir old_vnode opt_new_vnode)) (\<lambda>ds\<^sub>3\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>7,ds\<^sub>3\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 FsopDoRenameHelper1R.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 FsopDoRenameHelper1R.ostore_st\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>2 FsopDoRenameHelper1R.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>4\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>3 FsopDoRenameHelper1R.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>4\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>4 FsopDoRenameHelper1R.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>4\<^sub>0). case_R (\<lambda>err. HOL.Let (free_opt_VfsInode (ex, opt_new_vnode)) (\<lambda>ex. (FsopDoRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>4\<^sub>6. Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>6 (\<lambda>ds\<^sub>4\<^sub>7. HOL.Let (free_opt_VfsInode (ex, opt_new_vnode)) (\<lambda>ex. (FsopDoRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode, (R.Success () :: (32 word, unit) R))))) r))))))))))))) ds\<^sub>3\<^sub>0))) r)))))))))))))) r)))))) (Let\<^sub>d\<^sub>s (rename_read_or_create_dentarrs (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, oldoid, newoid)) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>0,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>4). case_R (\<lambda>err. (FsopDoRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P6_p1\<^sub>f) (\<lambda>(old_o,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P6_p2\<^sub>f) (\<lambda>(new_o,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P6_p3\<^sub>f) (\<lambda>(old_dent,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P6_p4\<^sub>f) (\<lambda>(new_dent,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P6_p5\<^sub>f) (\<lambda>(old_dent_size,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P6_p6\<^sub>f) (\<lambda>(new_dent_size,ds\<^sub>2\<^sub>2). HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_del_dentry (ex, old_dent, old_name)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p2\<^sub>f) (\<lambda>(old_dent,ds\<^sub>2\<^sub>4). HOL.Let (vtype_to_dtype (vmode_to_vtype (vfs_inode_get_mode old_vnode))) (\<lambda>dtype. Let\<^sub>d\<^sub>s (dentarr_add_dentry (ex, new_dent, old_vnode, new_name, dtype)) (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>6,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P2_p2\<^sub>f) (\<lambda>(new_dent,ds\<^sub>3\<^sub>0). case_R (\<lambda>err. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr old_dent ::  ObjUnion\<^sub>T)) old_o) (\<lambda>old_o. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr new_dent ::  ObjUnion\<^sub>T)) new_o) (\<lambda>new_o. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. (FsopDoRenameRR.make ex fs_st vdir old_vnode, (R.Error err :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>3\<^sub>2. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>2 (\<lambda>ds\<^sub>3\<^sub>3. Let\<^sub>d\<^sub>s (obj_dentarr_or_del_new (ex, old_o, old_dent)) (\<lambda>ds\<^sub>3\<^sub>4. case_R (\<lambda>ds\<^sub>3\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>5 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>8). HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr new_dent ::  ObjUnion\<^sub>T)) new_o) (\<lambda>new_o. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. (FsopDoRenameRR.make ex fs_st vdir old_vnode, (R.Error err :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>3\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>8 P2_p2\<^sub>f) (\<lambda>(old_o,ds\<^sub>3\<^sub>9). HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr new_dent ::  ObjUnion\<^sub>T)) new_o) (\<lambda>new_o. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). Let\<^sub>d\<^sub>s (fsop_do_rename_helper (FsopDoRenameHelperP.make ex (FsState.mount_st\<^sub>f fs_st) ostore_st old_dent_size new_dent_size new_o old_o vdir old_vnode (Option.None () :: (unit,  VfsInode\<^sub>T) Option))) (\<lambda>ds\<^sub>4\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>4\<^sub>1,ds\<^sub>4\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>2 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>4\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 FsopDoRenameHelper1R.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>5 FsopDoRenameHelper1R.ostore_st\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>6 FsopDoRenameHelper1R.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>4\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>7 FsopDoRenameHelper1R.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>4\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>8 FsopDoRenameHelper1R.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>4\<^sub>4). case_R (\<lambda>err. HOL.Let (free_opt_VfsInode (ex, opt_new_vnode)) (\<lambda>ex. (FsopDoRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>5\<^sub>0. Let\<^sub>d\<^sub>s ds\<^sub>5\<^sub>0 (\<lambda>ds\<^sub>5\<^sub>1. HOL.Let (free_opt_VfsInode (ex, opt_new_vnode)) (\<lambda>ex. (FsopDoRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode, (R.Success () :: (32 word, unit) R))))) r))))))))))))) ds\<^sub>3\<^sub>4))) r)))))))))))))))) r))))))))))))))))"

definition
  fsop_do_rename_del :: " FsopDoRenameDelP\<^sub>T \<Rightarrow>  FsopRenameRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_do_rename_del ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopDoRenameDelP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopDoRenameDelP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopDoRenameDelP.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopDoRenameDelP.old_name\<^sub>f) (\<lambda>(old_name,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopDoRenameDelP.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopDoRenameDelP.new_name\<^sub>f) (\<lambda>(new_name,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 FsopDoRenameDelP.new_vnode\<^sub>f) (\<lambda>(new_vnode,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>8. HOL.Let (obj_id_dentarr_mk (vfs_inode_get_ino vdir, old_name)) (\<lambda>oldoid. HOL.Let (obj_id_dentarr_mk (vfs_inode_get_ino vdir, new_name)) (\<lambda>newoid. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.If ((=) oldoid newoid) (Let\<^sub>d\<^sub>s (read_or_create_dentarr (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, oldoid)) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>0,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>4). case_R (\<lambda>err. (FsopRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option), (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P3_p1\<^sub>f) (\<lambda>(obj,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P3_p3\<^sub>f) (\<lambda>(created,ds\<^sub>1\<^sub>9). HOL.Let (HOL.If created (0 :: 32 word) (Obj.len\<^sub>f obj)) (\<lambda>dent_size. HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_del_dentry (ex, dentarr, new_name)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_del_dentry (ex, dentarr, old_name)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>2\<^sub>3). HOL.Let (vtype_to_dtype (vmode_to_vtype (vfs_inode_get_mode old_vnode))) (\<lambda>dtype. Let\<^sub>d\<^sub>s (dentarr_add_dentry (ex, dentarr, old_vnode, new_name, dtype)) (\<lambda>ds\<^sub>2\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>5,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P2_p2\<^sub>f) (\<lambda>(dentarr,ds\<^sub>2\<^sub>9). case_R (\<lambda>err. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr dentarr ::  ObjUnion\<^sub>T)) obj) (\<lambda>obj. HOL.Let (deep_freeObj (ex, obj)) (\<lambda>ex. (FsopRenameRR.make ex fs_st vdir old_vnode (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option), (R.Error err :: (32 word, unit) R))))) (\<lambda>ds\<^sub>3\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>1 (\<lambda>ds\<^sub>3\<^sub>2. Let\<^sub>d\<^sub>s (obj_dentarr_or_del_new (ex, obj, dentarr)) (\<lambda>ds\<^sub>3\<^sub>3. case_R (\<lambda>ds\<^sub>3\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>3\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>7). (FsopRenameRR.make ex fs_st vdir old_vnode (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option), (R.Error err :: (32 word, unit) R))))) (\<lambda>ds\<^sub>3\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P2_p2\<^sub>f) (\<lambda>(obj,ds\<^sub>3\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). Let\<^sub>d\<^sub>s (fsop_do_rename_helper1 (FsopDoRenameHelper1P.make ex (FsState.mount_st\<^sub>f fs_st) ostore_st dent_size obj vdir old_vnode (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option))) (\<lambda>ds\<^sub>3\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>4\<^sub>0,ds\<^sub>4\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>4\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>0 FsopDoRenameHelper1R.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>4 FsopDoRenameHelper1R.ostore_st\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>5 FsopDoRenameHelper1R.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>4\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>6 FsopDoRenameHelper1R.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>4\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>7 FsopDoRenameHelper1R.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>4\<^sub>3). case_R (\<lambda>err. (FsopRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>4\<^sub>9. Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>9 (\<lambda>ds\<^sub>5\<^sub>0. (FsopRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode opt_new_vnode, (R.Success () :: (32 word, unit) R)))) r)))))))))))) ds\<^sub>3\<^sub>3))) r)))))))))))))))) r)))))) (Let\<^sub>d\<^sub>s (rename_read_or_create_dentarrs (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, oldoid, newoid)) (\<lambda>ds\<^sub>1\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>1,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>5). case_R (\<lambda>err. (FsopRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option), (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P6_p1\<^sub>f) (\<lambda>(old_o,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P6_p2\<^sub>f) (\<lambda>(new_o,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P6_p3\<^sub>f) (\<lambda>(old_dent,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P6_p4\<^sub>f) (\<lambda>(new_dent,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P6_p5\<^sub>f) (\<lambda>(old_dent_size,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P6_p6\<^sub>f) (\<lambda>(new_dent_size,ds\<^sub>2\<^sub>3). HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_del_dentry (ex, old_dent, old_name)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p2\<^sub>f) (\<lambda>(old_dent,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (dentarr_del_dentry (ex, new_dent, new_name)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(new_dent,ds\<^sub>2\<^sub>7). HOL.Let (vtype_to_dtype (vmode_to_vtype (vfs_inode_get_mode old_vnode))) (\<lambda>dtype. Let\<^sub>d\<^sub>s (dentarr_add_dentry (ex, new_dent, old_vnode, new_name, dtype)) (\<lambda>ds\<^sub>2\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>9,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P2_p2\<^sub>f) (\<lambda>(new_dent,ds\<^sub>3\<^sub>3). case_R (\<lambda>err. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr old_dent ::  ObjUnion\<^sub>T)) old_o) (\<lambda>old_o. HOL.Let (deep_freeObj (ex, old_o)) (\<lambda>ex. HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr new_dent ::  ObjUnion\<^sub>T)) new_o) (\<lambda>new_o. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. (FsopRenameRR.make ex fs_st vdir old_vnode (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option), (R.Error err :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>3\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>5 (\<lambda>ds\<^sub>3\<^sub>6. Let\<^sub>d\<^sub>s (obj_dentarr_or_del_new (ex, old_o, old_dent)) (\<lambda>ds\<^sub>3\<^sub>7. case_R (\<lambda>ds\<^sub>3\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>8 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>4\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>0 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>1). HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr new_dent ::  ObjUnion\<^sub>T)) new_o) (\<lambda>new_o. HOL.Let (deep_freeObj (ex, new_o)) (\<lambda>ex. (FsopRenameRR.make ex fs_st vdir old_vnode (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option), (R.Error err :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>4\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 P2_p2\<^sub>f) (\<lambda>(old_o,ds\<^sub>4\<^sub>2). HOL.Let (Obj.ounion\<^sub>f_update (\<lambda>_. (ObjUnion.TObjDentarr new_dent ::  ObjUnion\<^sub>T)) new_o) (\<lambda>new_o. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). Let\<^sub>d\<^sub>s (fsop_do_rename_helper (FsopDoRenameHelperP.make ex (FsState.mount_st\<^sub>f fs_st) ostore_st old_dent_size new_dent_size new_o old_o vdir old_vnode (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option))) (\<lambda>ds\<^sub>4\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>4\<^sub>4,ds\<^sub>4\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>4\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>4 FsopDoRenameHelper1R.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>8 FsopDoRenameHelper1R.ostore_st\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>9 FsopDoRenameHelper1R.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>5\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>0 FsopDoRenameHelper1R.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>5\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>1 FsopDoRenameHelper1R.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>4\<^sub>7). case_R (\<lambda>err. (FsopRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>5\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>5\<^sub>3 (\<lambda>ds\<^sub>5\<^sub>4. (FsopRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode opt_new_vnode, (R.Success () :: (32 word, unit) R)))) r))))))))))))) ds\<^sub>3\<^sub>7))) r)))))))))))))))))) r)))))))))))))))))"

definition
  fsop_rename :: " FsopRenameP\<^sub>T \<Rightarrow>  FsopRenameRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_rename ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopRenameP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopRenameP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopRenameP.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopRenameP.old_name\<^sub>f) (\<lambda>(old_name,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopRenameP.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 FsopRenameP.new_name\<^sub>f) (\<lambda>(new_name,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 FsopRenameP.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.If is_ro (FsopRenameRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir old_vnode opt_new_vnode, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (HOL.Let (vmode_is_dir (vfs_inode_get_mode old_vnode)) (\<lambda>old_is_dir. HOL.Let (vfs_inode_get_nlink old_vnode) (\<lambda>old_vnode_nlink. HOL.Let (vfs_inode_get_ctime old_vnode) (\<lambda>old_vnode_ctime. HOL.Let (vfs_inode_get_mtime vdir) (\<lambda>vdir_mtime. HOL.Let (vfs_inode_get_ctime vdir) (\<lambda>vdir_ctime. HOL.Let (vfs_inode_get_size vdir) (\<lambda>vdir_size. case_Option (\<lambda>ds\<^sub>1\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>1 (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (HOL.If old_is_dir ((-) old_vnode_nlink (1 :: 32 word)) old_vnode_nlink) (\<lambda>v_nlink. HOL.Let (vfs_inode_set_nlink (old_vnode, v_nlink)) (\<lambda>old_vnode. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>1\<^sub>4). HOL.Let (vfs_inode_set_ctime (old_vnode, time)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_mtime (vdir, time)) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, time)) (\<lambda>vdir. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsop_do_rename (FsopDoRenameP.make ex fs_st vdir old_name old_vnode new_name)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>5,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 FsopDoRenameRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 FsopDoRenameRR.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 FsopDoRenameRR.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 FsopDoRenameRR.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>1\<^sub>8). case_R (\<lambda>err. HOL.Let (vfs_inode_set_nlink (old_vnode, old_vnode_nlink)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_ctime (old_vnode, old_vnode_ctime)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_mtime (vdir, vdir_mtime)) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, vdir_ctime)) (\<lambda>vdir. HOL.Let (vfs_inode_set_size (vdir, vdir_size)) (\<lambda>vdir. (FsopRenameRR.make ex fs_st vdir old_vnode (Option.None () :: (unit,  VfsInode\<^sub>T) Option), (R.Error err :: (32 word, unit) R)))))))) (\<lambda>ds\<^sub>2\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>3 (\<lambda>ds\<^sub>2\<^sub>4. (FsopRenameRR.make ex fs_st vdir old_vnode (Option.None () :: (unit,  VfsInode\<^sub>T) Option), (R.Success () :: (32 word, unit) R)))) r)))))))))))))))) (\<lambda>new_vnode. HOL.Let (vmode_is_dir (vfs_inode_get_mode new_vnode)) (\<lambda>new_is_dir. HOL.Let (check_dir_empty (T0.make (FsState.mount_st\<^sub>f fs_st) ostore_st new_vnode)) (\<lambda>is_empty. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>1. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>2. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>3. HOL.If (HOL.Not is_empty) (HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (Option.Some new_vnode :: (unit,  VfsInode\<^sub>T) Option) (\<lambda>opt_new_vnode. (FsopRenameRR.make ex fs_st vdir old_vnode opt_new_vnode, (R.Error (39 :: 32 word) :: (32 word, unit) R))))) (HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (vfs_inode_get_nlink new_vnode) (\<lambda>new_vnode_nlink. HOL.Let (HOL.If new_is_dir (0 :: 32 word) ((-) new_vnode_nlink (1 :: 32 word))) (\<lambda>new_vnode_nlink_count. HOL.Let (vfs_inode_set_nlink (new_vnode, new_vnode_nlink_count)) (\<lambda>new_vnode. HOL.Let (HOL.If old_is_dir ((-) old_vnode_nlink (1 :: 32 word)) old_vnode_nlink) (\<lambda>old_vnode_nlink. HOL.Let (vfs_inode_set_nlink (old_vnode, old_vnode_nlink)) (\<lambda>old_vnode. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>1\<^sub>5). HOL.Let (vfs_inode_get_ctime old_vnode) (\<lambda>time. HOL.Let (vfs_inode_set_mtime (vdir, time)) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, time)) (\<lambda>vdir. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsop_do_rename_del (FsopDoRenameDelP.make ex fs_st vdir old_name old_vnode new_name new_vnode)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>6,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 FsopRenameRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 FsopRenameRR.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 FsopRenameRR.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 FsopRenameRR.old_vnode\<^sub>f) (\<lambda>(old_vnode,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 FsopRenameRR.opt_new_vnode\<^sub>f) (\<lambda>(opt_new_vnode,ds\<^sub>1\<^sub>9). case_R (\<lambda>err. HOL.Let (opt_vnode_set_nlink (opt_new_vnode, new_vnode_nlink)) (\<lambda>opt_new_vnode. HOL.Let (vfs_inode_set_nlink (old_vnode, old_vnode_nlink)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_ctime (old_vnode, old_vnode_ctime)) (\<lambda>old_vnode. HOL.Let (vfs_inode_set_mtime (vdir, vdir_mtime)) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, vdir_ctime)) (\<lambda>vdir. HOL.Let (vfs_inode_set_size (vdir, vdir_size)) (\<lambda>vdir. (FsopRenameRR.make ex fs_st vdir old_vnode opt_new_vnode, (R.Error err :: (32 word, unit) R))))))))) (\<lambda>ds\<^sub>2\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>5 (\<lambda>ds\<^sub>2\<^sub>6. (FsopRenameRR.make ex fs_st vdir old_vnode opt_new_vnode, (R.Success () :: (32 word, unit) R)))) r))))))))))))))))))))))))) opt_new_vnode)))))))))))))))))"

definition
  fsop_do_truncate :: " FsopTruncateP\<^sub>T \<Rightarrow>  FsopVfsInodeP\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_do_truncate ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopTruncateP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopTruncateP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopTruncateP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopTruncateP.newsize\<^sub>f) (\<lambda>(newsize,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>5. HOL.Let (vfs_inode_get_size vnode) (\<lambda>oldsize. HOL.Let (vfs_inode_get_mtime vnode) (\<lambda>v_mtime. HOL.Let (vfs_inode_get_ctime vnode) (\<lambda>v_ctime. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>7). HOL.Let (vfs_inode_set_mtime (vnode, time)) (\<lambda>vnode. HOL.Let (vfs_inode_set_ctime (vnode, time)) (\<lambda>vnode. HOL.Let (vfs_inode_set_size (vnode, newsize)) (\<lambda>vnode. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vnode)) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>0). case_R (\<lambda>err. (FsopIgetRR.make ex fs_st vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>oi. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (truncate_last_block (FsopTruncateP.make ex fs_st vnode newsize)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>2,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 FsopIgetRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 FsopIgetRR.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 FsopIgetRR.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1\<^sub>5). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, oi)) (\<lambda>ex. (FsopIgetRR.make ex fs_st vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>optlastblock. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (truncate_deletion_obj (FsopTruncateP.make ex fs_st vnode newsize)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>9,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 FsopIgetRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 FsopIgetRR.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 FsopIgetRR.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>2\<^sub>2). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, oi)) (\<lambda>ex. HOL.Let (deep_opt_freeObj (ex, optlastblock)) (\<lambda>ex. (FsopIgetRR.make ex fs_st vnode, (R.Error err :: (32 word, unit) R))))) (\<lambda>optdel. HOL.Let (case_Option (\<lambda>ds\<^sub>2\<^sub>6. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>6 (\<lambda>ds\<^sub>2\<^sub>8. (2 :: 32 word))) (\<lambda>ds\<^sub>2\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>8 (\<lambda>ds\<^sub>2\<^sub>9. (0 :: 32 word))) optdel) (\<lambda>osw_flag. Let\<^sub>d\<^sub>s (truncate_arrayobj_create (ex, optlastblock, optdel, oi)) (\<lambda>ds\<^sub>2\<^sub>8. case_R (\<lambda>ex. (FsopIgetRR.make ex fs_st vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R))) (\<lambda>ds\<^sub>3\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). Let\<^sub>d\<^sub>s (ostore_write (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, arr, osw_flag)) (\<lambda>ds\<^sub>3\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>4,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>8 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>9). case_R (\<lambda>err. HOL.Let (vfs_inode_set_size (vnode, oldsize)) (\<lambda>vnode. HOL.Let (vfs_inode_set_mtime (vnode, v_mtime)) (\<lambda>vnode. HOL.Let (vfs_inode_set_ctime (vnode, v_ctime)) (\<lambda>vnode. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopIgetRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vnode, (R.Error err :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>4\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>1 (\<lambda>ds\<^sub>4\<^sub>2. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopIgetRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vnode, (R.Success () :: (32 word, unit) R))))) r)))))))))) ds\<^sub>2\<^sub>8))) r)))))) r)))))) r))))))))))))))))"

definition
  fsop_evict_inode :: " FsopVfsInodeP\<^sub>T \<Rightarrow>  FsopVfsInodeP\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_evict_inode ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopIgetRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopIgetRR.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopIgetRR.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1). HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.If is_ro (FsopIgetRR.make ex fs_st vnode, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (HOL.Let (vfs_inode_get_nlink vnode) (\<lambda>nlink. HOL.If ((~=) nlink (0 :: 32 word)) (FsopIgetRR.make ex fs_st vnode, (R.Success () :: (32 word, unit) R)) (HOL.Let (obj_id_inode_mk (vfs_inode_get_ino vnode)) (\<lambda>oid. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (obj_del_new (ex, oid)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>5). case_R (\<lambda>err. (FsopIgetRR.make ex fs_st vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>odel. Let\<^sub>d\<^sub>s (arrayobj_create1 (ex, odel)) (\<lambda>ds\<^sub>7. case_R (\<lambda>ex. (FsopIgetRR.make ex fs_st vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R))) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). Let\<^sub>d\<^sub>s (ostore_write (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, arr, (0 :: 32 word))) (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>3,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>1\<^sub>8). case_R (\<lambda>err. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopIgetRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>2\<^sub>0. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>0 (\<lambda>ds\<^sub>2\<^sub>1. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopIgetRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vnode, (R.Success () :: (32 word, unit) R))))) r)))))))))) ds\<^sub>7)) r))))))))))"

definition
  fsop_link :: " FsopUnlinkP\<^sub>T \<Rightarrow>  FsopRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_link ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopLinkP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopLinkP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopLinkP.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopLinkP.name\<^sub>f) (\<lambda>(name,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopLinkP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1). HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.If is_ro (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (HOL.Let (vfs_inode_get_mode vnode) (\<lambda>vtype. HOL.Let (vtype_to_dtype vtype) (\<lambda>dtype. Let\<^sub>d\<^sub>s (dentarr_read_and_add (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, vdir, name, vnode, dtype)) (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>2). case_R (\<lambda>err. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(new_v_size,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(dentarr_obj,ds\<^sub>1\<^sub>6). HOL.Let (vfs_inode_inc_nlink vnode) (\<lambda>vnode. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>1\<^sub>8). HOL.Let (vfs_inode_set_mtime (vnode, time)) (\<lambda>vnode. HOL.Let (vfs_inode_set_ctime (vnode, time)) (\<lambda>vnode. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vnode)) (\<lambda>ds\<^sub>1\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>1). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. HOL.Let (vfs_inode_dec_nlink vnode) (\<lambda>vnode. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R))))) (\<lambda>inode. HOL.Let (vfs_inode_get_size vdir) (\<lambda>v_size'. HOL.Let (vfs_inode_get_mtime vdir) (\<lambda>v_mtime'. HOL.Let (vfs_inode_get_ctime vdir) (\<lambda>v_ctime'. HOL.Let (vfs_inode_set_size (vdir, new_v_size)) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, time)) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, time)) (\<lambda>vdir. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vdir)) (\<lambda>ds\<^sub>2\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>5). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, inode)) (\<lambda>ex. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (vfs_inode_dec_nlink vnode) (\<lambda>vnode. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R))))))))) (\<lambda>dir. Let\<^sub>d\<^sub>s (arrayobj_create3 (ex, dentarr_obj, inode, dir)) (\<lambda>ds\<^sub>2\<^sub>7. case_R (\<lambda>ex. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (vfs_inode_dec_nlink vnode) (\<lambda>vnode. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>2\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>1). Let\<^sub>d\<^sub>s (ostore_write (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, arr, (0 :: 32 word))) (\<lambda>ds\<^sub>3\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>3,ds\<^sub>3\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>8). case_R (\<lambda>err. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (vfs_inode_dec_nlink vnode) (\<lambda>vnode. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R)))))))) (\<lambda>ds\<^sub>4\<^sub>0. Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>0 (\<lambda>ds\<^sub>4\<^sub>1. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Success () :: (32 word, unit) R))))) r))))))))) ds\<^sub>2\<^sub>7)) r)))))))))) r))))))))))) r)))))))))))))))"

definition
  fsop_mkdir :: " FsopCreateP\<^sub>T \<Rightarrow>  FsopRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_mkdir ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopCreateP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopCreateP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopCreateP.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopCreateP.name\<^sub>f) (\<lambda>(name,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopCreateP.mode\<^sub>f) (\<lambda>(mode,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 FsopCreateP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1). HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.If is_ro (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (Let\<^sub>d\<^sub>s (init_vnode (ex, ostore_st, vdir, vnode, (OR) mode (16384 :: 32 word))) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>9,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p3\<^sub>f) (\<lambda>(vnode,ds\<^sub>1\<^sub>4). case_R (\<lambda>err. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>6. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>6 (\<lambda>ds\<^sub>1\<^sub>7. Let\<^sub>d\<^sub>s (dentarr_read_and_add (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, vdir, name, vnode, (1 :: 8 word))) (\<lambda>ds\<^sub>1\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>9,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>3). case_R (\<lambda>err. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p1\<^sub>f) (\<lambda>(new_v_size,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(dentarr_obj,ds\<^sub>2\<^sub>7). HOL.Let (vfs_inode_set_nlink (vnode, (2 :: 32 word))) (\<lambda>vnode. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vnode)) (\<lambda>ds\<^sub>2\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>0). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>inode. HOL.Let (vfs_inode_get_size vdir) (\<lambda>v_size'. HOL.Let (vfs_inode_get_mtime vdir) (\<lambda>v_mtime'. HOL.Let (vfs_inode_get_ctime vdir) (\<lambda>v_ctime'. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>3\<^sub>3). HOL.Let (vfs_inode_set_size (vdir, new_v_size)) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, time)) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, time)) (\<lambda>vdir. HOL.Let (vfs_inode_inc_nlink vdir) (\<lambda>vdir. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vdir)) (\<lambda>ds\<^sub>3\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>6). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, inode)) (\<lambda>ex. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (vfs_inode_dec_nlink vdir) (\<lambda>vdir. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R))))))))) (\<lambda>dir. Let\<^sub>d\<^sub>s (arrayobj_create3 (ex, dentarr_obj, inode, dir)) (\<lambda>ds\<^sub>3\<^sub>8. case_R (\<lambda>ex. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (vfs_inode_dec_nlink vdir) (\<lambda>vdir. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>4\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>4\<^sub>2). Let\<^sub>d\<^sub>s (ostore_write (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, arr, (0 :: 32 word))) (\<lambda>ds\<^sub>4\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>4\<^sub>4,ds\<^sub>4\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>4\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>4 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>7 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>4\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>8 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>4\<^sub>9). case_R (\<lambda>err. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. HOL.Let (vfs_inode_dec_nlink vdir) (\<lambda>vdir. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R)))))))) (\<lambda>ds\<^sub>5\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>5\<^sub>1 (\<lambda>ds\<^sub>5\<^sub>2. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Success () :: (32 word, unit) R))))) r))))))))) ds\<^sub>3\<^sub>8)) r))))))))))))) r))))))) r))))))) r)))))))))))))))"

definition
  fsop_rmdir :: " FsopUnlinkP\<^sub>T \<Rightarrow>  FsopRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_rmdir ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopLinkP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopLinkP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopLinkP.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopLinkP.name\<^sub>f) (\<lambda>(name,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopLinkP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1). HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.If is_ro (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (HOL.Let (check_dir_empty (T0.make (FsState.mount_st\<^sub>f fs_st) ostore_st vnode)) (\<lambda>is_empty. HOL.If (HOL.Not is_empty) (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error (39 :: 32 word) :: (32 word, unit) R)) (Let\<^sub>d\<^sub>s (dentarr_read_and_del (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, vdir, name)) (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>2). case_R (\<lambda>err. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(new_v_size,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(dentarr_obj,ds\<^sub>1\<^sub>6). HOL.Let (vfs_inode_set_nlink (vnode, (0 :: 32 word))) (\<lambda>vnode. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vnode)) (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>9). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. HOL.Let (vfs_inode_set_nlink (vnode, (2 :: 32 word))) (\<lambda>vnode. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R))))) (\<lambda>inode. HOL.Let (vfs_inode_get_size vdir) (\<lambda>v_size'. HOL.Let (vfs_inode_get_mtime vdir) (\<lambda>v_mtime'. HOL.Let (vfs_inode_get_ctime vdir) (\<lambda>v_ctime'. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p2\<^sub>f) (\<lambda>(v_mtime,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p2\<^sub>f) (\<lambda>(v_ctime,ds\<^sub>2\<^sub>4). HOL.Let (vfs_inode_set_size (vdir, new_v_size)) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime)) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime)) (\<lambda>vdir. HOL.Let (vfs_inode_dec_nlink vdir) (\<lambda>vdir. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vdir)) (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>7). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, inode)) (\<lambda>ex. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_nlink (vnode, (2 :: 32 word))) (\<lambda>vnode. HOL.Let (vfs_inode_inc_nlink vdir) (\<lambda>vdir. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R)))))))))) (\<lambda>dir. Let\<^sub>d\<^sub>s (arrayobj_create3 (ex, dentarr_obj, inode, dir)) (\<lambda>ds\<^sub>2\<^sub>9. case_R (\<lambda>ex. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_nlink (vnode, (2 :: 32 word))) (\<lambda>vnode. HOL.Let (vfs_inode_inc_nlink vdir) (\<lambda>vdir. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R)))))))) (\<lambda>ds\<^sub>3\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>3). Let\<^sub>d\<^sub>s (ostore_write (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, arr, (0 :: 32 word))) (\<lambda>ds\<^sub>3\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>5,ds\<^sub>3\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>5 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>8 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>9 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>4\<^sub>0). case_R (\<lambda>err. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4\<^sub>2. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. HOL.Let (vfs_inode_set_nlink (vnode, (2 :: 32 word))) (\<lambda>vnode. HOL.Let (vfs_inode_inc_nlink vdir) (\<lambda>vdir. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R)))))))))) (\<lambda>ds\<^sub>4\<^sub>2. Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>2 (\<lambda>ds\<^sub>4\<^sub>3. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Success () :: (32 word, unit) R))))) r))))))))) ds\<^sub>2\<^sub>9)) r))))))))))))))) r))))))) r)))))))))))))))"

definition
  fsop_symlink :: " FsopSymlinkP\<^sub>T \<Rightarrow>  FsopSymlinkRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_symlink ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopSymlinkP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopSymlinkP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopSymlinkP.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopSymlinkP.name\<^sub>f) (\<lambda>(name,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopSymlinkP.symname\<^sub>f) (\<lambda>(symname,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 FsopSymlinkP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1). HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.Let (wordarray_length symname) (\<lambda>sz_sym. HOL.If is_ro (FsopSymlinkRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir symname vnode, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (HOL.If ((>) sz_sym (4096 :: 32 word)) (FsopSymlinkRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir symname vnode, (R.Error (36 :: 32 word) :: (32 word, unit) R)) (Let\<^sub>d\<^sub>s (init_vnode (ex, ostore_st, vdir, vnode, (OR) (40960 :: 32 word) ((OR) ((OR) (448 :: 32 word) (56 :: 32 word)) (7 :: 32 word)))) (\<lambda>ds\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>9,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p3\<^sub>f) (\<lambda>(vnode,ds\<^sub>1\<^sub>4). case_R (\<lambda>err. (FsopSymlinkRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir symname vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>6. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>6 (\<lambda>ds\<^sub>1\<^sub>7. Let\<^sub>d\<^sub>s (dentarr_read_and_add (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, vdir, name, vnode, (2 :: 8 word))) (\<lambda>ds\<^sub>1\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>9,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>3). case_R (\<lambda>err. (FsopSymlinkRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir symname vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p1\<^sub>f) (\<lambda>(new_v_size,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(dentarr_obj,ds\<^sub>2\<^sub>7). HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. Let\<^sub>d\<^sub>s (wordarray_create (ex, (1 :: 32 word))) (\<lambda>ds\<^sub>2\<^sub>8. case_R (\<lambda>ex. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. (FsopSymlinkRR.make ex fs_st vdir symname vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R)))) (\<lambda>ds\<^sub>3\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P2_p2\<^sub>f) (\<lambda>(dummy_data,ds\<^sub>3\<^sub>2). HOL.Let (obj_id_data_mk (vfs_inode_get_ino vnode, (0 :: 32 word))) (\<lambda>oid. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (obj_data_new (ex, oid, sz_sym, symname)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>4). case_R (\<lambda>ds\<^sub>3\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>5 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P2_p2\<^sub>f) (\<lambda>(symname,ds\<^sub>3\<^sub>8). HOL.Let (wordarray_free (ex, dummy_data)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. (FsopSymlinkRR.make ex fs_st vdir symname vnode, (R.Error err :: (32 word, unit) R))))))) (\<lambda>odata. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vnode)) (\<lambda>ds\<^sub>3\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>9). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (get_data_back (ex, dummy_data, (Option.Some odata :: (unit,  Obj\<^sub>T) Option))) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 P2_p2\<^sub>f) (\<lambda>(symname,ds\<^sub>4\<^sub>2). (FsopSymlinkRR.make ex fs_st vdir symname vnode, (R.Error err :: (32 word, unit) R)))))) (\<lambda>inode. HOL.Let (vfs_inode_get_size vdir) (\<lambda>v_size'. HOL.Let (vfs_inode_get_mtime vdir) (\<lambda>v_mtime'. HOL.Let (vfs_inode_get_ctime vdir) (\<lambda>v_ctime'. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>1 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>4\<^sub>2). HOL.Let (vfs_inode_set_size (vdir, new_v_size)) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, time)) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, time)) (\<lambda>vdir. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vdir)) (\<lambda>ds\<^sub>4\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>4\<^sub>5). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, inode)) (\<lambda>ex. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (get_data_back (ex, dummy_data, (Option.Some odata :: (unit,  Obj\<^sub>T) Option))) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>7 P2_p2\<^sub>f) (\<lambda>(symname,ds\<^sub>4\<^sub>8). HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. (FsopSymlinkRR.make ex fs_st vdir symname vnode, (R.Error err :: (32 word, unit) R)))))))))) (\<lambda>dir. Let\<^sub>d\<^sub>s (arrayobj_create4_ret2 (ex, dentarr_obj, odata, inode, dir)) (\<lambda>ds\<^sub>4\<^sub>7. case_R (\<lambda>ds\<^sub>4\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>0 P2_p2\<^sub>f) (\<lambda>(odata,ds\<^sub>5\<^sub>1). HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (get_data_back (ex, dummy_data, (Option.Some odata :: (unit,  Obj\<^sub>T) Option))) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>2 P2_p2\<^sub>f) (\<lambda>(symname,ds\<^sub>5\<^sub>3). (FsopSymlinkRR.make ex fs_st vdir symname vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R)))))))))) (\<lambda>ds\<^sub>5\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>1 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>5\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). Let\<^sub>d\<^sub>s (ostore_write (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, arr, (0 :: 32 word))) (\<lambda>ds\<^sub>5\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>5\<^sub>4,ds\<^sub>5\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>5\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>4 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>7 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>5\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5\<^sub>8 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>5\<^sub>9). HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) (\<lambda>fs_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (array_remove (arr, (1 :: 32 word))) P2_p1\<^sub>f) (\<lambda>(arr,ds\<^sub>6\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6\<^sub>0 P2_p2\<^sub>f) (\<lambda>(opto,ds\<^sub>6\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (get_data_back (ex, dummy_data, opto)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6\<^sub>2 P2_p2\<^sub>f) (\<lambda>(symname,ds\<^sub>6\<^sub>3). case_R (\<lambda>err. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopSymlinkRR.make ex fs_st vdir symname vnode, (R.Error err :: (32 word, unit) R))))))) (\<lambda>ds\<^sub>6\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>6\<^sub>5 (\<lambda>ds\<^sub>6\<^sub>6. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopSymlinkRR.make ex fs_st vdir symname vnode, (R.Success () :: (32 word, unit) R))))) r))))))))))))))) ds\<^sub>4\<^sub>7)) r)))))))))))) r)))) r)))))) ds\<^sub>2\<^sub>8))))) r))))))) r)))))))))))))))))"

definition
  fsop_unlink :: " FsopUnlinkP\<^sub>T \<Rightarrow>  FsopRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_unlink ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopLinkP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopLinkP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopLinkP.vdir\<^sub>f) (\<lambda>(vdir,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopLinkP.name\<^sub>f) (\<lambda>(name,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopLinkP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1). HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.If is_ro (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (Let\<^sub>d\<^sub>s (dentarr_read_and_del (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, vdir, name)) (\<lambda>ds\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>2). case_R (\<lambda>err. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>4. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(new_v_size,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(dentarr_obj,ds\<^sub>1\<^sub>6). HOL.Let (vfs_inode_dec_nlink vnode) (\<lambda>vnode. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>1\<^sub>8). HOL.Let (vfs_inode_get_ctime vnode) (\<lambda>vnode_ctime. HOL.Let (vfs_inode_set_ctime (vnode, time)) (\<lambda>vnode. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vnode)) (\<lambda>ds\<^sub>1\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>1). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. HOL.Let (vfs_inode_inc_nlink vnode) (\<lambda>vnode. HOL.Let (vfs_inode_set_ctime (vnode, vnode_ctime)) (\<lambda>vnode. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R)))))) (\<lambda>inode. HOL.Let (vfs_inode_get_size vdir) (\<lambda>v_size'. HOL.Let (vfs_inode_get_mtime vdir) (\<lambda>v_mtime'. HOL.Let (vfs_inode_get_ctime vdir) (\<lambda>v_ctime'. HOL.Let (vfs_inode_set_size (vdir, new_v_size)) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, time)) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, time)) (\<lambda>vdir. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vdir)) (\<lambda>ds\<^sub>2\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>5). case_R (\<lambda>err. HOL.Let (deep_freeObj (ex, dentarr_obj)) (\<lambda>ex. HOL.Let (deep_freeObj (ex, inode)) (\<lambda>ex. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (vfs_inode_inc_nlink vnode) (\<lambda>vnode. HOL.Let (vfs_inode_set_ctime (vnode, vnode_ctime)) (\<lambda>vnode. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R)))))))))) (\<lambda>dir. Let\<^sub>d\<^sub>s (arrayobj_create3 (ex, dentarr_obj, inode, dir)) (\<lambda>ds\<^sub>2\<^sub>7. case_R (\<lambda>ex. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (vfs_inode_inc_nlink vnode) (\<lambda>vnode. HOL.Let (vfs_inode_set_ctime (vnode, vnode_ctime)) (\<lambda>vnode. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R)))))))) (\<lambda>ds\<^sub>2\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>1). Let\<^sub>d\<^sub>s (ostore_write (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, arr, (0 :: 32 word))) (\<lambda>ds\<^sub>3\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>3,ds\<^sub>3\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>6 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>8). case_R (\<lambda>err. HOL.Let (vfs_inode_set_size (vdir, v_size')) (\<lambda>vdir. HOL.Let (vfs_inode_set_mtime (vdir, v_mtime')) (\<lambda>vdir. HOL.Let (vfs_inode_set_ctime (vdir, v_ctime')) (\<lambda>vdir. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. HOL.Let (vfs_inode_inc_nlink vnode) (\<lambda>vnode. HOL.Let (vfs_inode_set_ctime (vnode, vnode_ctime)) (\<lambda>vnode. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Error err :: (32 word, unit) R))))))))) (\<lambda>ds\<^sub>4\<^sub>0. Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>0 (\<lambda>ds\<^sub>4\<^sub>1. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vdir vnode, (R.Success () :: (32 word, unit) R))))) r))))))))) ds\<^sub>2\<^sub>7)) r)))))))))) r))))))))))) r)))))))))))))"

definition
  fsop_write_end :: " FsopWriteP\<^sub>T \<Rightarrow>  FsopWriteRR\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_write_end ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopWriteP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopWriteP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopWriteP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopWriteP.pos\<^sub>f) (\<lambda>(pos,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopWriteP.len\<^sub>f) (\<lambda>(len,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopWriteP.addr\<^sub>f) (\<lambda>(addr,ds\<^sub>1). HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.If is_ro (FsopWriteRR.make ex fs_st vnode addr, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (HOL.Let (vfs_inode_get_size vnode) (\<lambda>isize. HOL.Let (HOL.If ((>) ((+) pos (ucast len :: 64 word)) isize) ((+) pos (ucast len :: 64 word)) isize) (\<lambda>v_size. HOL.Let (vfs_inode_get_mtime vnode) (\<lambda>mtime. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>8). HOL.Let (vfs_inode_set_mtime (vnode, time)) (\<lambda>vnode. HOL.Let (vfs_inode_set_size (vnode, v_size)) (\<lambda>vnode. Let\<^sub>d\<^sub>s (obj_inode_new (ex, vnode)) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>1). case_R (\<lambda>err. (FsopWriteRR.make ex fs_st vnode addr, (R.Error err :: (32 word, unit) R))) (\<lambda>ovnode. Let\<^sub>d\<^sub>s (wordarray_create (ex, (1 :: 32 word))) (\<lambda>ds\<^sub>1\<^sub>3. case_R (\<lambda>ex. HOL.Let (deep_freeObj (ex, ovnode)) (\<lambda>ex. (FsopWriteRR.make ex fs_st vnode addr, (R.Error (12 :: 32 word) :: (32 word, unit) R)))) (\<lambda>ds\<^sub>1\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p2\<^sub>f) (\<lambda>(dummy_data,ds\<^sub>1\<^sub>7). HOL.Let (u64_to_u32 (checked_shift shiftr pos (12 :: 64 word))) (\<lambda>block. HOL.Let (obj_id_data_mk (vfs_inode_get_ino vnode, block)) (\<lambda>oid. HOL.Let ((AND) pos ((-) (4096 :: 64 word) (1 :: 64 word))) (\<lambda>start. HOL.Let ((+) (u64_to_u32 start) len) (\<lambda>end. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t addr Buffer.data\<^sub>f) (\<lambda>(data,addr). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (obj_data_new (ex, oid, end, data)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>9). case_R (\<lambda>ds\<^sub>2\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p2\<^sub>f) (\<lambda>(data,ds\<^sub>2\<^sub>3). HOL.Let (deep_freeObj (ex, ovnode)) (\<lambda>ex. HOL.Let (wordarray_free (ex, dummy_data)) (\<lambda>ex. HOL.Let (Buffer.data\<^sub>f_update (\<lambda>_. data) addr) (\<lambda>addr. (FsopWriteRR.make ex fs_st vnode addr, (R.Error err :: (32 word, unit) R)))))))) (\<lambda>odata. Let\<^sub>d\<^sub>s (arrayobj_create2 (ex, ovnode, odata)) (\<lambda>ds\<^sub>2\<^sub>2. case_R (\<lambda>ds\<^sub>2\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p2\<^sub>f) (\<lambda>(odata,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (get_data_back (ex, dummy_data, (Option.Some odata :: (unit,  Obj\<^sub>T) Option))) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P2_p2\<^sub>f) (\<lambda>(data,ds\<^sub>2\<^sub>8). HOL.Let (Buffer.data\<^sub>f_update (\<lambda>_. data) addr) (\<lambda>addr. (FsopWriteRR.make ex fs_st vnode addr, (R.Error (12 :: 32 word) :: (32 word, unit) R)))))))) (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). Let\<^sub>d\<^sub>s (ostore_write (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, arr, (0 :: 32 word))) (\<lambda>ds\<^sub>2\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>9,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (array_remove (arr, (1 :: 32 word))) P2_p1\<^sub>f) (\<lambda>(arr,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>5 P2_p2\<^sub>f) (\<lambda>(optobj,ds\<^sub>3\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (get_data_back (ex, dummy_data, optobj)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P2_p2\<^sub>f) (\<lambda>(data,ds\<^sub>3\<^sub>8). HOL.Let (Buffer.data\<^sub>f_update (\<lambda>_. data) addr) (\<lambda>addr. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. case_R (\<lambda>err. HOL.Let (vfs_inode_set_size (vnode, isize)) (\<lambda>vnode. HOL.Let (vfs_inode_set_mtime (vnode, mtime)) (\<lambda>vnode. (FsopWriteRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vnode addr, (R.Error err :: (32 word, unit) R))))) (\<lambda>ds\<^sub>4\<^sub>0. Let\<^sub>d\<^sub>s ds\<^sub>4\<^sub>0 (\<lambda>ds\<^sub>4\<^sub>1. (FsopWriteRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vnode addr, (R.Success () :: (32 word, unit) R)))) r)))))))))))))))) ds\<^sub>2\<^sub>2)) r)))))))))) ds\<^sub>1\<^sub>3)) r))))))))))))))))))"

definition
  fsop_write_inode :: " FsopVfsInodeP\<^sub>T \<Rightarrow>  FsopVfsInodeP\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_write_inode ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopIgetRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopIgetRR.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopIgetRR.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1). Let\<^sub>d\<^sub>s (obj_inode_new (ex, vnode)) (\<lambda>ds\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>6). case_R (\<lambda>err. (FsopIgetRR.make ex fs_st vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>oi. Let\<^sub>d\<^sub>s (arrayobj_create1 (ex, oi)) (\<lambda>ds\<^sub>8. case_R (\<lambda>ex. (FsopIgetRR.make ex fs_st vnode, (R.Error (12 :: 32 word) :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(arr,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). Let\<^sub>d\<^sub>s (ostore_write (ex, FsState.mount_st\<^sub>f fs_st, ostore_st, arr, (0 :: 32 word))) (\<lambda>ds\<^sub>1\<^sub>3. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>4,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P3_p3\<^sub>f) (\<lambda>(arr,ds\<^sub>1\<^sub>9). case_R (\<lambda>err. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopIgetRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vnode, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>2\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>1 (\<lambda>ds\<^sub>2\<^sub>2. HOL.Let (array_free (ArrayFreeP.make arr deep_freeObj ex)) (\<lambda>ex. (FsopIgetRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st) vnode, (R.Success () :: (32 word, unit) R))))) r)))))))))) ds\<^sub>8)) r))))))"

definition
  fsop_do_setattr :: " FsopSetattrP\<^sub>T \<Rightarrow>  FsopVfsInodeP\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_do_setattr ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopSetattrP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopSetattrP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopSetattrP.iattr\<^sub>f) (\<lambda>(iattr,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopSetattrP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1). HOL.Let (vfs_inode_get_mode vnode) (\<lambda>mode. HOL.Let (vfs_inode_get_uid vnode) (\<lambda>uid. HOL.Let (vfs_inode_get_gid vnode) (\<lambda>gid. HOL.Let (vfs_inode_get_mtime vnode) (\<lambda>mtime. HOL.Let (vfs_inode_get_ctime vnode) (\<lambda>ctime. HOL.Let (vfs_iattr_get_valid iattr) (\<lambda>valid. HOL.Let (HOL.If (is_set (valid, checked_shift shiftl (1 :: 32 word) (0 :: 32 word))) (vfs_inode_set_mode (vnode, vfs_iattr_get_mode iattr)) vnode) (\<lambda>vnode. HOL.Let (HOL.If (is_set (valid, checked_shift shiftl (1 :: 32 word) (1 :: 32 word))) (vfs_inode_set_uid (vnode, vfs_iattr_get_uid iattr)) vnode) (\<lambda>vnode. HOL.Let (HOL.If (is_set (valid, checked_shift shiftl (1 :: 32 word) (2 :: 32 word))) (vfs_inode_set_gid (vnode, vfs_iattr_get_gid iattr)) vnode) (\<lambda>vnode. HOL.Let (HOL.If (is_set (valid, checked_shift shiftl (1 :: 32 word) (5 :: 32 word))) (vfs_inode_set_mtime (vnode, vfs_iattr_get_mtime iattr)) vnode) (\<lambda>vnode. HOL.Let (HOL.If (is_set (valid, checked_shift shiftl (1 :: 32 word) (6 :: 32 word))) (vfs_inode_set_ctime (vnode, vfs_iattr_get_ctime iattr)) vnode) (\<lambda>vnode. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsop_write_inode (FsopIgetRR.make ex fs_st vnode)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>5,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopIgetRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 FsopIgetRR.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 FsopIgetRR.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>8). case_R (\<lambda>err. HOL.Let (vfs_inode_set_mode (vnode, mode)) (\<lambda>vnode. HOL.Let (vfs_inode_set_uid (vnode, uid)) (\<lambda>vnode. HOL.Let (vfs_inode_set_gid (vnode, gid)) (\<lambda>vnode. HOL.Let (vfs_inode_set_mtime (vnode, mtime)) (\<lambda>vnode. HOL.Let (vfs_inode_set_ctime (vnode, ctime)) (\<lambda>vnode. (FsopIgetRR.make ex fs_st vnode, (R.Error err :: (32 word, unit) R)))))))) (\<lambda>ds\<^sub>1\<^sub>2. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>2 (\<lambda>ds\<^sub>1\<^sub>3. (FsopIgetRR.make ex fs_st vnode, (R.Success () :: (32 word, unit) R)))) r))))))))))))))))))))"

definition
  fsop_setattr :: " FsopSetattrP\<^sub>T \<Rightarrow>  FsopVfsInodeP\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_setattr ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopSetattrP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopSetattrP.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopSetattrP.iattr\<^sub>f) (\<lambda>(iattr,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsopSetattrP.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>1). HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.Let (vfs_iattr_get_valid iattr) (\<lambda>valid. HOL.If is_ro (FsopIgetRR.make ex fs_st vnode, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (HOL.If (is_set (valid, checked_shift shiftl (1 :: 32 word) (3 :: 32 word))) (HOL.Let (vfs_iattr_get_size iattr) (\<lambda>newsize. fsop_do_truncate (FsopTruncateP.make ex fs_st vnode newsize))) (fsop_do_setattr (FsopSetattrP.make ex fs_st iattr vnode)))))))))"

definition
  fsop_format_default :: " FsopVfsInodeP\<^sub>T \<Rightarrow>  FsopVfsInodeP\<^sub>T \<times> (32 word, unit) R"
where
  "fsop_format_default ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopIgetRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopIgetRR.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopIgetRR.vnode\<^sub>f) (\<lambda>(root,ds\<^sub>1). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>4. HOL.Let (FsopState.is_ro\<^sub>f (FsState.fsop_st\<^sub>f fs_st)) (\<lambda>is_ro. HOL.If is_ro (FsopIgetRR.make ex fs_st root, (R.Error (30 :: 32 word) :: (32 word, unit) R)) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.mount_st\<^sub>f) (\<lambda>(mount_st,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). HOL.Let (OstoreState.next_inum\<^sub>f_update (\<lambda>_. (+) (24 :: 32 word) (1 :: 32 word)) ostore_st) (\<lambda>ostore_st. HOL.Let (vfs_inode_set_ino (root, (24 :: 32 word))) (\<lambda>root. HOL.Let (vfs_inode_set_nlink (root, (2 :: 32 word))) (\<lambda>root. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (os_get_current_time ex) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(time,ds\<^sub>7). HOL.Let (vfs_inode_set_mtime (root, time)) (\<lambda>root. HOL.Let (vfs_inode_set_ctime (root, time)) (\<lambda>root. HOL.Let (vfs_inode_set_uid (root, os_get_current_fsuid ex)) (\<lambda>root. HOL.Let (vfs_inode_set_mode (root, (OR) ((OR) ((OR) (16384 :: 32 word) ((OR) ((OR) (256 :: 32 word) (32 :: 32 word)) (4 :: 32 word))) (128 :: 32 word)) ((OR) ((OR) (64 :: 32 word) (8 :: 32 word)) (1 :: 32 word)))) (\<lambda>root. HOL.Let (vfs_inode_set_gid (root, os_get_current_fsgid ex)) (\<lambda>root. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_write_super (ex, mount_st, ostore_st)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>3). case_R (\<lambda>err. HOL.Let (OstoreState.used\<^sub>f_update (\<lambda>_. (0 :: 32 word)) ostore_st) (\<lambda>ostore_st. (FsopIgetRR.make ex (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st)) root, (R.Error err :: (32 word, unit) R)))) (\<lambda>ds\<^sub>1\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>5 (\<lambda>ds\<^sub>1\<^sub>6. Let\<^sub>d\<^sub>s (ostore_new_wbuf (mount_st, ostore_st, (0 :: 32 word))) (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p1\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>9). case_R (\<lambda>err. (FsopIgetRR.make ex (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st)) root, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>2\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>1 (\<lambda>ds\<^sub>2\<^sub>2. HOL.Let (OstoreState.used\<^sub>f_update (\<lambda>_. (0 :: 32 word)) ostore_st) (\<lambda>ostore_st. HOL.Let (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) fs_st)) (\<lambda>fs_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsop_write_inode (FsopIgetRR.make ex fs_st root)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>3,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 FsopIgetRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 FsopIgetRR.fs_st\<^sub>f) (\<lambda>(fs_st,ds\<^sub>2\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 FsopIgetRR.vnode\<^sub>f) (\<lambda>(vnode,ds\<^sub>2\<^sub>6). case_R (\<lambda>err. (FsopIgetRR.make ex fs_st vnode, (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>3\<^sub>0. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>0 (\<lambda>ds\<^sub>3\<^sub>1. (FsopIgetRR.make ex fs_st vnode, (R.Success () :: (32 word, unit) R)))) r))))))))) r))))) r)))))))))))))))))))))))"

definition
  proc_obj_or_objsdel_loop :: "( Obj\<^sub>T,  SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List',  MountState\<^sub>T \<times> 32 word) ElemAO \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List',  SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') LoopResult"
where
  "proc_obj_or_objsdel_loop ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(obj,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P3_p3\<^sub>f) (\<lambda>(objsdel,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(eb,ds\<^sub>1\<^sub>0). HOL.Let (Let\<^sub>d\<^sub>s (Obj.ounion\<^sub>f obj) (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (\<lambda>ds\<^sub>1\<^sub>2. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>2 (\<lambda>ds\<^sub>1\<^sub>3. False)) (\<lambda>ccase\<^sub>G\<^sub>1. case_ObjUnion (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjData v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v. True) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjDentarr v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjInode v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjPad v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjSummary v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) (\<lambda>v\<^sub>G\<^sub>0. ccase\<^sub>G\<^sub>1 (ObjUnion.TObjSuper v\<^sub>G\<^sub>0 ::  ObjUnion\<^sub>T)) ds\<^sub>1\<^sub>1))) (\<lambda>is_del. HOL.If is_del (Let\<^sub>d\<^sub>s (new_delnode_init (ex, obj, eb)) (\<lambda>ds\<^sub>1\<^sub>2. case_R (\<lambda>ex. (LoopResult.Break (ex, ostore_st, objsdel) :: ( SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List',  SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') LoopResult)) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(node,ds\<^sub>1\<^sub>6). HOL.Let (list_add_node (objsdel, node)) (\<lambda>objsdel. (LoopResult.Iterate (ex, ostore_st, objsdel) :: ( SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List',  SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') LoopResult))))) ds\<^sub>1\<^sub>2)) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (proc_obj (ex, mount_st, ostore_st, obj, eb)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>4). (LoopResult.Iterate (ex, ostore_st, objsdel) :: ( SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List',  SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') LoopResult)))))))))))))"

definition
  scan_transaction :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List' \<times>  Obj\<^sub>T Array \<times> 32 word \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List' \<times>  Obj\<^sub>T Array) \<times> (32 word, 32 word) R"
where
  "scan_transaction ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P7_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P7_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P7_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P7_p4\<^sub>f) (\<lambda>(objsdel,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P7_p5\<^sub>f) (\<lambda>(objs,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P7_p6\<^sub>f) (\<lambda>(eb,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P7_p7\<^sub>f) (\<lambda>(offs,ds\<^sub>7). HOL.Let (array_length objs) (\<lambda>len. Let\<^sub>d\<^sub>s (array_map (ArrayMapP.make objs (0 :: 32 word) len scan_trans_obj (ex, offs) (mount_st, OstoreState.rbuf\<^sub>f ostore_st))) (\<lambda>ds\<^sub>8. case_LoopResult (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(objs,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(res,ds\<^sub>1\<^sub>3). case_R (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p2\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). ((ex, ostore_st, objsdel, objs), (R.Error err :: (32 word, 32 word) R))))) (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>8). HOL.Let (array_nb_elem objs) (\<lambda>nb_nodes. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_alloc_pools (ex, ostore_st, nb_nodes)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>9,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>3). case_R (\<lambda>e. ((ex, ostore_st, objsdel, objs), (R.Error e :: (32 word, 32 word) R))) (\<lambda>ds\<^sub>2\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>5 (\<lambda>ds\<^sub>2\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.summary\<^sub>f) (\<lambda>(summary,ostore_st). Let\<^sub>d\<^sub>s (array_fold (ArrayFoldP.make objs proc_obj_or_objsdel_loop (ex, ostore_st, objsdel) (mount_st, eb))) (\<lambda>ds\<^sub>2\<^sub>7. case_LoopResult (\<lambda>ds\<^sub>2\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P3_p3\<^sub>f) (\<lambda>(objsdel,ds\<^sub>3\<^sub>2). HOL.Let (OstoreState.summary\<^sub>f_update (\<lambda>_. summary) ostore_st) (\<lambda>ostore_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_free_pools (ex, ostore_st)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>4). ((ex, ostore_st, objsdel, objs), (R.Error (22 :: 32 word) :: (32 word, 32 word) R))))))))) (\<lambda>ds\<^sub>3\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P3_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P3_p3\<^sub>f) (\<lambda>(objsdel,ds\<^sub>3\<^sub>3). HOL.Let (OstoreState.summary\<^sub>f_update (\<lambda>_. summary) ostore_st) (\<lambda>ostore_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_free_pools (ex, ostore_st)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>5). ((ex, ostore_st, objsdel, objs), (R.Success offs :: (32 word, 32 word) R))))))))) ds\<^sub>2\<^sub>7)))) r)))))))) res))) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(objs,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>1,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>5). Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>6. ((ex, ostore_st, objsdel, objs), (R.Error (22 :: 32 word) :: (32 word, 32 word) R)))))))) ds\<^sub>8)))))))))"

definition
  scan_transaction_loop :: "( SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List' \<times>  Obj\<^sub>T Array \<times> 32 word,  MountState\<^sub>T \<times> 32 word, 32 word) Seq32_bodyParam \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List' \<times>  Obj\<^sub>T Array \<times> 32 word) \<times> ((32 word, unit) R, unit) LoopResult"
where
  "scan_transaction_loop ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 Seq32_bodyParam.acc\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P5_p3\<^sub>f) (\<lambda>(objsdel,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P5_p4\<^sub>f) (\<lambda>(objs,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P5_p5\<^sub>f) (\<lambda>(offs,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 Seq32_bodyParam.obsv\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>0,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p2\<^sub>f) (\<lambda>(eb,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 Seq32_bodyParam.idx\<^sub>f) (\<lambda>(nb_trans,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (scan_transaction (ex, mount_st, ostore_st, objsdel, objs, eb, offs)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>3,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P4_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P4_p3\<^sub>f) (\<lambda>(objsdel,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P4_p4\<^sub>f) (\<lambda>(objs,ds\<^sub>1\<^sub>9). case_R (\<lambda>err. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (array_filter (ArrayFoldP.make objs object_eraser ex ())) ArrA.arr\<^sub>f) (\<lambda>(objs,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 ArrA.acc\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>2). HOL.Let (align32 (offs, ObjSuper.io_size\<^sub>f (MountState.super\<^sub>f mount_st))) (\<lambda>aligned_offs. HOL.If ((<) ((-) aligned_offs offs) (24 :: 32 word)) (HOL.If ((=) aligned_offs (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>4. ((ex, ostore_st, objsdel, objs, (0 :: 32 word)), (LoopResult.Break (R.Success () :: (32 word, unit) R) :: ((32 word, unit) R, unit) LoopResult)))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>5. HOL.If ((=) aligned_offs offs) ((ex, ostore_st, objsdel, objs, aligned_offs), (LoopResult.Break (R.Error (88 :: 32 word) :: (32 word, unit) R) :: ((32 word, unit) R, unit) LoopResult)) ((ex, ostore_st, objsdel, objs, aligned_offs), (LoopResult.Iterate () :: ((32 word, unit) R, unit) LoopResult))))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>6. ((ex, ostore_st, objsdel, objs, offs), (LoopResult.Break (R.Error err :: (32 word, unit) R) :: ((32 word, unit) R, unit) LoopResult))))))))) (\<lambda>offs'. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (array_filter (ArrayFoldP.make objs object_eraser ex ())) ArrA.arr\<^sub>f) (\<lambda>(objs,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 ArrA.acc\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>1). HOL.If ((<) offs' (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>3. ((ex, ostore_st, objsdel, objs, offs'), (LoopResult.Iterate () :: ((32 word, unit) R, unit) LoopResult)))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>4. ((ex, ostore_st, objsdel, objs, (0 :: 32 word)), (LoopResult.Break (R.Success () :: (32 word, unit) R) :: ((32 word, unit) R, unit) LoopResult))))))) r))))))))))))))))"

definition
  mount_scan_rbuf :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List' \<times>  Obj\<^sub>T Array \<times> 32 word \<Rightarrow> ( SysState \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List' \<times>  Obj\<^sub>T Array) \<times> (32 word \<times> 32 word, unit) R"
where
  "mount_scan_rbuf ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P6_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P6_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P6_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P6_p4\<^sub>f) (\<lambda>(objsdel,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P6_p5\<^sub>f) (\<lambda>(objs,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P6_p6\<^sub>f) (\<lambda>(eb,ds\<^sub>6). HOL.Let (0 :: 32 word) (\<lambda>offs. HOL.Let (checked_div (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) (24 :: 32 word)) (\<lambda>max_nb_trans. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (seq32 (Seq32Param.make (0 :: 32 word) ((+) max_nb_trans (1 :: 32 word)) (1 :: 32 word) scan_transaction_loop (ex, ostore_st, objsdel, objs, offs) (mount_st, eb))) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>7,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P5_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P5_p3\<^sub>f) (\<lambda>(objsdel,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P5_p4\<^sub>f) (\<lambda>(objs,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P5_p5\<^sub>f) (\<lambda>(offs,ds\<^sub>1\<^sub>4). case_LoopResult (\<lambda>res. case_R (\<lambda>err. ((ex, ostore_st, objsdel, objs), (R.Error (err, offs) :: (32 word \<times> 32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>8 (\<lambda>ds\<^sub>1\<^sub>9. ((ex, ostore_st, objsdel, objs), (R.Success () :: (32 word \<times> 32 word, unit) R)))) res) (\<lambda>ds\<^sub>1\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>5 (\<lambda>ds\<^sub>1\<^sub>7. Let\<^sub>d\<^sub>s (cogent_assert False) (\<lambda>ds\<^sub>1\<^sub>8. ((ex, ostore_st, objsdel, objs), (R.Error ((22 :: 32 word), offs) :: (32 word \<times> 32 word, unit) R))))) r)))))))))))))))"

definition
  mount_scan_full_eb :: "( SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List' \<times>  Obj\<^sub>T Array, unit, 32 word) Seq32_bodyParam \<Rightarrow> ( SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List' \<times>  Obj\<^sub>T Array) \<times> (32 word, unit) LoopResult"
where
  "mount_scan_full_eb ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 Seq32_bodyParam.acc\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P5_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P5_p4\<^sub>f) (\<lambda>(objsdel,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P5_p5\<^sub>f) (\<lambda>(objs,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 Seq32_bodyParam.obsv\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>0,ds\<^sub>9). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>0 (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 Seq32_bodyParam.idx\<^sub>f) (\<lambda>(eb,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.fsm_st\<^sub>f) (\<lambda>(fsm_st,ostore_st). HOL.Let (fsm_mark_used (mount_st, fsm_st, eb)) (\<lambda>fsm_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (OstoreState.fsm_st\<^sub>f_update (\<lambda>_. fsm_st) ostore_st) OstoreState.rbuf\<^sub>f) (\<lambda>(rbuf,ostore_st). Let\<^sub>d\<^sub>s (wbuf_read_leb (ex, mount_st, OstoreState.ubi_vol\<^sub>f ostore_st, rbuf, eb)) (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>3,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p2\<^sub>f) (\<lambda>(rbuf,ds\<^sub>1\<^sub>7). case_R (\<lambda>err. ((ex, mount_st, OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st, objsdel, objs), (LoopResult.Break err :: (32 word, unit) LoopResult))) (\<lambda>ds\<^sub>1\<^sub>9. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>9 (\<lambda>ds\<^sub>2\<^sub>0. HOL.Let (OstoreState.rbuf\<^sub>f_update (\<lambda>_. rbuf) ostore_st) (\<lambda>ostore_st. Let\<^sub>d\<^sub>s (mount_scan_rbuf (ex, mount_st, ostore_st, objsdel, objs, eb)) (\<lambda>ds\<^sub>2\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>2,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P4_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P4_p3\<^sub>f) (\<lambda>(objsdel,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>7 P4_p4\<^sub>f) (\<lambda>(objs,ds\<^sub>2\<^sub>8). case_R (\<lambda>ds\<^sub>2\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P2_p1\<^sub>f) (\<lambda>(err,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P2_p2\<^sub>f) (\<lambda>(offs,ds\<^sub>3\<^sub>2). HOL.If ((~=) err (88 :: 32 word)) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>3\<^sub>3. ((ex, mount_st, ostore_st, objsdel, objs), (LoopResult.Break err :: (32 word, unit) LoopResult)))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>3\<^sub>4. HOL.Let (MountState.eb_recovery\<^sub>f mount_st) (\<lambda>eb_recovery. HOL.Let ((~=) eb_recovery (0 :: 32 word)) (\<lambda>has_eb_to_recover. HOL.If has_eb_to_recover (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>3\<^sub>5. HOL.Let (MountState.eb_recovery\<^sub>f_update (\<lambda>_. (0 :: 32 word)) mount_st) (\<lambda>mount_st. ((ex, mount_st, ostore_st, objsdel, objs), (LoopResult.Break (9 :: 32 word) :: (32 word, unit) LoopResult))))) (HOL.Let (MountState.eb_recovery_offs\<^sub>f_update (\<lambda>_. offs) (MountState.eb_recovery\<^sub>f_update (\<lambda>_. eb) mount_st)) (\<lambda>mount_st. ((ex, mount_st, ostore_st, objsdel, objs), (LoopResult.Iterate () :: (32 word, unit) LoopResult))))))))))) (\<lambda>ds\<^sub>3\<^sub>1. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>1 (\<lambda>ds\<^sub>3\<^sub>2. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>3\<^sub>3. ((ex, mount_st, ostore_st, objsdel, objs), (LoopResult.Iterate () :: (32 word, unit) LoopResult))))) r)))))))))) r)))))))))))))))))"

definition
  proc_sum_entry :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  ObjSumEntry\<^sub>T \<times> 32 word \<Rightarrow>  SysState \<times>  OstoreState\<^sub>T"
where
  "proc_sum_entry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P5_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p4\<^sub>f) (\<lambda>(entry,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p5\<^sub>f) (\<lambda>(ebnum,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.oaddr\<^sub>f) (\<lambda>(oaddr,ostore_st). HOL.Let (ObjAddr.sqnum\<^sub>f_update (\<lambda>_. ObjSumEntry.sqnum\<^sub>f entry) (ObjAddr.len\<^sub>f_update (\<lambda>_. ObjSumEntry.len\<^sub>f entry) (ObjAddr.offs\<^sub>f_update (\<lambda>_. obj_sum_entry_offs entry) (ObjAddr.ebnum\<^sub>f_update (\<lambda>_. ebnum) oaddr)))) (\<lambda>oaddr. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (update_obj (ex, mount_st, ostore_st, ObjSumEntry.id\<^sub>f entry, oaddr)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>7). Let\<^sub>d\<^sub>s (HOL.If ((=) (inum_from_obj_id (ObjSumEntry.id\<^sub>f entry)) (24 :: 32 word)) () ()) (\<lambda>ds\<^sub>8. (ex, OstoreState.oaddr\<^sub>f_update (\<lambda>_. oaddr) ostore_st)))))))))))"

definition
  scan_summary_proc_entry :: "( ObjSumEntry\<^sub>T,  SysState \<times> 32 word \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List',  MountState\<^sub>T \<times> 32 word) ElemAO \<Rightarrow> (( SysState \<times> 32 word \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') \<times> 32 word,  SysState \<times> 32 word \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') LoopResult"
where
  "scan_summary_proc_entry ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 ElemAO.elem\<^sub>f) (\<lambda>(sum_entry,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 ElemAO.acc\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P4_p2\<^sub>f) (\<lambda>(tot_used,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P4_p4\<^sub>f) (\<lambda>(objsdel,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 ElemAO.obsv\<^sub>f) (\<lambda>(ds\<^sub>9,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(mount_st,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(eb,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.fsm_st\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 OstoreState.pools\<^sub>f) (\<lambda>(pools,ostore_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t pools AllocPools.gim\<^sub>f) (\<lambda>(gim,pools). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsm_set_garbage (ex, mount_st, fsm_st, gim, ObjSumEntry.id\<^sub>f sum_entry, ObjSumEntry.sqnum\<^sub>f sum_entry, ObjSumEntry.count\<^sub>f sum_entry)) P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P3_p2\<^sub>f) (\<lambda>(fsm_st,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P3_p3\<^sub>f) (\<lambda>(gim,ds\<^sub>1\<^sub>5). HOL.Let (AllocPools.gim\<^sub>f_update (\<lambda>_. gim) pools) (\<lambda>pools. HOL.Let (OstoreState.pools\<^sub>f_update (\<lambda>_. pools) (OstoreState.fsm_st\<^sub>f_update (\<lambda>_. fsm_st) ostore_st)) (\<lambda>ostore_st. HOL.If (HOL.Not (obj_sum_entry_is_del sum_entry)) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (proc_sum_entry (ex, mount_st, ostore_st, sum_entry, eb)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>7). (LoopResult.Iterate (ex, (+) tot_used (ObjSumEntry.len\<^sub>f sum_entry), ostore_st, objsdel) :: (( SysState \<times> 32 word \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') \<times> 32 word,  SysState \<times> 32 word \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') LoopResult)))) (Let\<^sub>d\<^sub>s (new_delnode_sum_init (ex, sum_entry, eb)) (\<lambda>ds\<^sub>1\<^sub>7. case_R (\<lambda>ex. (LoopResult.Break ((ex, (+) tot_used (ObjSumEntry.len\<^sub>f sum_entry), ostore_st, objsdel), (12 :: 32 word)) :: (( SysState \<times> 32 word \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') \<times> 32 word,  SysState \<times> 32 word \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') LoopResult)) (\<lambda>ds\<^sub>1\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(node,ds\<^sub>2\<^sub>1). HOL.Let (list_add_node (objsdel, node)) (\<lambda>objsdel. (LoopResult.Iterate (ex, (+) tot_used (ObjSumEntry.len\<^sub>f sum_entry), ostore_st, objsdel) :: (( SysState \<times> 32 word \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') \<times> 32 word,  SysState \<times> 32 word \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') LoopResult))))) ds\<^sub>1\<^sub>7)))))))))))))))))))"

definition
  mount_scan_summary :: "( SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List', unit, 32 word) Seq32_bodyParam \<Rightarrow> ( SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List') \<times> (32 word, unit) LoopResult"
where
  "mount_scan_summary ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 Seq32_bodyParam.acc\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P4_p3\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P4_p4\<^sub>f) (\<lambda>(objsdel,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 OstoreState.fsm_st\<^sub>f) (\<lambda>(fsm_st,ostore_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 Seq32_bodyParam.obsv\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>0,ds\<^sub>9). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>0 (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 Seq32_bodyParam.idx\<^sub>f) (\<lambda>(eb,ds\<^sub>1). HOL.Let (fsm_mark_used (mount_st, fsm_st, eb)) (\<lambda>fsm_st. HOL.Let (OstoreState.fsm_st\<^sub>f_update (\<lambda>_. fsm_st) ostore_st) (\<lambda>ostore_st. Let\<^sub>d\<^sub>s (ostore_read_sum (ex, mount_st, ostore_st, eb)) (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>3,ds\<^sub>1\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>6 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>7). case_R (\<lambda>e. ((ex, mount_st, ostore_st, objsdel), (LoopResult.Break e :: (32 word, unit) LoopResult))) (\<lambda>sum_offs. HOL.Let (ObjSummary.nb_sum_entry\<^sub>f (OstoreState.summary\<^sub>f ostore_st)) (\<lambda>sum_nb_entry. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_alloc_pools (ex, ostore_st, sum_nb_entry)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>9,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>3). case_R (\<lambda>e. ((ex, mount_st, ostore_st, objsdel), (LoopResult.Break e :: (32 word, unit) LoopResult))) (\<lambda>ds\<^sub>2\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>5 (\<lambda>ds\<^sub>2\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.summary\<^sub>f) (\<lambda>(summary,ostore_st). Let\<^sub>d\<^sub>s (wordarray_fold (ArrayMapP.make (ObjSummary.entries\<^sub>f summary) (0 :: 32 word) (ObjSummary.nb_sum_entry\<^sub>f summary) scan_summary_proc_entry (ex, (0 :: 32 word), ostore_st, objsdel) (mount_st, eb))) (\<lambda>ds\<^sub>2\<^sub>7. case_LoopResult (\<lambda>ds\<^sub>2\<^sub>8. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P2_p1\<^sub>f) (\<lambda>(ds\<^sub>3\<^sub>0,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P2_p2\<^sub>f) (\<lambda>(e,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P4_p2\<^sub>f) (\<lambda>(tot_used,ds\<^sub>3\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>4 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>5 P4_p4\<^sub>f) (\<lambda>(objsdel,ds\<^sub>3\<^sub>6). HOL.Let (OstoreState.summary\<^sub>f_update (\<lambda>_. summary) ostore_st) (\<lambda>ostore_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_free_pools (ex, ostore_st)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>7 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>8). ((ex, mount_st, ostore_st, objsdel), (LoopResult.Break e :: (32 word, unit) LoopResult)))))))))))) (\<lambda>ds\<^sub>3\<^sub>0. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>1 P4_p2\<^sub>f) (\<lambda>(tot_used,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P4_p4\<^sub>f) (\<lambda>(objsdel,ds\<^sub>3\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (OstoreState.summary\<^sub>f_update (\<lambda>_. summary) ostore_st) OstoreState.fsm_st\<^sub>f) (\<lambda>(fsm_st,ostore_st). HOL.Let (ObjSuper.eb_size\<^sub>f (MountState.super\<^sub>f mount_st)) (\<lambda>eb_size. HOL.Let (fsm_mark_ebnum_dirty (fsm_st, eb, (-) eb_size tot_used)) (\<lambda>fsm_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_free_pools (ex, OstoreState.fsm_st\<^sub>f_update (\<lambda>_. fsm_st) ostore_st)) P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>5 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>6). ((ex, mount_st, ostore_st, objsdel), (LoopResult.Iterate () :: (32 word, unit) LoopResult)))))))))))) ds\<^sub>2\<^sub>7)))) r)))))) r))))))))))))))))"

definition
  mount_scan_loop :: "( SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List' \<times>  Obj\<^sub>T Array, unit, 32 word) Seq32_bodyParam \<Rightarrow> ( SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<times>  DelNode\<^sub>T ListNode List' \<times>  Obj\<^sub>T Array) \<times> (32 word, unit) LoopResult"
where
  "mount_scan_loop ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 Seq32_bodyParam.acc\<^sub>f) (\<lambda>(ds\<^sub>3,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>4). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P5_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P5_p4\<^sub>f) (\<lambda>(objsdel,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P5_p5\<^sub>f) (\<lambda>(objs,ds\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 Seq32_bodyParam.obsv\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>0,ds\<^sub>9). Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>0 (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 Seq32_bodyParam.idx\<^sub>f) (\<lambda>(eb,ds\<^sub>1). Let\<^sub>d\<^sub>s (wubi_is_mapped (WubiIsMappedP.make ex (OstoreState.ubi_vol\<^sub>f ostore_st) eb)) (\<lambda>ds\<^sub>1\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>3 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>4). HOL.Let (MountState.no_summary\<^sub>f mount_st) (\<lambda>no_summary. case_R (\<lambda>err. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>6. ((ex, mount_st, ostore_st, objsdel, objs), (LoopResult.Break err :: (32 word, unit) LoopResult)))) (\<lambda>is_mapped. HOL.If (HOL.Not is_mapped) ((ex, mount_st, ostore_st, objsdel, objs), (LoopResult.Iterate () :: (32 word, unit) LoopResult)) (HOL.If no_summary (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>6. mount_scan_full_eb (Seq32_bodyParam.make (ex, mount_st, ostore_st, objsdel, objs) () eb))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>1\<^sub>7. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (mount_scan_summary (Seq32_bodyParam.make (ex, mount_st, ostore_st, objsdel) () eb)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>8,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P4_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P4_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>2 P4_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>3 P4_p4\<^sub>f) (\<lambda>(objsdel,ds\<^sub>2\<^sub>4). case_LoopResult (\<lambda>e. HOL.If ((=) e (12 :: 32 word)) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>6. ((ex, mount_st, ostore_st, objsdel, objs), (LoopResult.Break (12 :: 32 word) :: (32 word, unit) LoopResult)))) (Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>2\<^sub>7. mount_scan_full_eb (Seq32_bodyParam.make (ex, mount_st, ostore_st, objsdel, objs) () eb)))) (\<lambda>ds\<^sub>2\<^sub>6. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>6 (\<lambda>ds\<^sub>2\<^sub>7. ((ex, mount_st, ostore_st, objsdel, objs), (LoopResult.Iterate () :: (32 word, unit) LoopResult)))) r)))))))))) r)))))))))))))"

definition
  mount_scan :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<Rightarrow> ( SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T) \<times> (32 word, bool) R"
where
  "mount_scan ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). Let\<^sub>d\<^sub>s (list_create ex) (\<lambda>ds\<^sub>4. case_R (\<lambda>ex. ((ex, mount_st, ostore_st), (R.Error (12 :: 32 word) :: (32 word, bool) R))) (\<lambda>ds\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>7 P2_p2\<^sub>f) (\<lambda>(objsdel,ds\<^sub>8). HOL.Let (ObjSuper.nb_eb\<^sub>f (MountState.super\<^sub>f mount_st)) (\<lambda>nb_eb. Let\<^sub>d\<^sub>s (array_create (ex, (2048 :: 32 word))) (\<lambda>ds\<^sub>9. case_R (\<lambda>ex. HOL.Let (list_free (ListFreeP.make objsdel freeListNode ex)) (\<lambda>ex. ((ex, mount_st, ostore_st), (R.Error (12 :: 32 word) :: (32 word, bool) R)))) (\<lambda>ds\<^sub>1\<^sub>1. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P2_p2\<^sub>f) (\<lambda>(objs,ds\<^sub>1\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (seq32 (Seq32Param.make (2 :: 32 word) nb_eb (1 :: 32 word) mount_scan_loop (ex, mount_st, ostore_st, objsdel, objs) ())) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>4,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P5_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P5_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P5_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>9 P5_p4\<^sub>f) (\<lambda>(objsdel,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P5_p5\<^sub>f) (\<lambda>(objs,ds\<^sub>2\<^sub>1). case_LoopResult (\<lambda>err. HOL.Let (list_free (ListFreeP.make objsdel freeListNode ex)) (\<lambda>ex. HOL.Let (array_free (ArrayFreeP.make objs deep_freeObj ex)) (\<lambda>ex. ((ex, mount_st, ostore_st), (R.Error err :: (32 word, bool) R))))) (\<lambda>ds\<^sub>2\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>3 (\<lambda>ds\<^sub>2\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (mount_recover (ex, mount_st, ostore_st)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>5,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>8 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>0). case_R (\<lambda>err. HOL.Let (list_free (ListFreeP.make objsdel freeListNode ex)) (\<lambda>ex. HOL.Let (array_free (ArrayFreeP.make objs deep_freeObj ex)) (\<lambda>ex. ((ex, mount_st, ostore_st), (R.Error err :: (32 word, bool) R))))) (\<lambda>alloc_neweb. Let\<^sub>d\<^sub>s (proc_objsdel (ex, mount_st, ostore_st, objsdel)) (\<lambda>ds\<^sub>3\<^sub>2. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>3\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 P2_p2\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3\<^sub>4). HOL.Let (list_free (ListFreeP.make objsdel freeListNode ex)) (\<lambda>ex. HOL.Let (array_free (ArrayFreeP.make objs deep_freeObj ex)) (\<lambda>ex. ((ex, mount_st, ostore_st), (R.Success alloc_neweb :: (32 word, bool) R)))))))) r))))))) r)))))))))) ds\<^sub>9))))) ds\<^sub>4))))"

definition
  ostore_mount :: " SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T \<Rightarrow> ( SysState \<times>  MountState\<^sub>T \<times>  OstoreState\<^sub>T) \<times> (32 word, unit) R"
where
  "ostore_mount ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>3). Let\<^sub>d\<^sub>s (check_flash_is_empty (ex, mount_st, OstoreState.ubi_vol\<^sub>f ostore_st)) (\<lambda>ds\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>6). case_R (\<lambda>err. ((ex, mount_st, ostore_st), (R.Error err :: (32 word, unit) R))) (\<lambda>is_empty. HOL.If is_empty ((ex, mount_st, ostore_st), (R.Error (42 :: 32 word) :: (32 word, unit) R)) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (mount_read_super (ex, mount_st, ostore_st)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>8,ds\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>8 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>1 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>1\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>2 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>1\<^sub>3). case_R (\<lambda>err. ((ex, mount_st, ostore_st), (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>1\<^sub>5. Let\<^sub>d\<^sub>s ds\<^sub>1\<^sub>5 (\<lambda>ds\<^sub>1\<^sub>6. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (mount_scan (ex, mount_st, ostore_st)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>7,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>2). case_R (\<lambda>err. ((ex, mount_st, ostore_st), (R.Error err :: (32 word, unit) R))) (\<lambda>alloc. HOL.If alloc (Let\<^sub>d\<^sub>s (ostore_new_wbuf (mount_st, ostore_st, (0 :: 32 word))) (\<lambda>ds\<^sub>2\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>6). case_R (\<lambda>err. ((ex, mount_st, ostore_st), (R.Error err :: (32 word, unit) R))) (\<lambda>ds\<^sub>2\<^sub>8. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>8 (\<lambda>ds\<^sub>2\<^sub>9. ((ex, mount_st, ostore_st), (R.Success () :: (32 word, unit) R)))) r)))) ((ex, mount_st, ostore_st), (R.Success () :: (32 word, unit) R))) r))))))) r))))))) r))))))"

definition
  fsop_fill_super :: " FsopFillSuperP\<^sub>T \<Rightarrow>  FsopFillSuperRR\<^sub>T \<times> ( FsopFillSuperE\<^sub>T,  FsState'Taken\<^sub>T) R"
where
  "fsop_fill_super ds\<^sub>0 \<equiv> HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>0 FsopFillSuperP.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2 FsopFillSuperP.fs_st\<^sub>f) (\<lambda>(ds\<^sub>4,ds\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>4 FsState.mount_st\<^sub>f) (\<lambda>(mount_st,fs_st). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3 FsopFillSuperP.vsup\<^sub>f) (\<lambda>(vsup,ds\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>5 FsopFillSuperP.is_silent\<^sub>f) (\<lambda>(is_silent,ds\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>6 FsopFillSuperP.root\<^sub>f) (\<lambda>(root,ds\<^sub>1). HOL.Let (wubi_vol_ubi_num (MountState.vol\<^sub>f mount_st)) (\<lambda>ubi_num. HOL.Let (wubi_vol_vol_id (MountState.vol\<^sub>f mount_st)) (\<lambda>vol_id. Let\<^sub>d\<^sub>s (wubi_open_volume (WubiOpenVolumeP.make ex ubi_num vol_id (2 :: 32 word))) (\<lambda>ds\<^sub>7. case_R (\<lambda>ex. Let\<^sub>d\<^sub>s () (\<lambda>ds\<^sub>9. (FsopFillSuperRR.make ex vsup root, (R.Error (FsopFillSuperE.make (2 :: 32 word) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) fs_st)) :: ( FsopFillSuperE\<^sub>T,  FsState'Taken\<^sub>T) R)))) (\<lambda>ds\<^sub>9. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>9 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>0 P2_p2\<^sub>f) (\<lambda>(ubi_vol,ds\<^sub>1\<^sub>1). HOL.Let (186104309 :: 64 word) (\<lambda>s_magic. HOL.Let (4096 :: 32 word) (\<lambda>s_blocksize. HOL.Let (12 :: 32 word) (\<lambda>s_blocksize_bits. HOL.Let ((-) (checked_shift shiftl (4096 :: 64 word) ((-) (32 :: 64 word) (1 :: 64 word))) (1 :: 64 word)) (\<lambda>s_maxbytes. HOL.Let (VfsMountInfo.s_maxbytes\<^sub>f_update (\<lambda>_. s_maxbytes) (VfsMountInfo.s_blocksize_bits\<^sub>f_update (\<lambda>_. s_blocksize_bits) (VfsMountInfo.s_blocksize\<^sub>f_update (\<lambda>_. s_blocksize) (VfsMountInfo.s_magic\<^sub>f_update (\<lambda>_. s_magic) vsup)))) (\<lambda>vsup. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t mount_st MountState.super\<^sub>f) (\<lambda>(super,mount_st). HOL.Let (wubi_vol_size (MountState.vol\<^sub>f mount_st)) (\<lambda>nb_eb. HOL.Let (wubi_vol_usable_leb_size (MountState.vol\<^sub>f mount_st)) (\<lambda>eb_size. HOL.Let (wubi_dev_min_io_size (MountState.dev\<^sub>f mount_st)) (\<lambda>io_size. HOL.Let (3 :: 32 word) (\<lambda>nb_reserved_gc. HOL.Let (3 :: 32 word) (\<lambda>nb_reserved_del. HOL.Let (2 :: 32 word) (\<lambda>cur_eb. HOL.Let (0 :: 32 word) (\<lambda>cur_offs. HOL.Let (0 :: 64 word) (\<lambda>next_sqnum. HOL.Let (0 :: 32 word) (\<lambda>last_inum. HOL.Let (ObjSuper.nb_reserved_del\<^sub>f_update (\<lambda>_. nb_reserved_del) (ObjSuper.nb_reserved_gc\<^sub>f_update (\<lambda>_. nb_reserved_gc) (ObjSuper.last_inum\<^sub>f_update (\<lambda>_. last_inum) (ObjSuper.next_sqnum\<^sub>f_update (\<lambda>_. next_sqnum) (ObjSuper.cur_offs\<^sub>f_update (\<lambda>_. cur_offs) (ObjSuper.cur_eb\<^sub>f_update (\<lambda>_. cur_eb) (ObjSuper.io_size\<^sub>f_update (\<lambda>_. io_size) (ObjSuper.eb_size\<^sub>f_update (\<lambda>_. eb_size) (ObjSuper.nb_eb\<^sub>f_update (\<lambda>_. nb_eb) super))))))))) (\<lambda>super. HOL.Let (0 :: 32 word) (\<lambda>super_offs. HOL.Let (MountState.super\<^sub>f_update (\<lambda>_. super) (MountState.super_offs\<^sub>f_update (\<lambda>_. super_offs) mount_st)) (\<lambda>mount_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st). Let\<^sub>d\<^sub>s (newFsState ex) (\<lambda>ds\<^sub>1\<^sub>2. case_R (\<lambda>ex. HOL.Let (wubi_close (ex, ubi_vol)) (\<lambda>ex. (FsopFillSuperRR.make ex vsup root, (R.Error (FsopFillSuperE.make (12 :: 32 word) (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) fs_st))) :: ( FsopFillSuperE\<^sub>T,  FsState'Taken\<^sub>T) R)))) (\<lambda>ds\<^sub>1\<^sub>4. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>4 P2_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>1\<^sub>5). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>5 P2_p2\<^sub>f) (\<lambda>(fs_st',ds\<^sub>1\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st FsState.fsop_st\<^sub>f) (\<lambda>(fsop_st,fs_st). HOL.Let (OstoreState.ubi_vol\<^sub>f_update (\<lambda>_. ubi_vol) ostore_st) (\<lambda>ostore_st. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (ostore_mount (ex, mount_st, ostore_st)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>1\<^sub>7,ds\<^sub>1\<^sub>8). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>8 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>1\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>1\<^sub>7 P3_p1\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>0 P3_p2\<^sub>f) (\<lambda>(mount_st,ds\<^sub>2\<^sub>1). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>1 P3_p3\<^sub>f) (\<lambda>(ostore_st,ds\<^sub>2\<^sub>2). case_R (\<lambda>err. HOL.If ((=) err (42 :: 32 word)) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t (fsop_format_default (FsopIgetRR.make ex (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) (FsState.fsop_st\<^sub>f_update (\<lambda>_. fsop_st) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) fs_st'))) root)) P2_p1\<^sub>f) (\<lambda>(ds\<^sub>2\<^sub>5,ds\<^sub>2\<^sub>6). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>6 P2_p2\<^sub>f) (\<lambda>(r,ds\<^sub>2\<^sub>7). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>5 FsopIgetRR.ex\<^sub>f) (\<lambda>(ex,ds\<^sub>2\<^sub>9). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>2\<^sub>9 FsopIgetRR.fs_st\<^sub>f) (\<lambda>(fs_st',ds\<^sub>3\<^sub>0). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>0 FsopIgetRR.vnode\<^sub>f) (\<lambda>(root,ds\<^sub>2\<^sub>8). case_R (\<lambda>err. HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t fs_st' FsState.mount_st\<^sub>f) (\<lambda>(mount_st,ds\<^sub>3\<^sub>2). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>2 FsState.fsop_st\<^sub>f) (\<lambda>(fsop_st,ds\<^sub>3\<^sub>3). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ds\<^sub>3\<^sub>3 FsState.ostore_st\<^sub>f) (\<lambda>(ostore_st,fs_st'). HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.ubi_vol\<^sub>f) (\<lambda>(ubi_vol,ostore_st). HOL.Let (wubi_close (ex, ubi_vol)) (\<lambda>ex. HOL.Let (freeFsState (ex, fs_st')) (\<lambda>ex. HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) (FsState.fsop_st\<^sub>f_update (\<lambda>_. fsop_st) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) fs_st))) (\<lambda>fs_st. (FsopFillSuperRR.make ex vsup root, (R.Error (FsopFillSuperE.make err fs_st) :: ( FsopFillSuperE\<^sub>T,  FsState'Taken\<^sub>T) R)))))))))) (\<lambda>ds\<^sub>3\<^sub>2. Let\<^sub>d\<^sub>s ds\<^sub>3\<^sub>2 (\<lambda>ds\<^sub>3\<^sub>3. HOL.Let (freeFsState2 (ex, fs_st)) (\<lambda>ex. HOL.Let (vfs_inode_set_ino (root, (24 :: 32 word))) (\<lambda>root. (FsopFillSuperRR.make ex vsup root, (R.Success fs_st' :: ( FsopFillSuperE\<^sub>T,  FsState'Taken\<^sub>T) R)))))) r)))))) (HOL.Let (take\<^sub>c\<^sub>o\<^sub>g\<^sub>e\<^sub>n\<^sub>t ostore_st OstoreState.ubi_vol\<^sub>f) (\<lambda>(ubi_vol,ostore_st). HOL.Let (wubi_close (ex, ubi_vol)) (\<lambda>ex. HOL.Let (freeFsState (ex, fs_st')) (\<lambda>ex. HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) (FsState.fsop_st\<^sub>f_update (\<lambda>_. fsop_st) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) fs_st))) (\<lambda>fs_st. (FsopFillSuperRR.make ex vsup root, (R.Error (FsopFillSuperE.make err fs_st) :: ( FsopFillSuperE\<^sub>T,  FsState'Taken\<^sub>T) R)))))))) (\<lambda>ds\<^sub>2\<^sub>3. Let\<^sub>d\<^sub>s ds\<^sub>2\<^sub>3 (\<lambda>ds\<^sub>2\<^sub>5. HOL.Let (freeFsState2 (ex, fs_st)) (\<lambda>ex. HOL.Let (FsState.ostore_st\<^sub>f_update (\<lambda>_. ostore_st) (FsState.mount_st\<^sub>f_update (\<lambda>_. mount_st) (FsState.fsop_st\<^sub>f_update (\<lambda>_. fsop_st) fs_st'))) (\<lambda>fs_st. HOL.Let (vfs_inode_set_ino (root, (24 :: 32 word))) (\<lambda>root. (FsopFillSuperRR.make ex vsup root, (R.Success fs_st :: ( FsopFillSuperE\<^sub>T,  FsState'Taken\<^sub>T) R))))))) r)))))))))) ds\<^sub>1\<^sub>2))))))))))))))))))))))) ds\<^sub>7)))))))))"

end
